/* rrapi_Stub.h
   Generated by gSOAP 2.8.109 for api.radioreference.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://api.radioreference.com/soap2"

#ifndef rrapi_Stub_H
#define rrapi_Stub_H
#ifndef WITH_NONAMESPACES
#define WITH_NONAMESPACES
#endif
#include "stdsoap2.h"
#if GSOAP_VERSION != 208109
# error "GSOAP VERSION 208109 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class SOAP_ENC__Array;	/* api.radioreference.h:152 */
class ns1__authInfo;	/* api.radioreference.h:171 */
class ns1__userFeedBroadcast;	/* api.radioreference.h:173 */
class ns1__Talkgroup;	/* api.radioreference.h:181 */
class ns1__TalkgroupCat;	/* api.radioreference.h:185 */
class ns1__TrsSite;	/* api.radioreference.h:189 */
class ns1__TrsSiteFreq;	/* api.radioreference.h:193 */
class ns1__TrsSiteLicense;	/* api.radioreference.h:197 */
class ns1__Trs;	/* api.radioreference.h:201 */
class ns1__TrsListDef;	/* api.radioreference.h:203 */
class ns1__trsSysidDef;	/* api.radioreference.h:207 */
class ns1__trsBandplanDef;	/* api.radioreference.h:211 */
class ns1__TrsFleetmap;	/* api.radioreference.h:215 */
class ns1__trsTypeDef;	/* api.radioreference.h:217 */
class ns1__trsFlavorDef;	/* api.radioreference.h:221 */
class ns1__trsVoiceDef;	/* api.radioreference.h:225 */
class ns1__freq;	/* api.radioreference.h:229 */
class ns1__searchFreqResult;	/* api.radioreference.h:231 */
class ns1__cat;	/* api.radioreference.h:239 */
class ns1__subcat;	/* api.radioreference.h:243 */
class ns1__AgencyInfo;	/* api.radioreference.h:245 */
class ns1__CountryInfo;	/* api.radioreference.h:247 */
class ns1__CountyInfo;	/* api.radioreference.h:249 */
class ns1__StateInfo;	/* api.radioreference.h:251 */
class ns1__County;	/* api.radioreference.h:253 */
class ns1__ctid;	/* api.radioreference.h:259 */
class ns1__State;	/* api.radioreference.h:263 */
class ns1__Metro;	/* api.radioreference.h:267 */
class ns1__Country;	/* api.radioreference.h:271 */
class ns1__Agency;	/* api.radioreference.h:275 */
class ns1__stid;	/* api.radioreference.h:279 */
class ns1__sid;	/* api.radioreference.h:283 */
class ns1__tag;	/* api.radioreference.h:287 */
class ns1__mode;	/* api.radioreference.h:291 */
class ns1__ZipInfo;	/* api.radioreference.h:293 */
class ns1__UserInfo;	/* api.radioreference.h:295 */
class ns1__fccCallsignDetails;	/* api.radioreference.h:297 */
class ns1__fccFrequency;	/* api.radioreference.h:299 */
class ns1__fccLocation;	/* api.radioreference.h:303 */
class ns1__proxCallsignResult;	/* api.radioreference.h:307 */
class ns1__fccRadioServiceCode;	/* api.radioreference.h:311 */
class userFeedBroadcasts;	/* api.radioreference.h:175 */
class stidList;	/* api.radioreference.h:177 */
class ctidList;	/* api.radioreference.h:179 */
class Talkgroups;	/* api.radioreference.h:183 */
class TalkgroupCats;	/* api.radioreference.h:187 */
class TrsSites;	/* api.radioreference.h:191 */
class TrsSiteFreqs;	/* api.radioreference.h:195 */
class TrsSiteLicenses;	/* api.radioreference.h:199 */
class TrsList;	/* api.radioreference.h:205 */
class TrsSysid;	/* api.radioreference.h:209 */
class TrsBandplan;	/* api.radioreference.h:213 */
class TrsType;	/* api.radioreference.h:219 */
class TrsFlavor;	/* api.radioreference.h:223 */
class TrsVoice;	/* api.radioreference.h:227 */
class searchFreqResults;	/* api.radioreference.h:233 */
class Freqs;	/* api.radioreference.h:235 */
class Cats;	/* api.radioreference.h:237 */
class SubCats;	/* api.radioreference.h:241 */
class Counties;	/* api.radioreference.h:255 */
class ctids;	/* api.radioreference.h:257 */
class States;	/* api.radioreference.h:261 */
class Metros;	/* api.radioreference.h:265 */
class Countries;	/* api.radioreference.h:269 */
class Agencies;	/* api.radioreference.h:273 */
class stids;	/* api.radioreference.h:277 */
class sids;	/* api.radioreference.h:281 */
class tags;	/* api.radioreference.h:285 */
class modes;	/* api.radioreference.h:289 */
class fccFrequencies;	/* api.radioreference.h:301 */
class fccLocations;	/* api.radioreference.h:305 */
class proxCallsignResults;	/* api.radioreference.h:309 */
class fccRadioServiceCodes;	/* api.radioreference.h:313 */
struct ns1__getTrsTalkgroupsResponse;	/* api.radioreference.h:2552 */
struct ns1__getTrsTalkgroups;	/* api.radioreference.h:2633 */
struct ns1__getTrsTalkgroupCatsResponse;	/* api.radioreference.h:2644 */
struct ns1__getTrsTalkgroupCats;	/* api.radioreference.h:2712 */
struct ns1__getTrsDetailsResponse;	/* api.radioreference.h:2723 */
struct ns1__getTrsDetails;	/* api.radioreference.h:2791 */
struct ns1__getTrsBySysidResponse;	/* api.radioreference.h:2802 */
struct ns1__getTrsBySysid;	/* api.radioreference.h:2870 */
struct ns1__getTrsSitesResponse;	/* api.radioreference.h:2881 */
struct ns1__getTrsSites;	/* api.radioreference.h:2949 */
struct ns1__getStatesByListResponse;	/* api.radioreference.h:2960 */
struct ns1__getStatesByList;	/* api.radioreference.h:3028 */
struct ns1__getCountiesByListResponse;	/* api.radioreference.h:3039 */
struct ns1__getCountiesByList;	/* api.radioreference.h:3107 */
struct ns1__getTagResponse;	/* api.radioreference.h:3118 */
struct ns1__getTag;	/* api.radioreference.h:3187 */
struct ns1__getModeResponse;	/* api.radioreference.h:3198 */
struct ns1__getMode;	/* api.radioreference.h:3267 */
struct ns1__getTrsTypeResponse;	/* api.radioreference.h:3278 */
struct ns1__getTrsType;	/* api.radioreference.h:3347 */
struct ns1__getTrsFlavorResponse;	/* api.radioreference.h:3358 */
struct ns1__getTrsFlavor;	/* api.radioreference.h:3427 */
struct ns1__getTrsVoiceResponse;	/* api.radioreference.h:3438 */
struct ns1__getTrsVoice;	/* api.radioreference.h:3507 */
struct ns1__getCountryListResponse;	/* api.radioreference.h:3518 */
struct ns1__getCountryList;	/* api.radioreference.h:3580 */
struct ns1__getCountryInfoResponse;	/* api.radioreference.h:3591 */
struct ns1__getCountryInfo;	/* api.radioreference.h:3659 */
struct ns1__getStateInfoResponse;	/* api.radioreference.h:3670 */
struct ns1__getStateInfo;	/* api.radioreference.h:3739 */
struct ns1__getCountyInfoResponse;	/* api.radioreference.h:3750 */
struct ns1__getCountyInfo;	/* api.radioreference.h:3819 */
struct ns1__getAgencyInfoResponse;	/* api.radioreference.h:3830 */
struct ns1__getAgencyInfo;	/* api.radioreference.h:3899 */
struct ns1__getSubcatFreqsResponse;	/* api.radioreference.h:3910 */
struct ns1__getSubcatFreqs;	/* api.radioreference.h:3978 */
struct ns1__searchCountyFreqResponse;	/* api.radioreference.h:3989 */
struct ns1__searchCountyFreq;	/* api.radioreference.h:4065 */
struct ns1__searchStateFreqResponse;	/* api.radioreference.h:4076 */
struct ns1__searchStateFreq;	/* api.radioreference.h:4152 */
struct ns1__searchMetroFreqResponse;	/* api.radioreference.h:4163 */
struct ns1__searchMetroFreq;	/* api.radioreference.h:4239 */
struct ns1__getCountyFreqsByTagResponse;	/* api.radioreference.h:4250 */
struct ns1__getCountyFreqsByTag;	/* api.radioreference.h:4321 */
struct ns1__getAgencyFreqsByTagResponse;	/* api.radioreference.h:4332 */
struct ns1__getAgencyFreqsByTag;	/* api.radioreference.h:4403 */
struct ns1__getMetroAreaResponse;	/* api.radioreference.h:4414 */
struct ns1__getMetroArea;	/* api.radioreference.h:4483 */
struct ns1__getMetroAreaInfoResponse;	/* api.radioreference.h:4494 */
struct ns1__getMetroAreaInfo;	/* api.radioreference.h:4562 */
struct ns1__getZipcodeInfoResponse;	/* api.radioreference.h:4573 */
struct ns1__getZipcodeInfo;	/* api.radioreference.h:4641 */
struct ns1__fccGetCallsignResponse;	/* api.radioreference.h:4652 */
struct ns1__fccGetCallsign;	/* api.radioreference.h:4720 */
struct ns1__fccGetRadioServiceCodeResponse;	/* api.radioreference.h:4731 */
struct ns1__fccGetRadioServiceCode;	/* api.radioreference.h:4800 */
struct ns1__fccGetProxCallsignsResponse;	/* api.radioreference.h:4811 */
struct ns1__fccGetProxCallsigns;	/* api.radioreference.h:4891 */
struct ns1__getUserDataResponse;	/* api.radioreference.h:4902 */
struct ns1__getUserData;	/* api.radioreference.h:4967 */
struct ns1__getUserFeedBroadcastsResponse;	/* api.radioreference.h:4978 */
struct ns1__getUserFeedBroadcasts;	/* api.radioreference.h:5043 */

/* api.radioreference.h:152 */
#ifndef SOAP_TYPE_SOAP_ENC__Array
#define SOAP_TYPE_SOAP_ENC__Array (8)
/* Sequence of SOAP-ENC:Array schema type: */
class SOAP_CMAC SOAP_ENC__Array {
      public:
        char **__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_SOAP_ENC__Array
        virtual long soap_type(void) const { return SOAP_TYPE_SOAP_ENC__Array; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SOAP_ENC__Array, default initialized and not managed by a soap context
        virtual SOAP_ENC__Array *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SOAP_ENC__Array); }
      public:
        /// Constructor with default initializations
        SOAP_ENC__Array() : __ptr(), __size() { }
        virtual ~SOAP_ENC__Array() { }
        /// Friend allocator used by soap_new_SOAP_ENC__Array(struct soap*, int)
        friend SOAP_FMAC1 SOAP_ENC__Array * SOAP_FMAC2 rrapi__instantiate_SOAP_ENC__Array(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:171 */
#ifndef SOAP_TYPE_ns1__authInfo
#define SOAP_TYPE_ns1__authInfo (12)
/* complex XML schema type 'ns1:authInfo': */
class SOAP_CMAC ns1__authInfo {
      public:
        /// Required element 'username' of XML schema type 'xsd:string'
        std::string username;
        /// Required element 'password' of XML schema type 'xsd:string'
        std::string password;
        /// Required element 'appKey' of XML schema type 'xsd:string'
        std::string appKey;
        /// Required element 'version' of XML schema type 'xsd:string'
        std::string version;
        /// Required element 'style' of XML schema type 'xsd:string'
        std::string style;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__authInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__authInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__authInfo, default initialized and not managed by a soap context
        virtual ns1__authInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__authInfo); }
      public:
        /// Constructor with default initializations
        ns1__authInfo() : username(), password(), appKey(), version(), style(), soap() { }
        virtual ~ns1__authInfo() { }
        /// Friend allocator used by soap_new_ns1__authInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__authInfo * SOAP_FMAC2 rrapi__instantiate_ns1__authInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:173 */
#ifndef SOAP_TYPE_ns1__userFeedBroadcast
#define SOAP_TYPE_ns1__userFeedBroadcast (13)
/* complex XML schema type 'ns1:userFeedBroadcast': */
class SOAP_CMAC ns1__userFeedBroadcast {
      public:
        /// Required element 'feedId' of XML schema type 'xsd:int'
        int feedId;
        /// Required element 'descr' of XML schema type 'xsd:string'
        std::string descr;
        /// Required element 'hostname' of XML schema type 'xsd:string'
        std::string hostname;
        /// Required element 'port' of XML schema type 'xsd:string'
        std::string port;
        /// Required element 'mount' of XML schema type 'xsd:string'
        std::string mount;
        /// Required element 'password' of XML schema type 'xsd:string'
        std::string password;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__userFeedBroadcast
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__userFeedBroadcast; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__userFeedBroadcast, default initialized and not managed by a soap context
        virtual ns1__userFeedBroadcast *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__userFeedBroadcast); }
      public:
        /// Constructor with default initializations
        ns1__userFeedBroadcast() : feedId(), descr(), hostname(), port(), mount(), password(), soap() { }
        virtual ~ns1__userFeedBroadcast() { }
        /// Friend allocator used by soap_new_ns1__userFeedBroadcast(struct soap*, int)
        friend SOAP_FMAC1 ns1__userFeedBroadcast * SOAP_FMAC2 rrapi__instantiate_ns1__userFeedBroadcast(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:181 */
#ifndef SOAP_TYPE_ns1__Talkgroup
#define SOAP_TYPE_ns1__Talkgroup (17)
/* complex XML schema type 'ns1:Talkgroup': */
class SOAP_CMAC ns1__Talkgroup {
      public:
        /// Required element 'tgId' of XML schema type 'xsd:int'
        int tgId;
        /// Required element 'tgDec' of XML schema type 'xsd:int'
        int tgDec;
        /// Required element 'tgSubfleet' of XML schema type 'xsd:string'
        std::string tgSubfleet;
        /// Required element 'tgLtr' of XML schema type 'xsd:boolean'
        bool tgLtr;
        /// Required element 'tgSlot' of XML schema type 'xsd:string'
        std::string tgSlot;
        /// Required element 'tgDescr' of XML schema type 'xsd:string'
        std::string tgDescr;
        /// Required element 'tgAlpha' of XML schema type 'xsd:string'
        std::string tgAlpha;
        /// Required element 'tgMode' of XML schema type 'xsd:string'
        std::string tgMode;
        /// Required element 'enc' of XML schema type 'xsd:int'
        int enc;
        /// Required element 'tags' of XML schema type 'ArrayOftag'
        tags *tags_;
        /// Required element 'tgCid' of XML schema type 'xsd:int'
        int tgCid;
        /// Required element 'tgSort' of XML schema type 'xsd:int'
        int tgSort;
        /// Required element 'tgDate' of XML schema type 'xsd:dateTime'
        time_t tgDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Talkgroup
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Talkgroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Talkgroup, default initialized and not managed by a soap context
        virtual ns1__Talkgroup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Talkgroup); }
      public:
        /// Constructor with default initializations
        ns1__Talkgroup() : tgId(), tgDec(), tgSubfleet(), tgLtr(), tgSlot(), tgDescr(), tgAlpha(), tgMode(), enc(), tags_(), tgCid(), tgSort(), tgDate(), soap() { }
        virtual ~ns1__Talkgroup() { }
        /// Friend allocator used by soap_new_ns1__Talkgroup(struct soap*, int)
        friend SOAP_FMAC1 ns1__Talkgroup * SOAP_FMAC2 rrapi__instantiate_ns1__Talkgroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:185 */
#ifndef SOAP_TYPE_ns1__TalkgroupCat
#define SOAP_TYPE_ns1__TalkgroupCat (19)
/* complex XML schema type 'ns1:TalkgroupCat': */
class SOAP_CMAC ns1__TalkgroupCat {
      public:
        /// Required element 'tgCid' of XML schema type 'xsd:int'
        int tgCid;
        /// Required element 'sid' of XML schema type 'xsd:int'
        int sid;
        /// Required element 'tgCname' of XML schema type 'xsd:string'
        std::string tgCname;
        /// Required element 'tgSort' of XML schema type 'xsd:int'
        int tgSort;
        /// Required element 'tgSortBy' of XML schema type 'xsd:int'
        int tgSortBy;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'range' of XML schema type 'xsd:decimal'
        std::string range;
        /// Required element 'lastUpdated' of XML schema type 'xsd:dateTime'
        time_t lastUpdated;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TalkgroupCat
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TalkgroupCat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TalkgroupCat, default initialized and not managed by a soap context
        virtual ns1__TalkgroupCat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TalkgroupCat); }
      public:
        /// Constructor with default initializations
        ns1__TalkgroupCat() : tgCid(), sid(), tgCname(), tgSort(), tgSortBy(), lat(), lon(), range(), lastUpdated(), soap() { }
        virtual ~ns1__TalkgroupCat() { }
        /// Friend allocator used by soap_new_ns1__TalkgroupCat(struct soap*, int)
        friend SOAP_FMAC1 ns1__TalkgroupCat * SOAP_FMAC2 rrapi__instantiate_ns1__TalkgroupCat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:189 */
#ifndef SOAP_TYPE_ns1__TrsSite
#define SOAP_TYPE_ns1__TrsSite (21)
/* complex XML schema type 'ns1:TrsSite': */
class SOAP_CMAC ns1__TrsSite {
      public:
        /// Required element 'siteId' of XML schema type 'xsd:int'
        int siteId;
        /// Required element 'sid' of XML schema type 'xsd:int'
        int sid;
        /// Required element 'siteNumber' of XML schema type 'xsd:int'
        int siteNumber;
        /// Required element 'siteDescr' of XML schema type 'xsd:string'
        std::string siteDescr;
        /// Required element 'zoneNumber' of XML schema type 'xsd:int'
        int zoneNumber;
        /// Required element 'zoneDescr' of XML schema type 'xsd:string'
        std::string zoneDescr;
        /// Required element 'rfss' of XML schema type 'xsd:int'
        int rfss;
        /// Required element 'nac' of XML schema type 'xsd:string'
        std::string nac;
        /// Required element 'ran' of XML schema type 'xsd:int'
        int ran;
        /// Required element 'siteNeighbors' of XML schema type 'xsd:string'
        std::string siteNeighbors;
        /// Required element 'siteLocation' of XML schema type 'xsd:string'
        std::string siteLocation;
        /// Required element 'siteCtid' of XML schema type 'xsd:int'
        int siteCtid;
        /// Required element 'siteCt' of XML schema type 'xsd:string'
        std::string siteCt;
        /// Required element 'siteModulation' of XML schema type 'xsd:string'
        std::string siteModulation;
        /// Required element 'siteNotes' of XML schema type 'xsd:string'
        std::string siteNotes;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'range' of XML schema type 'xsd:decimal'
        std::string range;
        /// Required element 'splinter' of XML schema type 'xsd:int'
        int splinter;
        /// Required element 'rebanded' of XML schema type 'xsd:int'
        int rebanded;
        /// Required element 'siteLicenses' of XML schema type 'ArrayOfTrsSiteLicense'
        TrsSiteLicenses *siteLicenses;
        /// Required element 'siteFreqs' of XML schema type 'ArrayOfTrsSiteFreq'
        TrsSiteFreqs *siteFreqs;
        /// Required element 'bandplan' of XML schema type 'ArrayOftrsBandplanDef'
        TrsBandplan *bandplan;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TrsSite
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TrsSite; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TrsSite, default initialized and not managed by a soap context
        virtual ns1__TrsSite *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TrsSite); }
      public:
        /// Constructor with default initializations
        ns1__TrsSite() : siteId(), sid(), siteNumber(), siteDescr(), zoneNumber(), zoneDescr(), rfss(), nac(), ran(), siteNeighbors(), siteLocation(), siteCtid(), siteCt(), siteModulation(), siteNotes(), lat(), lon(), range(), splinter(), rebanded(), siteLicenses(), siteFreqs(), bandplan(), soap() { }
        virtual ~ns1__TrsSite() { }
        /// Friend allocator used by soap_new_ns1__TrsSite(struct soap*, int)
        friend SOAP_FMAC1 ns1__TrsSite * SOAP_FMAC2 rrapi__instantiate_ns1__TrsSite(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:193 */
#ifndef SOAP_TYPE_ns1__TrsSiteFreq
#define SOAP_TYPE_ns1__TrsSiteFreq (23)
/* complex XML schema type 'ns1:TrsSiteFreq': */
class SOAP_CMAC ns1__TrsSiteFreq {
      public:
        /// Required element 'lcn' of XML schema type 'xsd:int'
        int lcn;
        /// Required element 'freq' of XML schema type 'xsd:decimal'
        std::string freq;
        /// Required element 'use' of XML schema type 'xsd:string'
        std::string use;
        /// Required element 'colorCode' of XML schema type 'xsd:string'
        std::string colorCode;
        /// Required element 'ch_id' of XML schema type 'xsd:string'
        std::string ch_USCOREid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TrsSiteFreq
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TrsSiteFreq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TrsSiteFreq, default initialized and not managed by a soap context
        virtual ns1__TrsSiteFreq *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TrsSiteFreq); }
      public:
        /// Constructor with default initializations
        ns1__TrsSiteFreq() : lcn(), freq(), use(), colorCode(), ch_USCOREid(), soap() { }
        virtual ~ns1__TrsSiteFreq() { }
        /// Friend allocator used by soap_new_ns1__TrsSiteFreq(struct soap*, int)
        friend SOAP_FMAC1 ns1__TrsSiteFreq * SOAP_FMAC2 rrapi__instantiate_ns1__TrsSiteFreq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:197 */
#ifndef SOAP_TYPE_ns1__TrsSiteLicense
#define SOAP_TYPE_ns1__TrsSiteLicense (25)
/* complex XML schema type 'ns1:TrsSiteLicense': */
class SOAP_CMAC ns1__TrsSiteLicense {
      public:
        /// Required element 'license' of XML schema type 'xsd:string'
        std::string license;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TrsSiteLicense
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TrsSiteLicense; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TrsSiteLicense, default initialized and not managed by a soap context
        virtual ns1__TrsSiteLicense *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TrsSiteLicense); }
      public:
        /// Constructor with default initializations
        ns1__TrsSiteLicense() : license(), soap() { }
        virtual ~ns1__TrsSiteLicense() { }
        /// Friend allocator used by soap_new_ns1__TrsSiteLicense(struct soap*, int)
        friend SOAP_FMAC1 ns1__TrsSiteLicense * SOAP_FMAC2 rrapi__instantiate_ns1__TrsSiteLicense(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:201 */
#ifndef SOAP_TYPE_ns1__Trs
#define SOAP_TYPE_ns1__Trs (27)
/* complex XML schema type 'ns1:Trs': */
class SOAP_CMAC ns1__Trs {
      public:
        /// Required element 'sName' of XML schema type 'xsd:string'
        std::string sName;
        /// Required element 'sType' of XML schema type 'xsd:int'
        int sType;
        /// Required element 'sFlavor' of XML schema type 'xsd:int'
        int sFlavor;
        /// Required element 'sVoice' of XML schema type 'xsd:int'
        int sVoice;
        /// Required element 'sCity' of XML schema type 'xsd:string'
        std::string sCity;
        /// Required element 'sCounty' of XML schema type 'ArrayOfctid'
        ctids *sCounty;
        /// Required element 'sState' of XML schema type 'ArrayOfstid'
        stids *sState;
        /// Required element 'sCountry' of XML schema type 'xsd:string'
        std::string sCountry;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'range' of XML schema type 'xsd:decimal'
        std::string range;
        /// Required element 'lastUpdated' of XML schema type 'xsd:dateTime'
        time_t lastUpdated;
        /// Required element 'sysid' of XML schema type 'ArrayOftrsSysidDef'
        TrsSysid *sysid;
        /// Required element 'bandplan' of XML schema type 'ArrayOftrsBandplanDef'
        TrsBandplan *bandplan;
        /// Required element 'fleetmap' of XML schema type 'ns1:TrsFleetmap'
        ns1__TrsFleetmap *fleetmap;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Trs
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Trs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Trs, default initialized and not managed by a soap context
        virtual ns1__Trs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Trs); }
      public:
        /// Constructor with default initializations
        ns1__Trs() : sName(), sType(), sFlavor(), sVoice(), sCity(), sCounty(), sState(), sCountry(), lat(), lon(), range(), lastUpdated(), sysid(), bandplan(), fleetmap(), soap() { }
        virtual ~ns1__Trs() { }
        /// Friend allocator used by soap_new_ns1__Trs(struct soap*, int)
        friend SOAP_FMAC1 ns1__Trs * SOAP_FMAC2 rrapi__instantiate_ns1__Trs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:203 */
#ifndef SOAP_TYPE_ns1__TrsListDef
#define SOAP_TYPE_ns1__TrsListDef (28)
/* complex XML schema type 'ns1:TrsListDef': */
class SOAP_CMAC ns1__TrsListDef {
      public:
        /// Required element 'sid' of XML schema type 'xsd:int'
        int sid;
        /// Required element 'sName' of XML schema type 'xsd:string'
        std::string sName;
        /// Required element 'sType' of XML schema type 'xsd:int'
        int sType;
        /// Required element 'sFlavor' of XML schema type 'xsd:int'
        int sFlavor;
        /// Required element 'sVoice' of XML schema type 'xsd:int'
        int sVoice;
        /// Required element 'sCity' of XML schema type 'xsd:string'
        std::string sCity;
        /// Required element 'lastUpdated' of XML schema type 'xsd:dateTime'
        time_t lastUpdated;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TrsListDef
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TrsListDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TrsListDef, default initialized and not managed by a soap context
        virtual ns1__TrsListDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TrsListDef); }
      public:
        /// Constructor with default initializations
        ns1__TrsListDef() : sid(), sName(), sType(), sFlavor(), sVoice(), sCity(), lastUpdated(), soap() { }
        virtual ~ns1__TrsListDef() { }
        /// Friend allocator used by soap_new_ns1__TrsListDef(struct soap*, int)
        friend SOAP_FMAC1 ns1__TrsListDef * SOAP_FMAC2 rrapi__instantiate_ns1__TrsListDef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:207 */
#ifndef SOAP_TYPE_ns1__trsSysidDef
#define SOAP_TYPE_ns1__trsSysidDef (30)
/* complex XML schema type 'ns1:trsSysidDef': */
class SOAP_CMAC ns1__trsSysidDef {
      public:
        /// Required element 'sysid' of XML schema type 'xsd:string'
        std::string sysid;
        /// Required element 'ct' of XML schema type 'xsd:string'
        std::string ct;
        /// Required element 'wacn' of XML schema type 'xsd:string'
        std::string wacn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__trsSysidDef
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__trsSysidDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__trsSysidDef, default initialized and not managed by a soap context
        virtual ns1__trsSysidDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__trsSysidDef); }
      public:
        /// Constructor with default initializations
        ns1__trsSysidDef() : sysid(), ct(), wacn(), soap() { }
        virtual ~ns1__trsSysidDef() { }
        /// Friend allocator used by soap_new_ns1__trsSysidDef(struct soap*, int)
        friend SOAP_FMAC1 ns1__trsSysidDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsSysidDef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:211 */
#ifndef SOAP_TYPE_ns1__trsBandplanDef
#define SOAP_TYPE_ns1__trsBandplanDef (32)
/* complex XML schema type 'ns1:trsBandplanDef': */
class SOAP_CMAC ns1__trsBandplanDef {
      public:
        /// Required element 'base' of XML schema type 'xsd:string'
        std::string base;
        /// Required element 'spacing' of XML schema type 'xsd:string'
        std::string spacing;
        /// Required element 'offset' of XML schema type 'xsd:string'
        std::string offset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__trsBandplanDef
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__trsBandplanDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__trsBandplanDef, default initialized and not managed by a soap context
        virtual ns1__trsBandplanDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__trsBandplanDef); }
      public:
        /// Constructor with default initializations
        ns1__trsBandplanDef() : base(), spacing(), offset(), soap() { }
        virtual ~ns1__trsBandplanDef() { }
        /// Friend allocator used by soap_new_ns1__trsBandplanDef(struct soap*, int)
        friend SOAP_FMAC1 ns1__trsBandplanDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsBandplanDef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:215 */
#ifndef SOAP_TYPE_ns1__TrsFleetmap
#define SOAP_TYPE_ns1__TrsFleetmap (34)
/* complex XML schema type 'ns1:TrsFleetmap': */
class SOAP_CMAC ns1__TrsFleetmap {
      public:
        /// Required element 'b0' of XML schema type 'xsd:string'
        std::string b0;
        /// Required element 'b1' of XML schema type 'xsd:string'
        std::string b1;
        /// Required element 'b2' of XML schema type 'xsd:string'
        std::string b2;
        /// Required element 'b3' of XML schema type 'xsd:string'
        std::string b3;
        /// Required element 'b4' of XML schema type 'xsd:string'
        std::string b4;
        /// Required element 'b5' of XML schema type 'xsd:string'
        std::string b5;
        /// Required element 'b6' of XML schema type 'xsd:string'
        std::string b6;
        /// Required element 'b7' of XML schema type 'xsd:string'
        std::string b7;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TrsFleetmap
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__TrsFleetmap; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TrsFleetmap, default initialized and not managed by a soap context
        virtual ns1__TrsFleetmap *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__TrsFleetmap); }
      public:
        /// Constructor with default initializations
        ns1__TrsFleetmap() : b0(), b1(), b2(), b3(), b4(), b5(), b6(), b7(), soap() { }
        virtual ~ns1__TrsFleetmap() { }
        /// Friend allocator used by soap_new_ns1__TrsFleetmap(struct soap*, int)
        friend SOAP_FMAC1 ns1__TrsFleetmap * SOAP_FMAC2 rrapi__instantiate_ns1__TrsFleetmap(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:217 */
#ifndef SOAP_TYPE_ns1__trsTypeDef
#define SOAP_TYPE_ns1__trsTypeDef (35)
/* complex XML schema type 'ns1:trsTypeDef': */
class SOAP_CMAC ns1__trsTypeDef {
      public:
        /// Required element 'sType' of XML schema type 'xsd:int'
        int sType;
        /// Required element 'sTypeDescr' of XML schema type 'xsd:string'
        std::string sTypeDescr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__trsTypeDef
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__trsTypeDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__trsTypeDef, default initialized and not managed by a soap context
        virtual ns1__trsTypeDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__trsTypeDef); }
      public:
        /// Constructor with default initializations
        ns1__trsTypeDef() : sType(), sTypeDescr(), soap() { }
        virtual ~ns1__trsTypeDef() { }
        /// Friend allocator used by soap_new_ns1__trsTypeDef(struct soap*, int)
        friend SOAP_FMAC1 ns1__trsTypeDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsTypeDef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:221 */
#ifndef SOAP_TYPE_ns1__trsFlavorDef
#define SOAP_TYPE_ns1__trsFlavorDef (37)
/* complex XML schema type 'ns1:trsFlavorDef': */
class SOAP_CMAC ns1__trsFlavorDef {
      public:
        /// Required element 'sType' of XML schema type 'xsd:int'
        int sType;
        /// Required element 'sFlavor' of XML schema type 'xsd:int'
        int sFlavor;
        /// Required element 'sFlavorDescr' of XML schema type 'xsd:string'
        std::string sFlavorDescr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__trsFlavorDef
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__trsFlavorDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__trsFlavorDef, default initialized and not managed by a soap context
        virtual ns1__trsFlavorDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__trsFlavorDef); }
      public:
        /// Constructor with default initializations
        ns1__trsFlavorDef() : sType(), sFlavor(), sFlavorDescr(), soap() { }
        virtual ~ns1__trsFlavorDef() { }
        /// Friend allocator used by soap_new_ns1__trsFlavorDef(struct soap*, int)
        friend SOAP_FMAC1 ns1__trsFlavorDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsFlavorDef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:225 */
#ifndef SOAP_TYPE_ns1__trsVoiceDef
#define SOAP_TYPE_ns1__trsVoiceDef (39)
/* complex XML schema type 'ns1:trsVoiceDef': */
class SOAP_CMAC ns1__trsVoiceDef {
      public:
        /// Required element 'sType' of XML schema type 'xsd:int'
        int sType;
        /// Required element 'sVoice' of XML schema type 'xsd:int'
        int sVoice;
        /// Required element 'sVoiceDescr' of XML schema type 'xsd:string'
        std::string sVoiceDescr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__trsVoiceDef
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__trsVoiceDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__trsVoiceDef, default initialized and not managed by a soap context
        virtual ns1__trsVoiceDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__trsVoiceDef); }
      public:
        /// Constructor with default initializations
        ns1__trsVoiceDef() : sType(), sVoice(), sVoiceDescr(), soap() { }
        virtual ~ns1__trsVoiceDef() { }
        /// Friend allocator used by soap_new_ns1__trsVoiceDef(struct soap*, int)
        friend SOAP_FMAC1 ns1__trsVoiceDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsVoiceDef(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:229 */
#ifndef SOAP_TYPE_ns1__freq
#define SOAP_TYPE_ns1__freq (41)
/* complex XML schema type 'ns1:freq': */
class SOAP_CMAC ns1__freq {
      public:
        /// Required element 'fid' of XML schema type 'xsd:int'
        int fid;
        /// Required element 'out' of XML schema type 'xsd:decimal'
        std::string out;
        /// Required element 'in' of XML schema type 'xsd:decimal'
        std::string in;
        /// Required element 'callsign' of XML schema type 'xsd:string'
        std::string callsign;
        /// Required element 'descr' of XML schema type 'xsd:string'
        std::string descr;
        /// Required element 'alpha' of XML schema type 'xsd:string'
        std::string alpha;
        /// Required element 'tone' of XML schema type 'xsd:string'
        std::string tone;
        /// Required element 'colorCode' of XML schema type 'xsd:string'
        std::string colorCode;
        /// Required element 'tg' of XML schema type 'xsd:string'
        std::string tg;
        /// Required element 'slot' of XML schema type 'xsd:string'
        std::string slot;
        /// Required element 'mode' of XML schema type 'xsd:string'
        std::string mode;
        /// Required element 'enc' of XML schema type 'xsd:int'
        int enc;
        /// Required element 'class' of XML schema type 'xsd:string'
        std::string class_;
        /// Required element 'tags' of XML schema type 'ArrayOftag'
        tags *tags_;
        /// Required element 'scid' of XML schema type 'xsd:int'
        int scid;
        /// Required element 'sort' of XML schema type 'xsd:int'
        int sort;
        /// Required element 'lastUpdated' of XML schema type 'xsd:dateTime'
        time_t lastUpdated;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__freq
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__freq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__freq, default initialized and not managed by a soap context
        virtual ns1__freq *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__freq); }
      public:
        /// Constructor with default initializations
        ns1__freq() : fid(), out(), in(), callsign(), descr(), alpha(), tone(), colorCode(), tg(), slot(), mode(), enc(), class_(), tags_(), scid(), sort(), lastUpdated(), soap() { }
        virtual ~ns1__freq() { }
        /// Friend allocator used by soap_new_ns1__freq(struct soap*, int)
        friend SOAP_FMAC1 ns1__freq * SOAP_FMAC2 rrapi__instantiate_ns1__freq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:231 */
#ifndef SOAP_TYPE_ns1__searchFreqResult
#define SOAP_TYPE_ns1__searchFreqResult (42)
/* complex XML schema type 'ns1:searchFreqResult': */
class SOAP_CMAC ns1__searchFreqResult {
      public:
        /// Required element 'out' of XML schema type 'xsd:decimal'
        std::string out;
        /// Required element 'in' of XML schema type 'xsd:decimal'
        std::string in;
        /// Required element 'callsign' of XML schema type 'xsd:string'
        std::string callsign;
        /// Required element 'descr' of XML schema type 'xsd:string'
        std::string descr;
        /// Required element 'alpha' of XML schema type 'xsd:string'
        std::string alpha;
        /// Required element 'tone' of XML schema type 'xsd:string'
        std::string tone;
        /// Required element 'colorCode' of XML schema type 'xsd:string'
        std::string colorCode;
        /// Required element 'tg' of XML schema type 'xsd:string'
        std::string tg;
        /// Required element 'slot' of XML schema type 'xsd:string'
        std::string slot;
        /// Required element 'mode' of XML schema type 'xsd:string'
        std::string mode;
        /// Required element 'class' of XML schema type 'xsd:string'
        std::string class_;
        /// Required element 'tags' of XML schema type 'ArrayOftag'
        tags *tags_;
        /// Required element 'scid' of XML schema type 'xsd:int'
        int scid;
        /// Required element 'sid' of XML schema type 'xsd:int'
        int sid;
        /// Required element 'aid' of XML schema type 'xsd:int'
        int aid;
        /// Required element 'ctid' of XML schema type 'xsd:int'
        int ctid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__searchFreqResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__searchFreqResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__searchFreqResult, default initialized and not managed by a soap context
        virtual ns1__searchFreqResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__searchFreqResult); }
      public:
        /// Constructor with default initializations
        ns1__searchFreqResult() : out(), in(), callsign(), descr(), alpha(), tone(), colorCode(), tg(), slot(), mode(), class_(), tags_(), scid(), sid(), aid(), ctid(), soap() { }
        virtual ~ns1__searchFreqResult() { }
        /// Friend allocator used by soap_new_ns1__searchFreqResult(struct soap*, int)
        friend SOAP_FMAC1 ns1__searchFreqResult * SOAP_FMAC2 rrapi__instantiate_ns1__searchFreqResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:239 */
#ifndef SOAP_TYPE_ns1__cat
#define SOAP_TYPE_ns1__cat (46)
/* complex XML schema type 'ns1:cat': */
class SOAP_CMAC ns1__cat {
      public:
        /// Required element 'cid' of XML schema type 'xsd:int'
        int cid;
        /// Required element 'cName' of XML schema type 'xsd:string'
        std::string cName;
        /// Required element 'subcats' of XML schema type 'ArrayOfsubcat'
        SubCats *subcats;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__cat
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__cat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__cat, default initialized and not managed by a soap context
        virtual ns1__cat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__cat); }
      public:
        /// Constructor with default initializations
        ns1__cat() : cid(), cName(), subcats(), soap() { }
        virtual ~ns1__cat() { }
        /// Friend allocator used by soap_new_ns1__cat(struct soap*, int)
        friend SOAP_FMAC1 ns1__cat * SOAP_FMAC2 rrapi__instantiate_ns1__cat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:243 */
#ifndef SOAP_TYPE_ns1__subcat
#define SOAP_TYPE_ns1__subcat (48)
/* complex XML schema type 'ns1:subcat': */
class SOAP_CMAC ns1__subcat {
      public:
        /// Required element 'scid' of XML schema type 'xsd:int'
        int scid;
        /// Required element 'scName' of XML schema type 'xsd:string'
        std::string scName;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'range' of XML schema type 'xsd:decimal'
        std::string range;
        /// Required element 'sids' of XML schema type 'ArrayOfsid'
        sids *sids_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__subcat
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__subcat; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__subcat, default initialized and not managed by a soap context
        virtual ns1__subcat *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__subcat); }
      public:
        /// Constructor with default initializations
        ns1__subcat() : scid(), scName(), lat(), lon(), range(), sids_(), soap() { }
        virtual ~ns1__subcat() { }
        /// Friend allocator used by soap_new_ns1__subcat(struct soap*, int)
        friend SOAP_FMAC1 ns1__subcat * SOAP_FMAC2 rrapi__instantiate_ns1__subcat(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:245 */
#ifndef SOAP_TYPE_ns1__AgencyInfo
#define SOAP_TYPE_ns1__AgencyInfo (49)
/* complex XML schema type 'ns1:AgencyInfo': */
class SOAP_CMAC ns1__AgencyInfo {
      public:
        /// Required element 'aid' of XML schema type 'xsd:int'
        int aid;
        /// Required element 'agencyName' of XML schema type 'xsd:string'
        std::string agencyName;
        /// Required element 'agencyType' of XML schema type 'xsd:string'
        std::string agencyType;
        /// Required element 'ctid' of XML schema type 'xsd:int'
        int ctid;
        /// Required element 'stid' of XML schema type 'xsd:int'
        int stid;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'range' of XML schema type 'xsd:decimal'
        std::string range;
        /// Required element 'lastUpdated' of XML schema type 'xsd:dateTime'
        time_t lastUpdated;
        /// Required element 'cats' of XML schema type 'ArrayOfcat'
        Cats *cats;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AgencyInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__AgencyInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AgencyInfo, default initialized and not managed by a soap context
        virtual ns1__AgencyInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__AgencyInfo); }
      public:
        /// Constructor with default initializations
        ns1__AgencyInfo() : aid(), agencyName(), agencyType(), ctid(), stid(), lat(), lon(), range(), lastUpdated(), cats(), soap() { }
        virtual ~ns1__AgencyInfo() { }
        /// Friend allocator used by soap_new_ns1__AgencyInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__AgencyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__AgencyInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:247 */
#ifndef SOAP_TYPE_ns1__CountryInfo
#define SOAP_TYPE_ns1__CountryInfo (50)
/* complex XML schema type 'ns1:CountryInfo': */
class SOAP_CMAC ns1__CountryInfo {
      public:
        /// Required element 'coid' of XML schema type 'xsd:int'
        int coid;
        /// Required element 'countryName' of XML schema type 'xsd:string'
        std::string countryName;
        /// Required element 'countryCode' of XML schema type 'xsd:string'
        std::string countryCode;
        /// Required element 'agencyList' of XML schema type 'ArrayOfAgency'
        Agencies *agencyList;
        /// Required element 'stateList' of XML schema type 'ArrayOfState'
        States *stateList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CountryInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CountryInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CountryInfo, default initialized and not managed by a soap context
        virtual ns1__CountryInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CountryInfo); }
      public:
        /// Constructor with default initializations
        ns1__CountryInfo() : coid(), countryName(), countryCode(), agencyList(), stateList(), soap() { }
        virtual ~ns1__CountryInfo() { }
        /// Friend allocator used by soap_new_ns1__CountryInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__CountryInfo * SOAP_FMAC2 rrapi__instantiate_ns1__CountryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:249 */
#ifndef SOAP_TYPE_ns1__CountyInfo
#define SOAP_TYPE_ns1__CountyInfo (51)
/* complex XML schema type 'ns1:CountyInfo': */
class SOAP_CMAC ns1__CountyInfo {
      public:
        /// Required element 'ctid' of XML schema type 'xsd:int'
        int ctid;
        /// Required element 'countyName' of XML schema type 'xsd:string'
        std::string countyName;
        /// Required element 'countyHeader' of XML schema type 'xsd:string'
        std::string countyHeader;
        /// Required element 'stid' of XML schema type 'xsd:int'
        int stid;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'range' of XML schema type 'xsd:decimal'
        std::string range;
        /// Required element 'fips' of XML schema type 'xsd:string'
        std::string fips;
        /// Required element 'lastUpdated' of XML schema type 'xsd:dateTime'
        time_t lastUpdated;
        /// Required element 'cats' of XML schema type 'ArrayOfcat'
        Cats *cats;
        /// Required element 'trsList' of XML schema type 'ArrayOfTrsListDef'
        TrsList *trsList;
        /// Required element 'agencyList' of XML schema type 'ArrayOfAgency'
        Agencies *agencyList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CountyInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__CountyInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CountyInfo, default initialized and not managed by a soap context
        virtual ns1__CountyInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__CountyInfo); }
      public:
        /// Constructor with default initializations
        ns1__CountyInfo() : ctid(), countyName(), countyHeader(), stid(), lat(), lon(), range(), fips(), lastUpdated(), cats(), trsList(), agencyList(), soap() { }
        virtual ~ns1__CountyInfo() { }
        /// Friend allocator used by soap_new_ns1__CountyInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__CountyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__CountyInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:251 */
#ifndef SOAP_TYPE_ns1__StateInfo
#define SOAP_TYPE_ns1__StateInfo (52)
/* complex XML schema type 'ns1:StateInfo': */
class SOAP_CMAC ns1__StateInfo {
      public:
        /// Required element 'stid' of XML schema type 'xsd:int'
        int stid;
        /// Required element 'stateName' of XML schema type 'xsd:string'
        std::string stateName;
        /// Required element 'stateEntityType' of XML schema type 'xsd:string'
        std::string stateEntityType;
        /// Required element 'trsList' of XML schema type 'ArrayOfTrsListDef'
        TrsList *trsList;
        /// Required element 'agencyList' of XML schema type 'ArrayOfAgency'
        Agencies *agencyList;
        /// Required element 'countyList' of XML schema type 'ArrayOfCounty'
        Counties *countyList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StateInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__StateInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StateInfo, default initialized and not managed by a soap context
        virtual ns1__StateInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__StateInfo); }
      public:
        /// Constructor with default initializations
        ns1__StateInfo() : stid(), stateName(), stateEntityType(), trsList(), agencyList(), countyList(), soap() { }
        virtual ~ns1__StateInfo() { }
        /// Friend allocator used by soap_new_ns1__StateInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__StateInfo * SOAP_FMAC2 rrapi__instantiate_ns1__StateInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:253 */
#ifndef SOAP_TYPE_ns1__County
#define SOAP_TYPE_ns1__County (53)
/* complex XML schema type 'ns1:County': */
class SOAP_CMAC ns1__County {
      public:
        /// Required element 'ctid' of XML schema type 'xsd:int'
        int ctid;
        /// Required element 'countyName' of XML schema type 'xsd:string'
        std::string countyName;
        /// Required element 'countyHeader' of XML schema type 'xsd:string'
        std::string countyHeader;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__County
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__County; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__County, default initialized and not managed by a soap context
        virtual ns1__County *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__County); }
      public:
        /// Constructor with default initializations
        ns1__County() : ctid(), countyName(), countyHeader(), soap() { }
        virtual ~ns1__County() { }
        /// Friend allocator used by soap_new_ns1__County(struct soap*, int)
        friend SOAP_FMAC1 ns1__County * SOAP_FMAC2 rrapi__instantiate_ns1__County(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:259 */
#ifndef SOAP_TYPE_ns1__ctid
#define SOAP_TYPE_ns1__ctid (56)
/* complex XML schema type 'ns1:ctid': */
class SOAP_CMAC ns1__ctid {
      public:
        /// Required element 'ctid' of XML schema type 'xsd:int'
        int ctid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ctid
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ctid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ctid, default initialized and not managed by a soap context
        virtual ns1__ctid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ctid); }
      public:
        /// Constructor with default initializations
        ns1__ctid() : ctid(), soap() { }
        virtual ~ns1__ctid() { }
        /// Friend allocator used by soap_new_ns1__ctid(struct soap*, int)
        friend SOAP_FMAC1 ns1__ctid * SOAP_FMAC2 rrapi__instantiate_ns1__ctid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:263 */
#ifndef SOAP_TYPE_ns1__State
#define SOAP_TYPE_ns1__State (58)
/* complex XML schema type 'ns1:State': */
class SOAP_CMAC ns1__State {
      public:
        /// Required element 'stid' of XML schema type 'xsd:int'
        int stid;
        /// Required element 'stateName' of XML schema type 'xsd:string'
        std::string stateName;
        /// Required element 'stateCode' of XML schema type 'xsd:string'
        std::string stateCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__State
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__State; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__State, default initialized and not managed by a soap context
        virtual ns1__State *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__State); }
      public:
        /// Constructor with default initializations
        ns1__State() : stid(), stateName(), stateCode(), soap() { }
        virtual ~ns1__State() { }
        /// Friend allocator used by soap_new_ns1__State(struct soap*, int)
        friend SOAP_FMAC1 ns1__State * SOAP_FMAC2 rrapi__instantiate_ns1__State(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:267 */
#ifndef SOAP_TYPE_ns1__Metro
#define SOAP_TYPE_ns1__Metro (60)
/* complex XML schema type 'ns1:Metro': */
class SOAP_CMAC ns1__Metro {
      public:
        /// Required element 'mid' of XML schema type 'xsd:int'
        int mid;
        /// Required element 'metroName' of XML schema type 'xsd:string'
        std::string metroName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Metro
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Metro; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Metro, default initialized and not managed by a soap context
        virtual ns1__Metro *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Metro); }
      public:
        /// Constructor with default initializations
        ns1__Metro() : mid(), metroName(), soap() { }
        virtual ~ns1__Metro() { }
        /// Friend allocator used by soap_new_ns1__Metro(struct soap*, int)
        friend SOAP_FMAC1 ns1__Metro * SOAP_FMAC2 rrapi__instantiate_ns1__Metro(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:271 */
#ifndef SOAP_TYPE_ns1__Country
#define SOAP_TYPE_ns1__Country (62)
/* complex XML schema type 'ns1:Country': */
class SOAP_CMAC ns1__Country {
      public:
        /// Required element 'coid' of XML schema type 'xsd:int'
        int coid;
        /// Required element 'countryName' of XML schema type 'xsd:string'
        std::string countryName;
        /// Required element 'countryCode' of XML schema type 'xsd:string'
        std::string countryCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Country
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Country; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Country, default initialized and not managed by a soap context
        virtual ns1__Country *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Country); }
      public:
        /// Constructor with default initializations
        ns1__Country() : coid(), countryName(), countryCode(), soap() { }
        virtual ~ns1__Country() { }
        /// Friend allocator used by soap_new_ns1__Country(struct soap*, int)
        friend SOAP_FMAC1 ns1__Country * SOAP_FMAC2 rrapi__instantiate_ns1__Country(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:275 */
#ifndef SOAP_TYPE_ns1__Agency
#define SOAP_TYPE_ns1__Agency (64)
/* complex XML schema type 'ns1:Agency': */
class SOAP_CMAC ns1__Agency {
      public:
        /// Required element 'aid' of XML schema type 'xsd:int'
        int aid;
        /// Required element 'aName' of XML schema type 'xsd:string'
        std::string aName;
        /// Required element 'aType' of XML schema type 'xsd:int'
        int aType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Agency
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Agency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Agency, default initialized and not managed by a soap context
        virtual ns1__Agency *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Agency); }
      public:
        /// Constructor with default initializations
        ns1__Agency() : aid(), aName(), aType(), soap() { }
        virtual ~ns1__Agency() { }
        /// Friend allocator used by soap_new_ns1__Agency(struct soap*, int)
        friend SOAP_FMAC1 ns1__Agency * SOAP_FMAC2 rrapi__instantiate_ns1__Agency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:279 */
#ifndef SOAP_TYPE_ns1__stid
#define SOAP_TYPE_ns1__stid (66)
/* complex XML schema type 'ns1:stid': */
class SOAP_CMAC ns1__stid {
      public:
        /// Required element 'stid' of XML schema type 'xsd:int'
        int stid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stid
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__stid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stid, default initialized and not managed by a soap context
        virtual ns1__stid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__stid); }
      public:
        /// Constructor with default initializations
        ns1__stid() : stid(), soap() { }
        virtual ~ns1__stid() { }
        /// Friend allocator used by soap_new_ns1__stid(struct soap*, int)
        friend SOAP_FMAC1 ns1__stid * SOAP_FMAC2 rrapi__instantiate_ns1__stid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:283 */
#ifndef SOAP_TYPE_ns1__sid
#define SOAP_TYPE_ns1__sid (68)
/* complex XML schema type 'ns1:sid': */
class SOAP_CMAC ns1__sid {
      public:
        /// Required element 'sid' of XML schema type 'xsd:int'
        int sid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__sid
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__sid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__sid, default initialized and not managed by a soap context
        virtual ns1__sid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__sid); }
      public:
        /// Constructor with default initializations
        ns1__sid() : sid(), soap() { }
        virtual ~ns1__sid() { }
        /// Friend allocator used by soap_new_ns1__sid(struct soap*, int)
        friend SOAP_FMAC1 ns1__sid * SOAP_FMAC2 rrapi__instantiate_ns1__sid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:287 */
#ifndef SOAP_TYPE_ns1__tag
#define SOAP_TYPE_ns1__tag (70)
/* complex XML schema type 'ns1:tag': */
class SOAP_CMAC ns1__tag {
      public:
        /// Required element 'tagId' of XML schema type 'xsd:int'
        int tagId;
        /// Required element 'tagDescr' of XML schema type 'xsd:string'
        std::string tagDescr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__tag
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__tag; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__tag, default initialized and not managed by a soap context
        virtual ns1__tag *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__tag); }
      public:
        /// Constructor with default initializations
        ns1__tag() : tagId(), tagDescr(), soap() { }
        virtual ~ns1__tag() { }
        /// Friend allocator used by soap_new_ns1__tag(struct soap*, int)
        friend SOAP_FMAC1 ns1__tag * SOAP_FMAC2 rrapi__instantiate_ns1__tag(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:291 */
#ifndef SOAP_TYPE_ns1__mode
#define SOAP_TYPE_ns1__mode (72)
/* complex XML schema type 'ns1:mode': */
class SOAP_CMAC ns1__mode {
      public:
        /// Required element 'mode' of XML schema type 'xsd:int'
        int mode;
        /// Required element 'modeName' of XML schema type 'xsd:string'
        std::string modeName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__mode
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__mode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__mode, default initialized and not managed by a soap context
        virtual ns1__mode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__mode); }
      public:
        /// Constructor with default initializations
        ns1__mode() : mode(), modeName(), soap() { }
        virtual ~ns1__mode() { }
        /// Friend allocator used by soap_new_ns1__mode(struct soap*, int)
        friend SOAP_FMAC1 ns1__mode * SOAP_FMAC2 rrapi__instantiate_ns1__mode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:293 */
#ifndef SOAP_TYPE_ns1__ZipInfo
#define SOAP_TYPE_ns1__ZipInfo (73)
/* complex XML schema type 'ns1:ZipInfo': */
class SOAP_CMAC ns1__ZipInfo {
      public:
        /// Required element 'zipCode' of XML schema type 'xsd:int'
        int zipCode;
        /// Required element 'lat' of XML schema type 'xsd:string'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:string'
        std::string lon;
        /// Required element 'city' of XML schema type 'xsd:string'
        std::string city;
        /// Required element 'stid' of XML schema type 'xsd:int'
        int stid;
        /// Required element 'ctid' of XML schema type 'xsd:int'
        int ctid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ZipInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ZipInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ZipInfo, default initialized and not managed by a soap context
        virtual ns1__ZipInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ZipInfo); }
      public:
        /// Constructor with default initializations
        ns1__ZipInfo() : zipCode(), lat(), lon(), city(), stid(), ctid(), soap() { }
        virtual ~ns1__ZipInfo() { }
        /// Friend allocator used by soap_new_ns1__ZipInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__ZipInfo * SOAP_FMAC2 rrapi__instantiate_ns1__ZipInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:295 */
#ifndef SOAP_TYPE_ns1__UserInfo
#define SOAP_TYPE_ns1__UserInfo (74)
/* complex XML schema type 'ns1:UserInfo': */
class SOAP_CMAC ns1__UserInfo {
      public:
        /// Required element 'username' of XML schema type 'xsd:string'
        std::string username;
        /// Required element 'subExpireDate' of XML schema type 'xsd:string'
        std::string subExpireDate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UserInfo
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__UserInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UserInfo, default initialized and not managed by a soap context
        virtual ns1__UserInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__UserInfo); }
      public:
        /// Constructor with default initializations
        ns1__UserInfo() : username(), subExpireDate(), soap() { }
        virtual ~ns1__UserInfo() { }
        /// Friend allocator used by soap_new_ns1__UserInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__UserInfo * SOAP_FMAC2 rrapi__instantiate_ns1__UserInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:297 */
#ifndef SOAP_TYPE_ns1__fccCallsignDetails
#define SOAP_TYPE_ns1__fccCallsignDetails (75)
/* complex XML schema type 'ns1:fccCallsignDetails': */
class SOAP_CMAC ns1__fccCallsignDetails {
      public:
        /// Required element 'licensee' of XML schema type 'xsd:string'
        std::string licensee;
        /// Required element 'callsign' of XML schema type 'xsd:string'
        std::string callsign;
        /// Required element 'status' of XML schema type 'xsd:string'
        std::string status;
        /// Required element 'grantDate' of XML schema type 'xsd:string'
        std::string grantDate;
        /// Required element 'radioService' of XML schema type 'xsd:string'
        std::string radioService;
        /// Required element 'notes' of XML schema type 'xsd:string'
        std::string notes;
        /// Required element 'locations' of XML schema type 'ArrayOffccLocation'
        fccLocations *locations;
        /// Required element 'frequencies' of XML schema type 'ArrayOffccFrequency'
        fccFrequencies *frequencies;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__fccCallsignDetails
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__fccCallsignDetails; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__fccCallsignDetails, default initialized and not managed by a soap context
        virtual ns1__fccCallsignDetails *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__fccCallsignDetails); }
      public:
        /// Constructor with default initializations
        ns1__fccCallsignDetails() : licensee(), callsign(), status(), grantDate(), radioService(), notes(), locations(), frequencies(), soap() { }
        virtual ~ns1__fccCallsignDetails() { }
        /// Friend allocator used by soap_new_ns1__fccCallsignDetails(struct soap*, int)
        friend SOAP_FMAC1 ns1__fccCallsignDetails * SOAP_FMAC2 rrapi__instantiate_ns1__fccCallsignDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:299 */
#ifndef SOAP_TYPE_ns1__fccFrequency
#define SOAP_TYPE_ns1__fccFrequency (76)
/* complex XML schema type 'ns1:fccFrequency': */
class SOAP_CMAC ns1__fccFrequency {
      public:
        /// Required element 'locationNumber' of XML schema type 'xsd:int'
        int locationNumber;
        /// Required element 'frequency' of XML schema type 'xsd:decimal'
        std::string frequency;
        /// Required element 'emission' of XML schema type 'xsd:string'
        std::string emission;
        /// Required element 'class' of XML schema type 'xsd:string'
        std::string class_;
        /// Required element 'power' of XML schema type 'xsd:decimal'
        std::string power;
        /// Required element 'mobiles' of XML schema type 'xsd:int'
        int mobiles;
        /// Required element 'pagers' of XML schema type 'xsd:int'
        int pagers;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__fccFrequency
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__fccFrequency; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__fccFrequency, default initialized and not managed by a soap context
        virtual ns1__fccFrequency *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__fccFrequency); }
      public:
        /// Constructor with default initializations
        ns1__fccFrequency() : locationNumber(), frequency(), emission(), class_(), power(), mobiles(), pagers(), soap() { }
        virtual ~ns1__fccFrequency() { }
        /// Friend allocator used by soap_new_ns1__fccFrequency(struct soap*, int)
        friend SOAP_FMAC1 ns1__fccFrequency * SOAP_FMAC2 rrapi__instantiate_ns1__fccFrequency(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:303 */
#ifndef SOAP_TYPE_ns1__fccLocation
#define SOAP_TYPE_ns1__fccLocation (78)
/* complex XML schema type 'ns1:fccLocation': */
class SOAP_CMAC ns1__fccLocation {
      public:
        /// Required element 'locationNumber' of XML schema type 'xsd:int'
        int locationNumber;
        /// Required element 'towerId' of XML schema type 'xsd:string'
        std::string towerId;
        /// Required element 'type' of XML schema type 'xsd:string'
        std::string type;
        /// Required element 'antennaHeight' of XML schema type 'xsd:decimal'
        std::string antennaHeight;
        /// Required element 'structureHeight' of XML schema type 'xsd:decimal'
        std::string structureHeight;
        /// Required element 'elevation' of XML schema type 'xsd:decimal'
        std::string elevation;
        /// Required element 'address' of XML schema type 'xsd:string'
        std::string address;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'city' of XML schema type 'xsd:string'
        std::string city;
        /// Required element 'county' of XML schema type 'xsd:string'
        std::string county;
        /// Required element 'state' of XML schema type 'xsd:string'
        std::string state;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__fccLocation
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__fccLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__fccLocation, default initialized and not managed by a soap context
        virtual ns1__fccLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__fccLocation); }
      public:
        /// Constructor with default initializations
        ns1__fccLocation() : locationNumber(), towerId(), type(), antennaHeight(), structureHeight(), elevation(), address(), lat(), lon(), city(), county(), state(), soap() { }
        virtual ~ns1__fccLocation() { }
        /// Friend allocator used by soap_new_ns1__fccLocation(struct soap*, int)
        friend SOAP_FMAC1 ns1__fccLocation * SOAP_FMAC2 rrapi__instantiate_ns1__fccLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:307 */
#ifndef SOAP_TYPE_ns1__proxCallsignResult
#define SOAP_TYPE_ns1__proxCallsignResult (80)
/* complex XML schema type 'ns1:proxCallsignResult': */
class SOAP_CMAC ns1__proxCallsignResult {
      public:
        /// Required element 'callsign' of XML schema type 'xsd:string'
        std::string callsign;
        /// Required element 'licensee' of XML schema type 'xsd:string'
        std::string licensee;
        /// Required element 'lat' of XML schema type 'xsd:decimal'
        std::string lat;
        /// Required element 'lon' of XML schema type 'xsd:decimal'
        std::string lon;
        /// Required element 'distance' of XML schema type 'xsd:decimal'
        std::string distance;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__proxCallsignResult
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__proxCallsignResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__proxCallsignResult, default initialized and not managed by a soap context
        virtual ns1__proxCallsignResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__proxCallsignResult); }
      public:
        /// Constructor with default initializations
        ns1__proxCallsignResult() : callsign(), licensee(), lat(), lon(), distance(), soap() { }
        virtual ~ns1__proxCallsignResult() { }
        /// Friend allocator used by soap_new_ns1__proxCallsignResult(struct soap*, int)
        friend SOAP_FMAC1 ns1__proxCallsignResult * SOAP_FMAC2 rrapi__instantiate_ns1__proxCallsignResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:311 */
#ifndef SOAP_TYPE_ns1__fccRadioServiceCode
#define SOAP_TYPE_ns1__fccRadioServiceCode (82)
/* complex XML schema type 'ns1:fccRadioServiceCode': */
class SOAP_CMAC ns1__fccRadioServiceCode {
      public:
        /// Required element 'code' of XML schema type 'xsd:string'
        std::string code;
        /// Required element 'description' of XML schema type 'xsd:string'
        std::string description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__fccRadioServiceCode
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__fccRadioServiceCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__fccRadioServiceCode, default initialized and not managed by a soap context
        virtual ns1__fccRadioServiceCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__fccRadioServiceCode); }
      public:
        /// Constructor with default initializations
        ns1__fccRadioServiceCode() : code(), description(), soap() { }
        virtual ~ns1__fccRadioServiceCode() { }
        /// Friend allocator used by soap_new_ns1__fccRadioServiceCode(struct soap*, int)
        friend SOAP_FMAC1 ns1__fccRadioServiceCode * SOAP_FMAC2 rrapi__instantiate_ns1__fccRadioServiceCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:175 */
#ifndef SOAP_TYPE_userFeedBroadcasts
#define SOAP_TYPE_userFeedBroadcasts (14)
/* SOAP encoded array of ns1:userFeedBroadcast schema type: */
class SOAP_CMAC userFeedBroadcasts {
      public:
        ns1__userFeedBroadcast **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_userFeedBroadcasts
        virtual long soap_type(void) const { return SOAP_TYPE_userFeedBroadcasts; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type userFeedBroadcasts, default initialized and not managed by a soap context
        virtual userFeedBroadcasts *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(userFeedBroadcasts); }
      public:
        /// Constructor with default initializations
        userFeedBroadcasts() : __ptr(), __size(), soap() { }
        virtual ~userFeedBroadcasts() { }
        /// Friend allocator used by soap_new_userFeedBroadcasts(struct soap*, int)
        friend SOAP_FMAC1 userFeedBroadcasts * SOAP_FMAC2 rrapi__instantiate_userFeedBroadcasts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:177 */
#ifndef SOAP_TYPE_stidList
#define SOAP_TYPE_stidList (15)
/* SOAP encoded array of ns1:stid schema type: */
class SOAP_CMAC stidList {
      public:
        ns1__stid **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_stidList
        virtual long soap_type(void) const { return SOAP_TYPE_stidList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type stidList, default initialized and not managed by a soap context
        virtual stidList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(stidList); }
      public:
        /// Constructor with default initializations
        stidList() : __ptr(), __size(), soap() { }
        virtual ~stidList() { }
        /// Friend allocator used by soap_new_stidList(struct soap*, int)
        friend SOAP_FMAC1 stidList * SOAP_FMAC2 rrapi__instantiate_stidList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:179 */
#ifndef SOAP_TYPE_ctidList
#define SOAP_TYPE_ctidList (16)
/* SOAP encoded array of ns1:ctid schema type: */
class SOAP_CMAC ctidList {
      public:
        ns1__ctid **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ctidList
        virtual long soap_type(void) const { return SOAP_TYPE_ctidList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ctidList, default initialized and not managed by a soap context
        virtual ctidList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ctidList); }
      public:
        /// Constructor with default initializations
        ctidList() : __ptr(), __size(), soap() { }
        virtual ~ctidList() { }
        /// Friend allocator used by soap_new_ctidList(struct soap*, int)
        friend SOAP_FMAC1 ctidList * SOAP_FMAC2 rrapi__instantiate_ctidList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:183 */
#ifndef SOAP_TYPE_Talkgroups
#define SOAP_TYPE_Talkgroups (18)
/* SOAP encoded array of ns1:Talkgroup schema type: */
class SOAP_CMAC Talkgroups {
      public:
        ns1__Talkgroup **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Talkgroups
        virtual long soap_type(void) const { return SOAP_TYPE_Talkgroups; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Talkgroups, default initialized and not managed by a soap context
        virtual Talkgroups *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Talkgroups); }
      public:
        /// Constructor with default initializations
        Talkgroups() : __ptr(), __size(), soap() { }
        virtual ~Talkgroups() { }
        /// Friend allocator used by soap_new_Talkgroups(struct soap*, int)
        friend SOAP_FMAC1 Talkgroups * SOAP_FMAC2 rrapi__instantiate_Talkgroups(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:187 */
#ifndef SOAP_TYPE_TalkgroupCats
#define SOAP_TYPE_TalkgroupCats (20)
/* SOAP encoded array of ns1:TalkgroupCat schema type: */
class SOAP_CMAC TalkgroupCats {
      public:
        ns1__TalkgroupCat **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TalkgroupCats
        virtual long soap_type(void) const { return SOAP_TYPE_TalkgroupCats; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TalkgroupCats, default initialized and not managed by a soap context
        virtual TalkgroupCats *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TalkgroupCats); }
      public:
        /// Constructor with default initializations
        TalkgroupCats() : __ptr(), __size(), soap() { }
        virtual ~TalkgroupCats() { }
        /// Friend allocator used by soap_new_TalkgroupCats(struct soap*, int)
        friend SOAP_FMAC1 TalkgroupCats * SOAP_FMAC2 rrapi__instantiate_TalkgroupCats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:191 */
#ifndef SOAP_TYPE_TrsSites
#define SOAP_TYPE_TrsSites (22)
/* SOAP encoded array of ns1:TrsSite schema type: */
class SOAP_CMAC TrsSites {
      public:
        ns1__TrsSite **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsSites
        virtual long soap_type(void) const { return SOAP_TYPE_TrsSites; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsSites, default initialized and not managed by a soap context
        virtual TrsSites *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsSites); }
      public:
        /// Constructor with default initializations
        TrsSites() : __ptr(), __size(), soap() { }
        virtual ~TrsSites() { }
        /// Friend allocator used by soap_new_TrsSites(struct soap*, int)
        friend SOAP_FMAC1 TrsSites * SOAP_FMAC2 rrapi__instantiate_TrsSites(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:195 */
#ifndef SOAP_TYPE_TrsSiteFreqs
#define SOAP_TYPE_TrsSiteFreqs (24)
/* SOAP encoded array of ns1:TrsSiteFreq schema type: */
class SOAP_CMAC TrsSiteFreqs {
      public:
        ns1__TrsSiteFreq **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsSiteFreqs
        virtual long soap_type(void) const { return SOAP_TYPE_TrsSiteFreqs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsSiteFreqs, default initialized and not managed by a soap context
        virtual TrsSiteFreqs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsSiteFreqs); }
      public:
        /// Constructor with default initializations
        TrsSiteFreqs() : __ptr(), __size(), soap() { }
        virtual ~TrsSiteFreqs() { }
        /// Friend allocator used by soap_new_TrsSiteFreqs(struct soap*, int)
        friend SOAP_FMAC1 TrsSiteFreqs * SOAP_FMAC2 rrapi__instantiate_TrsSiteFreqs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:199 */
#ifndef SOAP_TYPE_TrsSiteLicenses
#define SOAP_TYPE_TrsSiteLicenses (26)
/* SOAP encoded array of ns1:TrsSiteLicense schema type: */
class SOAP_CMAC TrsSiteLicenses {
      public:
        ns1__TrsSiteLicense **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsSiteLicenses
        virtual long soap_type(void) const { return SOAP_TYPE_TrsSiteLicenses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsSiteLicenses, default initialized and not managed by a soap context
        virtual TrsSiteLicenses *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsSiteLicenses); }
      public:
        /// Constructor with default initializations
        TrsSiteLicenses() : __ptr(), __size(), soap() { }
        virtual ~TrsSiteLicenses() { }
        /// Friend allocator used by soap_new_TrsSiteLicenses(struct soap*, int)
        friend SOAP_FMAC1 TrsSiteLicenses * SOAP_FMAC2 rrapi__instantiate_TrsSiteLicenses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:205 */
#ifndef SOAP_TYPE_TrsList
#define SOAP_TYPE_TrsList (29)
/* SOAP encoded array of ns1:TrsListDef schema type: */
class SOAP_CMAC TrsList {
      public:
        ns1__TrsListDef **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsList
        virtual long soap_type(void) const { return SOAP_TYPE_TrsList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsList, default initialized and not managed by a soap context
        virtual TrsList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsList); }
      public:
        /// Constructor with default initializations
        TrsList() : __ptr(), __size(), soap() { }
        virtual ~TrsList() { }
        /// Friend allocator used by soap_new_TrsList(struct soap*, int)
        friend SOAP_FMAC1 TrsList * SOAP_FMAC2 rrapi__instantiate_TrsList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:209 */
#ifndef SOAP_TYPE_TrsSysid
#define SOAP_TYPE_TrsSysid (31)
/* SOAP encoded array of ns1:trsSysidDef schema type: */
class SOAP_CMAC TrsSysid {
      public:
        ns1__trsSysidDef **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsSysid
        virtual long soap_type(void) const { return SOAP_TYPE_TrsSysid; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsSysid, default initialized and not managed by a soap context
        virtual TrsSysid *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsSysid); }
      public:
        /// Constructor with default initializations
        TrsSysid() : __ptr(), __size(), soap() { }
        virtual ~TrsSysid() { }
        /// Friend allocator used by soap_new_TrsSysid(struct soap*, int)
        friend SOAP_FMAC1 TrsSysid * SOAP_FMAC2 rrapi__instantiate_TrsSysid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:213 */
#ifndef SOAP_TYPE_TrsBandplan
#define SOAP_TYPE_TrsBandplan (33)
/* SOAP encoded array of ns1:trsBandplanDef schema type: */
class SOAP_CMAC TrsBandplan {
      public:
        ns1__trsBandplanDef **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsBandplan
        virtual long soap_type(void) const { return SOAP_TYPE_TrsBandplan; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsBandplan, default initialized and not managed by a soap context
        virtual TrsBandplan *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsBandplan); }
      public:
        /// Constructor with default initializations
        TrsBandplan() : __ptr(), __size(), soap() { }
        virtual ~TrsBandplan() { }
        /// Friend allocator used by soap_new_TrsBandplan(struct soap*, int)
        friend SOAP_FMAC1 TrsBandplan * SOAP_FMAC2 rrapi__instantiate_TrsBandplan(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:219 */
#ifndef SOAP_TYPE_TrsType
#define SOAP_TYPE_TrsType (36)
/* SOAP encoded array of ns1:trsTypeDef schema type: */
class SOAP_CMAC TrsType {
      public:
        ns1__trsTypeDef **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsType
        virtual long soap_type(void) const { return SOAP_TYPE_TrsType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsType, default initialized and not managed by a soap context
        virtual TrsType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsType); }
      public:
        /// Constructor with default initializations
        TrsType() : __ptr(), __size(), soap() { }
        virtual ~TrsType() { }
        /// Friend allocator used by soap_new_TrsType(struct soap*, int)
        friend SOAP_FMAC1 TrsType * SOAP_FMAC2 rrapi__instantiate_TrsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:223 */
#ifndef SOAP_TYPE_TrsFlavor
#define SOAP_TYPE_TrsFlavor (38)
/* SOAP encoded array of ns1:trsFlavorDef schema type: */
class SOAP_CMAC TrsFlavor {
      public:
        ns1__trsFlavorDef **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsFlavor
        virtual long soap_type(void) const { return SOAP_TYPE_TrsFlavor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsFlavor, default initialized and not managed by a soap context
        virtual TrsFlavor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsFlavor); }
      public:
        /// Constructor with default initializations
        TrsFlavor() : __ptr(), __size(), soap() { }
        virtual ~TrsFlavor() { }
        /// Friend allocator used by soap_new_TrsFlavor(struct soap*, int)
        friend SOAP_FMAC1 TrsFlavor * SOAP_FMAC2 rrapi__instantiate_TrsFlavor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:227 */
#ifndef SOAP_TYPE_TrsVoice
#define SOAP_TYPE_TrsVoice (40)
/* SOAP encoded array of ns1:trsVoiceDef schema type: */
class SOAP_CMAC TrsVoice {
      public:
        ns1__trsVoiceDef **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_TrsVoice
        virtual long soap_type(void) const { return SOAP_TYPE_TrsVoice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type TrsVoice, default initialized and not managed by a soap context
        virtual TrsVoice *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(TrsVoice); }
      public:
        /// Constructor with default initializations
        TrsVoice() : __ptr(), __size(), soap() { }
        virtual ~TrsVoice() { }
        /// Friend allocator used by soap_new_TrsVoice(struct soap*, int)
        friend SOAP_FMAC1 TrsVoice * SOAP_FMAC2 rrapi__instantiate_TrsVoice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:233 */
#ifndef SOAP_TYPE_searchFreqResults
#define SOAP_TYPE_searchFreqResults (43)
/* SOAP encoded array of ns1:searchFreqResult schema type: */
class SOAP_CMAC searchFreqResults {
      public:
        ns1__searchFreqResult **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_searchFreqResults
        virtual long soap_type(void) const { return SOAP_TYPE_searchFreqResults; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type searchFreqResults, default initialized and not managed by a soap context
        virtual searchFreqResults *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(searchFreqResults); }
      public:
        /// Constructor with default initializations
        searchFreqResults() : __ptr(), __size(), soap() { }
        virtual ~searchFreqResults() { }
        /// Friend allocator used by soap_new_searchFreqResults(struct soap*, int)
        friend SOAP_FMAC1 searchFreqResults * SOAP_FMAC2 rrapi__instantiate_searchFreqResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:235 */
#ifndef SOAP_TYPE_Freqs
#define SOAP_TYPE_Freqs (44)
/* SOAP encoded array of ns1:freq schema type: */
class SOAP_CMAC Freqs {
      public:
        ns1__freq **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Freqs
        virtual long soap_type(void) const { return SOAP_TYPE_Freqs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Freqs, default initialized and not managed by a soap context
        virtual Freqs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Freqs); }
      public:
        /// Constructor with default initializations
        Freqs() : __ptr(), __size(), soap() { }
        virtual ~Freqs() { }
        /// Friend allocator used by soap_new_Freqs(struct soap*, int)
        friend SOAP_FMAC1 Freqs * SOAP_FMAC2 rrapi__instantiate_Freqs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:237 */
#ifndef SOAP_TYPE_Cats
#define SOAP_TYPE_Cats (45)
/* SOAP encoded array of ns1:cat schema type: */
class SOAP_CMAC Cats {
      public:
        ns1__cat **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Cats
        virtual long soap_type(void) const { return SOAP_TYPE_Cats; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Cats, default initialized and not managed by a soap context
        virtual Cats *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Cats); }
      public:
        /// Constructor with default initializations
        Cats() : __ptr(), __size(), soap() { }
        virtual ~Cats() { }
        /// Friend allocator used by soap_new_Cats(struct soap*, int)
        friend SOAP_FMAC1 Cats * SOAP_FMAC2 rrapi__instantiate_Cats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:241 */
#ifndef SOAP_TYPE_SubCats
#define SOAP_TYPE_SubCats (47)
/* SOAP encoded array of ns1:subcat schema type: */
class SOAP_CMAC SubCats {
      public:
        ns1__subcat **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_SubCats
        virtual long soap_type(void) const { return SOAP_TYPE_SubCats; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SubCats, default initialized and not managed by a soap context
        virtual SubCats *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SubCats); }
      public:
        /// Constructor with default initializations
        SubCats() : __ptr(), __size(), soap() { }
        virtual ~SubCats() { }
        /// Friend allocator used by soap_new_SubCats(struct soap*, int)
        friend SOAP_FMAC1 SubCats * SOAP_FMAC2 rrapi__instantiate_SubCats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:255 */
#ifndef SOAP_TYPE_Counties
#define SOAP_TYPE_Counties (54)
/* SOAP encoded array of ns1:County schema type: */
class SOAP_CMAC Counties {
      public:
        ns1__County **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Counties
        virtual long soap_type(void) const { return SOAP_TYPE_Counties; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Counties, default initialized and not managed by a soap context
        virtual Counties *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Counties); }
      public:
        /// Constructor with default initializations
        Counties() : __ptr(), __size(), soap() { }
        virtual ~Counties() { }
        /// Friend allocator used by soap_new_Counties(struct soap*, int)
        friend SOAP_FMAC1 Counties * SOAP_FMAC2 rrapi__instantiate_Counties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:257 */
#ifndef SOAP_TYPE_ctids
#define SOAP_TYPE_ctids (55)
/* SOAP encoded array of ns1:ctid schema type: */
class SOAP_CMAC ctids {
      public:
        ns1__ctid **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ctids
        virtual long soap_type(void) const { return SOAP_TYPE_ctids; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ctids, default initialized and not managed by a soap context
        virtual ctids *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ctids); }
      public:
        /// Constructor with default initializations
        ctids() : __ptr(), __size(), soap() { }
        virtual ~ctids() { }
        /// Friend allocator used by soap_new_ctids(struct soap*, int)
        friend SOAP_FMAC1 ctids * SOAP_FMAC2 rrapi__instantiate_ctids(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:261 */
#ifndef SOAP_TYPE_States
#define SOAP_TYPE_States (57)
/* SOAP encoded array of ns1:State schema type: */
class SOAP_CMAC States {
      public:
        ns1__State **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_States
        virtual long soap_type(void) const { return SOAP_TYPE_States; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type States, default initialized and not managed by a soap context
        virtual States *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(States); }
      public:
        /// Constructor with default initializations
        States() : __ptr(), __size(), soap() { }
        virtual ~States() { }
        /// Friend allocator used by soap_new_States(struct soap*, int)
        friend SOAP_FMAC1 States * SOAP_FMAC2 rrapi__instantiate_States(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:265 */
#ifndef SOAP_TYPE_Metros
#define SOAP_TYPE_Metros (59)
/* SOAP encoded array of ns1:Metro schema type: */
class SOAP_CMAC Metros {
      public:
        ns1__Metro **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Metros
        virtual long soap_type(void) const { return SOAP_TYPE_Metros; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Metros, default initialized and not managed by a soap context
        virtual Metros *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Metros); }
      public:
        /// Constructor with default initializations
        Metros() : __ptr(), __size(), soap() { }
        virtual ~Metros() { }
        /// Friend allocator used by soap_new_Metros(struct soap*, int)
        friend SOAP_FMAC1 Metros * SOAP_FMAC2 rrapi__instantiate_Metros(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:269 */
#ifndef SOAP_TYPE_Countries
#define SOAP_TYPE_Countries (61)
/* SOAP encoded array of ns1:Country schema type: */
class SOAP_CMAC Countries {
      public:
        ns1__Country **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Countries
        virtual long soap_type(void) const { return SOAP_TYPE_Countries; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Countries, default initialized and not managed by a soap context
        virtual Countries *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Countries); }
      public:
        /// Constructor with default initializations
        Countries() : __ptr(), __size(), soap() { }
        virtual ~Countries() { }
        /// Friend allocator used by soap_new_Countries(struct soap*, int)
        friend SOAP_FMAC1 Countries * SOAP_FMAC2 rrapi__instantiate_Countries(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:273 */
#ifndef SOAP_TYPE_Agencies
#define SOAP_TYPE_Agencies (63)
/* SOAP encoded array of ns1:Agency schema type: */
class SOAP_CMAC Agencies {
      public:
        ns1__Agency **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_Agencies
        virtual long soap_type(void) const { return SOAP_TYPE_Agencies; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type Agencies, default initialized and not managed by a soap context
        virtual Agencies *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(Agencies); }
      public:
        /// Constructor with default initializations
        Agencies() : __ptr(), __size(), soap() { }
        virtual ~Agencies() { }
        /// Friend allocator used by soap_new_Agencies(struct soap*, int)
        friend SOAP_FMAC1 Agencies * SOAP_FMAC2 rrapi__instantiate_Agencies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:277 */
#ifndef SOAP_TYPE_stids
#define SOAP_TYPE_stids (65)
/* SOAP encoded array of ns1:stid schema type: */
class SOAP_CMAC stids {
      public:
        ns1__stid **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_stids
        virtual long soap_type(void) const { return SOAP_TYPE_stids; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type stids, default initialized and not managed by a soap context
        virtual stids *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(stids); }
      public:
        /// Constructor with default initializations
        stids() : __ptr(), __size(), soap() { }
        virtual ~stids() { }
        /// Friend allocator used by soap_new_stids(struct soap*, int)
        friend SOAP_FMAC1 stids * SOAP_FMAC2 rrapi__instantiate_stids(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:281 */
#ifndef SOAP_TYPE_sids
#define SOAP_TYPE_sids (67)
/* SOAP encoded array of ns1:sid schema type: */
class SOAP_CMAC sids {
      public:
        ns1__sid **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_sids
        virtual long soap_type(void) const { return SOAP_TYPE_sids; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type sids, default initialized and not managed by a soap context
        virtual sids *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(sids); }
      public:
        /// Constructor with default initializations
        sids() : __ptr(), __size(), soap() { }
        virtual ~sids() { }
        /// Friend allocator used by soap_new_sids(struct soap*, int)
        friend SOAP_FMAC1 sids * SOAP_FMAC2 rrapi__instantiate_sids(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:285 */
#ifndef SOAP_TYPE_tags
#define SOAP_TYPE_tags (69)
/* SOAP encoded array of ns1:tag schema type: */
class SOAP_CMAC tags {
      public:
        ns1__tag **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tags
        virtual long soap_type(void) const { return SOAP_TYPE_tags; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tags, default initialized and not managed by a soap context
        virtual tags *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tags); }
      public:
        /// Constructor with default initializations
        tags() : __ptr(), __size(), soap() { }
        virtual ~tags() { }
        /// Friend allocator used by soap_new_tags(struct soap*, int)
        friend SOAP_FMAC1 tags * SOAP_FMAC2 rrapi__instantiate_tags(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:289 */
#ifndef SOAP_TYPE_modes
#define SOAP_TYPE_modes (71)
/* SOAP encoded array of ns1:mode schema type: */
class SOAP_CMAC modes {
      public:
        ns1__mode **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_modes
        virtual long soap_type(void) const { return SOAP_TYPE_modes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type modes, default initialized and not managed by a soap context
        virtual modes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(modes); }
      public:
        /// Constructor with default initializations
        modes() : __ptr(), __size(), soap() { }
        virtual ~modes() { }
        /// Friend allocator used by soap_new_modes(struct soap*, int)
        friend SOAP_FMAC1 modes * SOAP_FMAC2 rrapi__instantiate_modes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:301 */
#ifndef SOAP_TYPE_fccFrequencies
#define SOAP_TYPE_fccFrequencies (77)
/* SOAP encoded array of ns1:fccFrequency schema type: */
class SOAP_CMAC fccFrequencies {
      public:
        ns1__fccFrequency **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_fccFrequencies
        virtual long soap_type(void) const { return SOAP_TYPE_fccFrequencies; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fccFrequencies, default initialized and not managed by a soap context
        virtual fccFrequencies *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fccFrequencies); }
      public:
        /// Constructor with default initializations
        fccFrequencies() : __ptr(), __size(), soap() { }
        virtual ~fccFrequencies() { }
        /// Friend allocator used by soap_new_fccFrequencies(struct soap*, int)
        friend SOAP_FMAC1 fccFrequencies * SOAP_FMAC2 rrapi__instantiate_fccFrequencies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:305 */
#ifndef SOAP_TYPE_fccLocations
#define SOAP_TYPE_fccLocations (79)
/* SOAP encoded array of ns1:fccLocation schema type: */
class SOAP_CMAC fccLocations {
      public:
        ns1__fccLocation **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_fccLocations
        virtual long soap_type(void) const { return SOAP_TYPE_fccLocations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fccLocations, default initialized and not managed by a soap context
        virtual fccLocations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fccLocations); }
      public:
        /// Constructor with default initializations
        fccLocations() : __ptr(), __size(), soap() { }
        virtual ~fccLocations() { }
        /// Friend allocator used by soap_new_fccLocations(struct soap*, int)
        friend SOAP_FMAC1 fccLocations * SOAP_FMAC2 rrapi__instantiate_fccLocations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:309 */
#ifndef SOAP_TYPE_proxCallsignResults
#define SOAP_TYPE_proxCallsignResults (81)
/* SOAP encoded array of ns1:proxCallsignResult schema type: */
class SOAP_CMAC proxCallsignResults {
      public:
        ns1__proxCallsignResult **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_proxCallsignResults
        virtual long soap_type(void) const { return SOAP_TYPE_proxCallsignResults; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type proxCallsignResults, default initialized and not managed by a soap context
        virtual proxCallsignResults *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(proxCallsignResults); }
      public:
        /// Constructor with default initializations
        proxCallsignResults() : __ptr(), __size(), soap() { }
        virtual ~proxCallsignResults() { }
        /// Friend allocator used by soap_new_proxCallsignResults(struct soap*, int)
        friend SOAP_FMAC1 proxCallsignResults * SOAP_FMAC2 rrapi__instantiate_proxCallsignResults(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:313 */
#ifndef SOAP_TYPE_fccRadioServiceCodes
#define SOAP_TYPE_fccRadioServiceCodes (83)
/* SOAP encoded array of ns1:fccRadioServiceCode schema type: */
class SOAP_CMAC fccRadioServiceCodes {
      public:
        ns1__fccRadioServiceCode **__ptr;
        int __size;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_fccRadioServiceCodes
        virtual long soap_type(void) const { return SOAP_TYPE_fccRadioServiceCodes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type fccRadioServiceCodes, default initialized and not managed by a soap context
        virtual fccRadioServiceCodes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(fccRadioServiceCodes); }
      public:
        /// Constructor with default initializations
        fccRadioServiceCodes() : __ptr(), __size(), soap() { }
        virtual ~fccRadioServiceCodes() { }
        /// Friend allocator used by soap_new_fccRadioServiceCodes(struct soap*, int)
        friend SOAP_FMAC1 fccRadioServiceCodes * SOAP_FMAC2 rrapi__instantiate_fccRadioServiceCodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2552 */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroupsResponse
#define SOAP_TYPE_ns1__getTrsTalkgroupsResponse (164)
/* complex XML schema type 'ns1:getTrsTalkgroupsResponse': */
struct SOAP_CMAC ns1__getTrsTalkgroupsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfTalkgroup' */
        Talkgroups *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsTalkgroupsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsTalkgroupsResponse; }
        /** Constructor with member initializations */
        ns1__getTrsTalkgroupsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsTalkgroupsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroupsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2633 */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroups
#define SOAP_TYPE_ns1__getTrsTalkgroups (169)
/* complex XML schema type 'ns1:getTrsTalkgroups': */
struct SOAP_CMAC ns1__getTrsTalkgroups {
      public:
        /** Required element 'sid' of XML schema type 'xsd:int' */
        int sid;
        /** Required element 'tgCid' of XML schema type 'xsd:int' */
        int tgCid;
        /** Required element 'tgTag' of XML schema type 'xsd:int' */
        int tgTag;
        /** Required element 'tgDec' of XML schema type 'xsd:int' */
        int tgDec;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsTalkgroups */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsTalkgroups; }
        /** Constructor with member initializations */
        ns1__getTrsTalkgroups() : sid(), tgCid(), tgTag(), tgDec(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsTalkgroups * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroups(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2644 */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse
#define SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse (170)
/* complex XML schema type 'ns1:getTrsTalkgroupCatsResponse': */
struct SOAP_CMAC ns1__getTrsTalkgroupCatsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfTalkgroupCat' */
        TalkgroupCats *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse; }
        /** Constructor with member initializations */
        ns1__getTrsTalkgroupCatsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsTalkgroupCatsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroupCatsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2712 */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroupCats
#define SOAP_TYPE_ns1__getTrsTalkgroupCats (174)
/* complex XML schema type 'ns1:getTrsTalkgroupCats': */
struct SOAP_CMAC ns1__getTrsTalkgroupCats {
      public:
        /** Required element 'sid' of XML schema type 'xsd:int' */
        int sid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsTalkgroupCats */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsTalkgroupCats; }
        /** Constructor with member initializations */
        ns1__getTrsTalkgroupCats() : sid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsTalkgroupCats * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroupCats(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2723 */
#ifndef SOAP_TYPE_ns1__getTrsDetailsResponse
#define SOAP_TYPE_ns1__getTrsDetailsResponse (175)
/* complex XML schema type 'ns1:getTrsDetailsResponse': */
struct SOAP_CMAC ns1__getTrsDetailsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:Trs' */
        ns1__Trs *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsDetailsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsDetailsResponse; }
        /** Constructor with member initializations */
        ns1__getTrsDetailsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsDetailsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsDetailsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2791 */
#ifndef SOAP_TYPE_ns1__getTrsDetails
#define SOAP_TYPE_ns1__getTrsDetails (179)
/* complex XML schema type 'ns1:getTrsDetails': */
struct SOAP_CMAC ns1__getTrsDetails {
      public:
        /** Required element 'sid' of XML schema type 'xsd:int' */
        int sid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsDetails */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsDetails; }
        /** Constructor with member initializations */
        ns1__getTrsDetails() : sid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsDetails * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2802 */
#ifndef SOAP_TYPE_ns1__getTrsBySysidResponse
#define SOAP_TYPE_ns1__getTrsBySysidResponse (180)
/* complex XML schema type 'ns1:getTrsBySysidResponse': */
struct SOAP_CMAC ns1__getTrsBySysidResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfTrsListDef' */
        TrsList *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsBySysidResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsBySysidResponse; }
        /** Constructor with member initializations */
        ns1__getTrsBySysidResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsBySysidResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsBySysidResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2870 */
#ifndef SOAP_TYPE_ns1__getTrsBySysid
#define SOAP_TYPE_ns1__getTrsBySysid (183)
/* complex XML schema type 'ns1:getTrsBySysid': */
struct SOAP_CMAC ns1__getTrsBySysid {
      public:
        /** Required element 'sysid' of XML schema type 'xsd:string' */
        std::string sysid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsBySysid */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsBySysid; }
        /** Constructor with member initializations */
        ns1__getTrsBySysid() : sysid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsBySysid * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsBySysid(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2881 */
#ifndef SOAP_TYPE_ns1__getTrsSitesResponse
#define SOAP_TYPE_ns1__getTrsSitesResponse (184)
/* complex XML schema type 'ns1:getTrsSitesResponse': */
struct SOAP_CMAC ns1__getTrsSitesResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfTrsSite' */
        TrsSites *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsSitesResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsSitesResponse; }
        /** Constructor with member initializations */
        ns1__getTrsSitesResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsSitesResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsSitesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2949 */
#ifndef SOAP_TYPE_ns1__getTrsSites
#define SOAP_TYPE_ns1__getTrsSites (188)
/* complex XML schema type 'ns1:getTrsSites': */
struct SOAP_CMAC ns1__getTrsSites {
      public:
        /** Required element 'sid' of XML schema type 'xsd:int' */
        int sid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsSites */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsSites; }
        /** Constructor with member initializations */
        ns1__getTrsSites() : sid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsSites * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsSites(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:2960 */
#ifndef SOAP_TYPE_ns1__getStatesByListResponse
#define SOAP_TYPE_ns1__getStatesByListResponse (189)
/* complex XML schema type 'ns1:getStatesByListResponse': */
struct SOAP_CMAC ns1__getStatesByListResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfState' */
        States *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getStatesByListResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getStatesByListResponse; }
        /** Constructor with member initializations */
        ns1__getStatesByListResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getStatesByListResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getStatesByListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3028 */
#ifndef SOAP_TYPE_ns1__getStatesByList
#define SOAP_TYPE_ns1__getStatesByList (193)
/* complex XML schema type 'ns1:getStatesByList': */
struct SOAP_CMAC ns1__getStatesByList {
      public:
        /** Optional element 'request' of XML schema type 'ArrayOfstid' */
        stidList *request;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getStatesByList */
        long soap_type() const { return SOAP_TYPE_ns1__getStatesByList; }
        /** Constructor with member initializations */
        ns1__getStatesByList() : request(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getStatesByList * SOAP_FMAC2 rrapi__instantiate_ns1__getStatesByList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3039 */
#ifndef SOAP_TYPE_ns1__getCountiesByListResponse
#define SOAP_TYPE_ns1__getCountiesByListResponse (194)
/* complex XML schema type 'ns1:getCountiesByListResponse': */
struct SOAP_CMAC ns1__getCountiesByListResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfCounty' */
        Counties *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountiesByListResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getCountiesByListResponse; }
        /** Constructor with member initializations */
        ns1__getCountiesByListResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountiesByListResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountiesByListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3107 */
#ifndef SOAP_TYPE_ns1__getCountiesByList
#define SOAP_TYPE_ns1__getCountiesByList (198)
/* complex XML schema type 'ns1:getCountiesByList': */
struct SOAP_CMAC ns1__getCountiesByList {
      public:
        /** Optional element 'request' of XML schema type 'ArrayOfctid' */
        ctidList *request;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountiesByList */
        long soap_type() const { return SOAP_TYPE_ns1__getCountiesByList; }
        /** Constructor with member initializations */
        ns1__getCountiesByList() : request(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountiesByList * SOAP_FMAC2 rrapi__instantiate_ns1__getCountiesByList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3118 */
#ifndef SOAP_TYPE_ns1__getTagResponse
#define SOAP_TYPE_ns1__getTagResponse (199)
/* complex XML schema type 'ns1:getTagResponse': */
struct SOAP_CMAC ns1__getTagResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOftag' */
        tags *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTagResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTagResponse; }
        /** Constructor with member initializations */
        ns1__getTagResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTagResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTagResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3187 */
#ifndef SOAP_TYPE_ns1__getTag
#define SOAP_TYPE_ns1__getTag (202)
/* complex XML schema type 'ns1:getTag': */
struct SOAP_CMAC ns1__getTag {
      public:
        /** Required element 'id' of XML schema type 'xsd:int' */
        int id;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTag */
        long soap_type() const { return SOAP_TYPE_ns1__getTag; }
        /** Constructor with member initializations */
        ns1__getTag() : id(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTag * SOAP_FMAC2 rrapi__instantiate_ns1__getTag(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3198 */
#ifndef SOAP_TYPE_ns1__getModeResponse
#define SOAP_TYPE_ns1__getModeResponse (203)
/* complex XML schema type 'ns1:getModeResponse': */
struct SOAP_CMAC ns1__getModeResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfmode' */
        modes *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getModeResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getModeResponse; }
        /** Constructor with member initializations */
        ns1__getModeResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getModeResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3267 */
#ifndef SOAP_TYPE_ns1__getMode
#define SOAP_TYPE_ns1__getMode (207)
/* complex XML schema type 'ns1:getMode': */
struct SOAP_CMAC ns1__getMode {
      public:
        /** Required element 'mode' of XML schema type 'xsd:int' */
        int mode;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getMode */
        long soap_type() const { return SOAP_TYPE_ns1__getMode; }
        /** Constructor with member initializations */
        ns1__getMode() : mode(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getMode * SOAP_FMAC2 rrapi__instantiate_ns1__getMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3278 */
#ifndef SOAP_TYPE_ns1__getTrsTypeResponse
#define SOAP_TYPE_ns1__getTrsTypeResponse (208)
/* complex XML schema type 'ns1:getTrsTypeResponse': */
struct SOAP_CMAC ns1__getTrsTypeResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOftrsTypeDef' */
        TrsType *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsTypeResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsTypeResponse; }
        /** Constructor with member initializations */
        ns1__getTrsTypeResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsTypeResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTypeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3347 */
#ifndef SOAP_TYPE_ns1__getTrsType
#define SOAP_TYPE_ns1__getTrsType (212)
/* complex XML schema type 'ns1:getTrsType': */
struct SOAP_CMAC ns1__getTrsType {
      public:
        /** Required element 'id' of XML schema type 'xsd:int' */
        int id;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsType */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsType; }
        /** Constructor with member initializations */
        ns1__getTrsType() : id(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsType * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3358 */
#ifndef SOAP_TYPE_ns1__getTrsFlavorResponse
#define SOAP_TYPE_ns1__getTrsFlavorResponse (213)
/* complex XML schema type 'ns1:getTrsFlavorResponse': */
struct SOAP_CMAC ns1__getTrsFlavorResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOftrsFlavorDef' */
        TrsFlavor *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsFlavorResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsFlavorResponse; }
        /** Constructor with member initializations */
        ns1__getTrsFlavorResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsFlavorResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsFlavorResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3427 */
#ifndef SOAP_TYPE_ns1__getTrsFlavor
#define SOAP_TYPE_ns1__getTrsFlavor (217)
/* complex XML schema type 'ns1:getTrsFlavor': */
struct SOAP_CMAC ns1__getTrsFlavor {
      public:
        /** Required element 'id' of XML schema type 'xsd:int' */
        int id;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsFlavor */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsFlavor; }
        /** Constructor with member initializations */
        ns1__getTrsFlavor() : id(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsFlavor * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsFlavor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3438 */
#ifndef SOAP_TYPE_ns1__getTrsVoiceResponse
#define SOAP_TYPE_ns1__getTrsVoiceResponse (218)
/* complex XML schema type 'ns1:getTrsVoiceResponse': */
struct SOAP_CMAC ns1__getTrsVoiceResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOftrsVoiceDef' */
        TrsVoice *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsVoiceResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsVoiceResponse; }
        /** Constructor with member initializations */
        ns1__getTrsVoiceResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsVoiceResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsVoiceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3507 */
#ifndef SOAP_TYPE_ns1__getTrsVoice
#define SOAP_TYPE_ns1__getTrsVoice (222)
/* complex XML schema type 'ns1:getTrsVoice': */
struct SOAP_CMAC ns1__getTrsVoice {
      public:
        /** Required element 'id' of XML schema type 'xsd:int' */
        int id;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getTrsVoice */
        long soap_type() const { return SOAP_TYPE_ns1__getTrsVoice; }
        /** Constructor with member initializations */
        ns1__getTrsVoice() : id(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getTrsVoice * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsVoice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3518 */
#ifndef SOAP_TYPE_ns1__getCountryListResponse
#define SOAP_TYPE_ns1__getCountryListResponse (223)
/* complex XML schema type 'ns1:getCountryListResponse': */
struct SOAP_CMAC ns1__getCountryListResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfCountry' */
        Countries *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountryListResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getCountryListResponse; }
        /** Constructor with member initializations */
        ns1__getCountryListResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountryListResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3580 */
#ifndef SOAP_TYPE_ns1__getCountryList
#define SOAP_TYPE_ns1__getCountryList (227)
/* complex XML schema type 'ns1:getCountryList': */
struct SOAP_CMAC ns1__getCountryList {
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountryList */
        long soap_type() const { return SOAP_TYPE_ns1__getCountryList; }
        /** Constructor with member initializations */
        ns1__getCountryList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountryList * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3591 */
#ifndef SOAP_TYPE_ns1__getCountryInfoResponse
#define SOAP_TYPE_ns1__getCountryInfoResponse (228)
/* complex XML schema type 'ns1:getCountryInfoResponse': */
struct SOAP_CMAC ns1__getCountryInfoResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:CountryInfo' */
        ns1__CountryInfo *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountryInfoResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getCountryInfoResponse; }
        /** Constructor with member initializations */
        ns1__getCountryInfoResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountryInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3659 */
#ifndef SOAP_TYPE_ns1__getCountryInfo
#define SOAP_TYPE_ns1__getCountryInfo (232)
/* complex XML schema type 'ns1:getCountryInfo': */
struct SOAP_CMAC ns1__getCountryInfo {
      public:
        /** Required element 'coid' of XML schema type 'xsd:int' */
        int coid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountryInfo */
        long soap_type() const { return SOAP_TYPE_ns1__getCountryInfo; }
        /** Constructor with member initializations */
        ns1__getCountryInfo() : coid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountryInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3670 */
#ifndef SOAP_TYPE_ns1__getStateInfoResponse
#define SOAP_TYPE_ns1__getStateInfoResponse (233)
/* complex XML schema type 'ns1:getStateInfoResponse': */
struct SOAP_CMAC ns1__getStateInfoResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:StateInfo' */
        ns1__StateInfo *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getStateInfoResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getStateInfoResponse; }
        /** Constructor with member initializations */
        ns1__getStateInfoResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getStateInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getStateInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3739 */
#ifndef SOAP_TYPE_ns1__getStateInfo
#define SOAP_TYPE_ns1__getStateInfo (237)
/* complex XML schema type 'ns1:getStateInfo': */
struct SOAP_CMAC ns1__getStateInfo {
      public:
        /** Required element 'stid' of XML schema type 'xsd:int' */
        int stid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getStateInfo */
        long soap_type() const { return SOAP_TYPE_ns1__getStateInfo; }
        /** Constructor with member initializations */
        ns1__getStateInfo() : stid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getStateInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getStateInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3750 */
#ifndef SOAP_TYPE_ns1__getCountyInfoResponse
#define SOAP_TYPE_ns1__getCountyInfoResponse (238)
/* complex XML schema type 'ns1:getCountyInfoResponse': */
struct SOAP_CMAC ns1__getCountyInfoResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:CountyInfo' */
        ns1__CountyInfo *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountyInfoResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getCountyInfoResponse; }
        /** Constructor with member initializations */
        ns1__getCountyInfoResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountyInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3819 */
#ifndef SOAP_TYPE_ns1__getCountyInfo
#define SOAP_TYPE_ns1__getCountyInfo (242)
/* complex XML schema type 'ns1:getCountyInfo': */
struct SOAP_CMAC ns1__getCountyInfo {
      public:
        /** Required element 'ctid' of XML schema type 'xsd:int' */
        int ctid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountyInfo */
        long soap_type() const { return SOAP_TYPE_ns1__getCountyInfo; }
        /** Constructor with member initializations */
        ns1__getCountyInfo() : ctid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3830 */
#ifndef SOAP_TYPE_ns1__getAgencyInfoResponse
#define SOAP_TYPE_ns1__getAgencyInfoResponse (243)
/* complex XML schema type 'ns1:getAgencyInfoResponse': */
struct SOAP_CMAC ns1__getAgencyInfoResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:AgencyInfo' */
        ns1__AgencyInfo *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getAgencyInfoResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getAgencyInfoResponse; }
        /** Constructor with member initializations */
        ns1__getAgencyInfoResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getAgencyInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3899 */
#ifndef SOAP_TYPE_ns1__getAgencyInfo
#define SOAP_TYPE_ns1__getAgencyInfo (247)
/* complex XML schema type 'ns1:getAgencyInfo': */
struct SOAP_CMAC ns1__getAgencyInfo {
      public:
        /** Required element 'aid' of XML schema type 'xsd:int' */
        int aid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getAgencyInfo */
        long soap_type() const { return SOAP_TYPE_ns1__getAgencyInfo; }
        /** Constructor with member initializations */
        ns1__getAgencyInfo() : aid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getAgencyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3910 */
#ifndef SOAP_TYPE_ns1__getSubcatFreqsResponse
#define SOAP_TYPE_ns1__getSubcatFreqsResponse (248)
/* complex XML schema type 'ns1:getSubcatFreqsResponse': */
struct SOAP_CMAC ns1__getSubcatFreqsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOffreq' */
        Freqs *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getSubcatFreqsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getSubcatFreqsResponse; }
        /** Constructor with member initializations */
        ns1__getSubcatFreqsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getSubcatFreqsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getSubcatFreqsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3978 */
#ifndef SOAP_TYPE_ns1__getSubcatFreqs
#define SOAP_TYPE_ns1__getSubcatFreqs (252)
/* complex XML schema type 'ns1:getSubcatFreqs': */
struct SOAP_CMAC ns1__getSubcatFreqs {
      public:
        /** Required element 'scid' of XML schema type 'xsd:int' */
        int scid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getSubcatFreqs */
        long soap_type() const { return SOAP_TYPE_ns1__getSubcatFreqs; }
        /** Constructor with member initializations */
        ns1__getSubcatFreqs() : scid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getSubcatFreqs * SOAP_FMAC2 rrapi__instantiate_ns1__getSubcatFreqs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:3989 */
#ifndef SOAP_TYPE_ns1__searchCountyFreqResponse
#define SOAP_TYPE_ns1__searchCountyFreqResponse (253)
/* complex XML schema type 'ns1:searchCountyFreqResponse': */
struct SOAP_CMAC ns1__searchCountyFreqResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfsearchFreqResult' */
        searchFreqResults *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__searchCountyFreqResponse */
        long soap_type() const { return SOAP_TYPE_ns1__searchCountyFreqResponse; }
        /** Constructor with member initializations */
        ns1__searchCountyFreqResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__searchCountyFreqResponse * SOAP_FMAC2 rrapi__instantiate_ns1__searchCountyFreqResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4065 */
#ifndef SOAP_TYPE_ns1__searchCountyFreq
#define SOAP_TYPE_ns1__searchCountyFreq (257)
/* complex XML schema type 'ns1:searchCountyFreq': */
struct SOAP_CMAC ns1__searchCountyFreq {
      public:
        /** Required element 'ctid' of XML schema type 'xsd:int' */
        int ctid;
        /** Required element 'freq' of XML schema type 'xsd:decimal' */
        std::string freq;
        /** Required element 'tone' of XML schema type 'xsd:string' */
        std::string tone;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__searchCountyFreq */
        long soap_type() const { return SOAP_TYPE_ns1__searchCountyFreq; }
        /** Constructor with member initializations */
        ns1__searchCountyFreq() : ctid(), freq(), tone(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__searchCountyFreq * SOAP_FMAC2 rrapi__instantiate_ns1__searchCountyFreq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4076 */
#ifndef SOAP_TYPE_ns1__searchStateFreqResponse
#define SOAP_TYPE_ns1__searchStateFreqResponse (258)
/* complex XML schema type 'ns1:searchStateFreqResponse': */
struct SOAP_CMAC ns1__searchStateFreqResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfsearchFreqResult' */
        searchFreqResults *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__searchStateFreqResponse */
        long soap_type() const { return SOAP_TYPE_ns1__searchStateFreqResponse; }
        /** Constructor with member initializations */
        ns1__searchStateFreqResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__searchStateFreqResponse * SOAP_FMAC2 rrapi__instantiate_ns1__searchStateFreqResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4152 */
#ifndef SOAP_TYPE_ns1__searchStateFreq
#define SOAP_TYPE_ns1__searchStateFreq (261)
/* complex XML schema type 'ns1:searchStateFreq': */
struct SOAP_CMAC ns1__searchStateFreq {
      public:
        /** Required element 'stid' of XML schema type 'xsd:int' */
        int stid;
        /** Required element 'freq' of XML schema type 'xsd:decimal' */
        std::string freq;
        /** Required element 'tone' of XML schema type 'xsd:string' */
        std::string tone;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__searchStateFreq */
        long soap_type() const { return SOAP_TYPE_ns1__searchStateFreq; }
        /** Constructor with member initializations */
        ns1__searchStateFreq() : stid(), freq(), tone(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__searchStateFreq * SOAP_FMAC2 rrapi__instantiate_ns1__searchStateFreq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4163 */
#ifndef SOAP_TYPE_ns1__searchMetroFreqResponse
#define SOAP_TYPE_ns1__searchMetroFreqResponse (262)
/* complex XML schema type 'ns1:searchMetroFreqResponse': */
struct SOAP_CMAC ns1__searchMetroFreqResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfsearchFreqResult' */
        searchFreqResults *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__searchMetroFreqResponse */
        long soap_type() const { return SOAP_TYPE_ns1__searchMetroFreqResponse; }
        /** Constructor with member initializations */
        ns1__searchMetroFreqResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__searchMetroFreqResponse * SOAP_FMAC2 rrapi__instantiate_ns1__searchMetroFreqResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4239 */
#ifndef SOAP_TYPE_ns1__searchMetroFreq
#define SOAP_TYPE_ns1__searchMetroFreq (265)
/* complex XML schema type 'ns1:searchMetroFreq': */
struct SOAP_CMAC ns1__searchMetroFreq {
      public:
        /** Required element 'mid' of XML schema type 'xsd:int' */
        int mid;
        /** Required element 'freq' of XML schema type 'xsd:decimal' */
        std::string freq;
        /** Required element 'tone' of XML schema type 'xsd:string' */
        std::string tone;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__searchMetroFreq */
        long soap_type() const { return SOAP_TYPE_ns1__searchMetroFreq; }
        /** Constructor with member initializations */
        ns1__searchMetroFreq() : mid(), freq(), tone(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__searchMetroFreq * SOAP_FMAC2 rrapi__instantiate_ns1__searchMetroFreq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4250 */
#ifndef SOAP_TYPE_ns1__getCountyFreqsByTagResponse
#define SOAP_TYPE_ns1__getCountyFreqsByTagResponse (266)
/* complex XML schema type 'ns1:getCountyFreqsByTagResponse': */
struct SOAP_CMAC ns1__getCountyFreqsByTagResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOffreq' */
        Freqs *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountyFreqsByTagResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getCountyFreqsByTagResponse; }
        /** Constructor with member initializations */
        ns1__getCountyFreqsByTagResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountyFreqsByTagResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyFreqsByTagResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4321 */
#ifndef SOAP_TYPE_ns1__getCountyFreqsByTag
#define SOAP_TYPE_ns1__getCountyFreqsByTag (269)
/* complex XML schema type 'ns1:getCountyFreqsByTag': */
struct SOAP_CMAC ns1__getCountyFreqsByTag {
      public:
        /** Required element 'ctid' of XML schema type 'xsd:int' */
        int ctid;
        /** Required element 'tag' of XML schema type 'xsd:int' */
        int tag;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getCountyFreqsByTag */
        long soap_type() const { return SOAP_TYPE_ns1__getCountyFreqsByTag; }
        /** Constructor with member initializations */
        ns1__getCountyFreqsByTag() : ctid(), tag(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getCountyFreqsByTag * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyFreqsByTag(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4332 */
#ifndef SOAP_TYPE_ns1__getAgencyFreqsByTagResponse
#define SOAP_TYPE_ns1__getAgencyFreqsByTagResponse (270)
/* complex XML schema type 'ns1:getAgencyFreqsByTagResponse': */
struct SOAP_CMAC ns1__getAgencyFreqsByTagResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOffreq' */
        Freqs *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getAgencyFreqsByTagResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getAgencyFreqsByTagResponse; }
        /** Constructor with member initializations */
        ns1__getAgencyFreqsByTagResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getAgencyFreqsByTagResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyFreqsByTagResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4403 */
#ifndef SOAP_TYPE_ns1__getAgencyFreqsByTag
#define SOAP_TYPE_ns1__getAgencyFreqsByTag (273)
/* complex XML schema type 'ns1:getAgencyFreqsByTag': */
struct SOAP_CMAC ns1__getAgencyFreqsByTag {
      public:
        /** Required element 'aid' of XML schema type 'xsd:int' */
        int aid;
        /** Required element 'tag' of XML schema type 'xsd:int' */
        int tag;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getAgencyFreqsByTag */
        long soap_type() const { return SOAP_TYPE_ns1__getAgencyFreqsByTag; }
        /** Constructor with member initializations */
        ns1__getAgencyFreqsByTag() : aid(), tag(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getAgencyFreqsByTag * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyFreqsByTag(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4414 */
#ifndef SOAP_TYPE_ns1__getMetroAreaResponse
#define SOAP_TYPE_ns1__getMetroAreaResponse (274)
/* complex XML schema type 'ns1:getMetroAreaResponse': */
struct SOAP_CMAC ns1__getMetroAreaResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfMetro' */
        Metros *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getMetroAreaResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getMetroAreaResponse; }
        /** Constructor with member initializations */
        ns1__getMetroAreaResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getMetroAreaResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroAreaResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4483 */
#ifndef SOAP_TYPE_ns1__getMetroArea
#define SOAP_TYPE_ns1__getMetroArea (278)
/* complex XML schema type 'ns1:getMetroArea': */
struct SOAP_CMAC ns1__getMetroArea {
      public:
        /** Required element 'mid' of XML schema type 'xsd:int' */
        int mid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getMetroArea */
        long soap_type() const { return SOAP_TYPE_ns1__getMetroArea; }
        /** Constructor with member initializations */
        ns1__getMetroArea() : mid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getMetroArea * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroArea(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4494 */
#ifndef SOAP_TYPE_ns1__getMetroAreaInfoResponse
#define SOAP_TYPE_ns1__getMetroAreaInfoResponse (279)
/* complex XML schema type 'ns1:getMetroAreaInfoResponse': */
struct SOAP_CMAC ns1__getMetroAreaInfoResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfCounty' */
        Counties *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getMetroAreaInfoResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getMetroAreaInfoResponse; }
        /** Constructor with member initializations */
        ns1__getMetroAreaInfoResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getMetroAreaInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroAreaInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4562 */
#ifndef SOAP_TYPE_ns1__getMetroAreaInfo
#define SOAP_TYPE_ns1__getMetroAreaInfo (282)
/* complex XML schema type 'ns1:getMetroAreaInfo': */
struct SOAP_CMAC ns1__getMetroAreaInfo {
      public:
        /** Required element 'mid' of XML schema type 'xsd:int' */
        int mid;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getMetroAreaInfo */
        long soap_type() const { return SOAP_TYPE_ns1__getMetroAreaInfo; }
        /** Constructor with member initializations */
        ns1__getMetroAreaInfo() : mid(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getMetroAreaInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroAreaInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4573 */
#ifndef SOAP_TYPE_ns1__getZipcodeInfoResponse
#define SOAP_TYPE_ns1__getZipcodeInfoResponse (283)
/* complex XML schema type 'ns1:getZipcodeInfoResponse': */
struct SOAP_CMAC ns1__getZipcodeInfoResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:ZipInfo' */
        ns1__ZipInfo *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getZipcodeInfoResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getZipcodeInfoResponse; }
        /** Constructor with member initializations */
        ns1__getZipcodeInfoResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getZipcodeInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getZipcodeInfoResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4641 */
#ifndef SOAP_TYPE_ns1__getZipcodeInfo
#define SOAP_TYPE_ns1__getZipcodeInfo (287)
/* complex XML schema type 'ns1:getZipcodeInfo': */
struct SOAP_CMAC ns1__getZipcodeInfo {
      public:
        /** Required element 'zipcode' of XML schema type 'xsd:int' */
        int zipcode;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getZipcodeInfo */
        long soap_type() const { return SOAP_TYPE_ns1__getZipcodeInfo; }
        /** Constructor with member initializations */
        ns1__getZipcodeInfo() : zipcode(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getZipcodeInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getZipcodeInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4652 */
#ifndef SOAP_TYPE_ns1__fccGetCallsignResponse
#define SOAP_TYPE_ns1__fccGetCallsignResponse (288)
/* complex XML schema type 'ns1:fccGetCallsignResponse': */
struct SOAP_CMAC ns1__fccGetCallsignResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:fccCallsignDetails' */
        ns1__fccCallsignDetails *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__fccGetCallsignResponse */
        long soap_type() const { return SOAP_TYPE_ns1__fccGetCallsignResponse; }
        /** Constructor with member initializations */
        ns1__fccGetCallsignResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__fccGetCallsignResponse * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetCallsignResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4720 */
#ifndef SOAP_TYPE_ns1__fccGetCallsign
#define SOAP_TYPE_ns1__fccGetCallsign (292)
/* complex XML schema type 'ns1:fccGetCallsign': */
struct SOAP_CMAC ns1__fccGetCallsign {
      public:
        /** Required element 'callsign' of XML schema type 'xsd:string' */
        std::string callsign;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__fccGetCallsign */
        long soap_type() const { return SOAP_TYPE_ns1__fccGetCallsign; }
        /** Constructor with member initializations */
        ns1__fccGetCallsign() : callsign(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__fccGetCallsign * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetCallsign(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4731 */
#ifndef SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse
#define SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse (293)
/* complex XML schema type 'ns1:fccGetRadioServiceCodeResponse': */
struct SOAP_CMAC ns1__fccGetRadioServiceCodeResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOffccRadioServiceCode' */
        fccRadioServiceCodes *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse */
        long soap_type() const { return SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse; }
        /** Constructor with member initializations */
        ns1__fccGetRadioServiceCodeResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__fccGetRadioServiceCodeResponse * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetRadioServiceCodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4800 */
#ifndef SOAP_TYPE_ns1__fccGetRadioServiceCode
#define SOAP_TYPE_ns1__fccGetRadioServiceCode (297)
/* complex XML schema type 'ns1:fccGetRadioServiceCode': */
struct SOAP_CMAC ns1__fccGetRadioServiceCode {
      public:
        /** Required element 'code' of XML schema type 'xsd:string' */
        std::string code;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__fccGetRadioServiceCode */
        long soap_type() const { return SOAP_TYPE_ns1__fccGetRadioServiceCode; }
        /** Constructor with member initializations */
        ns1__fccGetRadioServiceCode() : code(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__fccGetRadioServiceCode * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetRadioServiceCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4811 */
#ifndef SOAP_TYPE_ns1__fccGetProxCallsignsResponse
#define SOAP_TYPE_ns1__fccGetProxCallsignsResponse (298)
/* complex XML schema type 'ns1:fccGetProxCallsignsResponse': */
struct SOAP_CMAC ns1__fccGetProxCallsignsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfproxCallsignResult' */
        proxCallsignResults *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__fccGetProxCallsignsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__fccGetProxCallsignsResponse; }
        /** Constructor with member initializations */
        ns1__fccGetProxCallsignsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__fccGetProxCallsignsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetProxCallsignsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4891 */
#ifndef SOAP_TYPE_ns1__fccGetProxCallsigns
#define SOAP_TYPE_ns1__fccGetProxCallsigns (302)
/* complex XML schema type 'ns1:fccGetProxCallsigns': */
struct SOAP_CMAC ns1__fccGetProxCallsigns {
      public:
        /** Required element 'lat' of XML schema type 'xsd:decimal' */
        std::string lat;
        /** Required element 'lon' of XML schema type 'xsd:decimal' */
        std::string lon;
        /** Required element 'range' of XML schema type 'xsd:decimal' */
        std::string range;
        /** Required element 'unit' of XML schema type 'xsd:string' */
        std::string unit;
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__fccGetProxCallsigns */
        long soap_type() const { return SOAP_TYPE_ns1__fccGetProxCallsigns; }
        /** Constructor with member initializations */
        ns1__fccGetProxCallsigns() : lat(), lon(), range(), unit(), authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__fccGetProxCallsigns * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetProxCallsigns(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4902 */
#ifndef SOAP_TYPE_ns1__getUserDataResponse
#define SOAP_TYPE_ns1__getUserDataResponse (303)
/* complex XML schema type 'ns1:getUserDataResponse': */
struct SOAP_CMAC ns1__getUserDataResponse {
      public:
        /** Optional element 'return' of XML schema type 'ns1:UserInfo' */
        ns1__UserInfo *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getUserDataResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getUserDataResponse; }
        /** Constructor with member initializations */
        ns1__getUserDataResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getUserDataResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getUserDataResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4967 */
#ifndef SOAP_TYPE_ns1__getUserData
#define SOAP_TYPE_ns1__getUserData (307)
/* complex XML schema type 'ns1:getUserData': */
struct SOAP_CMAC ns1__getUserData {
      public:
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getUserData */
        long soap_type() const { return SOAP_TYPE_ns1__getUserData; }
        /** Constructor with member initializations */
        ns1__getUserData() : authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getUserData * SOAP_FMAC2 rrapi__instantiate_ns1__getUserData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:4978 */
#ifndef SOAP_TYPE_ns1__getUserFeedBroadcastsResponse
#define SOAP_TYPE_ns1__getUserFeedBroadcastsResponse (308)
/* complex XML schema type 'ns1:getUserFeedBroadcastsResponse': */
struct SOAP_CMAC ns1__getUserFeedBroadcastsResponse {
      public:
        /** Optional element 'return' of XML schema type 'ArrayOfuserFeedBroadcast' */
        userFeedBroadcasts *return_;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getUserFeedBroadcastsResponse */
        long soap_type() const { return SOAP_TYPE_ns1__getUserFeedBroadcastsResponse; }
        /** Constructor with member initializations */
        ns1__getUserFeedBroadcastsResponse() : return_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getUserFeedBroadcastsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getUserFeedBroadcastsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:5043 */
#ifndef SOAP_TYPE_ns1__getUserFeedBroadcasts
#define SOAP_TYPE_ns1__getUserFeedBroadcasts (312)
/* complex XML schema type 'ns1:getUserFeedBroadcasts': */
struct SOAP_CMAC ns1__getUserFeedBroadcasts {
      public:
        /** Optional element 'authInfo' of XML schema type 'ns1:authInfo' */
        ns1__authInfo *authInfo;
      public:
        /** Return unique type id SOAP_TYPE_ns1__getUserFeedBroadcasts */
        long soap_type() const { return SOAP_TYPE_ns1__getUserFeedBroadcasts; }
        /** Constructor with member initializations */
        ns1__getUserFeedBroadcasts() : authInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ns1__getUserFeedBroadcasts * SOAP_FMAC2 rrapi__instantiate_ns1__getUserFeedBroadcasts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* api.radioreference.h:5104 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (313)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* api.radioreference.h:5104 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (314)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* api.radioreference.h:5104 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (316)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* api.radioreference.h:5104 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (319)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* api.radioreference.h:5104 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (320)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* api.radioreference.h:161 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (11)
typedef std::string xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (87)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (85)
#endif

/* fccRadioServiceCodes has binding name 'fccRadioServiceCodes' for type 'ns1:fccRadioServiceCode' */
#ifndef SOAP_TYPE_fccRadioServiceCodes
#define SOAP_TYPE_fccRadioServiceCodes (83)
#endif

/* ns1__fccRadioServiceCode has binding name 'ns1__fccRadioServiceCode' for type 'ns1:fccRadioServiceCode' */
#ifndef SOAP_TYPE_ns1__fccRadioServiceCode
#define SOAP_TYPE_ns1__fccRadioServiceCode (82)
#endif

/* proxCallsignResults has binding name 'proxCallsignResults' for type 'ns1:proxCallsignResult' */
#ifndef SOAP_TYPE_proxCallsignResults
#define SOAP_TYPE_proxCallsignResults (81)
#endif

/* ns1__proxCallsignResult has binding name 'ns1__proxCallsignResult' for type 'ns1:proxCallsignResult' */
#ifndef SOAP_TYPE_ns1__proxCallsignResult
#define SOAP_TYPE_ns1__proxCallsignResult (80)
#endif

/* fccLocations has binding name 'fccLocations' for type 'ns1:fccLocation' */
#ifndef SOAP_TYPE_fccLocations
#define SOAP_TYPE_fccLocations (79)
#endif

/* ns1__fccLocation has binding name 'ns1__fccLocation' for type 'ns1:fccLocation' */
#ifndef SOAP_TYPE_ns1__fccLocation
#define SOAP_TYPE_ns1__fccLocation (78)
#endif

/* fccFrequencies has binding name 'fccFrequencies' for type 'ns1:fccFrequency' */
#ifndef SOAP_TYPE_fccFrequencies
#define SOAP_TYPE_fccFrequencies (77)
#endif

/* ns1__fccFrequency has binding name 'ns1__fccFrequency' for type 'ns1:fccFrequency' */
#ifndef SOAP_TYPE_ns1__fccFrequency
#define SOAP_TYPE_ns1__fccFrequency (76)
#endif

/* ns1__fccCallsignDetails has binding name 'ns1__fccCallsignDetails' for type 'ns1:fccCallsignDetails' */
#ifndef SOAP_TYPE_ns1__fccCallsignDetails
#define SOAP_TYPE_ns1__fccCallsignDetails (75)
#endif

/* ns1__UserInfo has binding name 'ns1__UserInfo' for type 'ns1:UserInfo' */
#ifndef SOAP_TYPE_ns1__UserInfo
#define SOAP_TYPE_ns1__UserInfo (74)
#endif

/* ns1__ZipInfo has binding name 'ns1__ZipInfo' for type 'ns1:ZipInfo' */
#ifndef SOAP_TYPE_ns1__ZipInfo
#define SOAP_TYPE_ns1__ZipInfo (73)
#endif

/* ns1__mode has binding name 'ns1__mode' for type 'ns1:mode' */
#ifndef SOAP_TYPE_ns1__mode
#define SOAP_TYPE_ns1__mode (72)
#endif

/* modes has binding name 'modes' for type 'ns1:mode' */
#ifndef SOAP_TYPE_modes
#define SOAP_TYPE_modes (71)
#endif

/* ns1__tag has binding name 'ns1__tag' for type 'ns1:tag' */
#ifndef SOAP_TYPE_ns1__tag
#define SOAP_TYPE_ns1__tag (70)
#endif

/* tags has binding name 'tags' for type 'ns1:tag' */
#ifndef SOAP_TYPE_tags
#define SOAP_TYPE_tags (69)
#endif

/* ns1__sid has binding name 'ns1__sid' for type 'ns1:sid' */
#ifndef SOAP_TYPE_ns1__sid
#define SOAP_TYPE_ns1__sid (68)
#endif

/* sids has binding name 'sids' for type 'ns1:sid' */
#ifndef SOAP_TYPE_sids
#define SOAP_TYPE_sids (67)
#endif

/* ns1__stid has binding name 'ns1__stid' for type 'ns1:stid' */
#ifndef SOAP_TYPE_ns1__stid
#define SOAP_TYPE_ns1__stid (66)
#endif

/* stids has binding name 'stids' for type 'ns1:stid' */
#ifndef SOAP_TYPE_stids
#define SOAP_TYPE_stids (65)
#endif

/* ns1__Agency has binding name 'ns1__Agency' for type 'ns1:Agency' */
#ifndef SOAP_TYPE_ns1__Agency
#define SOAP_TYPE_ns1__Agency (64)
#endif

/* Agencies has binding name 'Agencies' for type 'ns1:Agency' */
#ifndef SOAP_TYPE_Agencies
#define SOAP_TYPE_Agencies (63)
#endif

/* ns1__Country has binding name 'ns1__Country' for type 'ns1:Country' */
#ifndef SOAP_TYPE_ns1__Country
#define SOAP_TYPE_ns1__Country (62)
#endif

/* Countries has binding name 'Countries' for type 'ns1:Country' */
#ifndef SOAP_TYPE_Countries
#define SOAP_TYPE_Countries (61)
#endif

/* ns1__Metro has binding name 'ns1__Metro' for type 'ns1:Metro' */
#ifndef SOAP_TYPE_ns1__Metro
#define SOAP_TYPE_ns1__Metro (60)
#endif

/* Metros has binding name 'Metros' for type 'ns1:Metro' */
#ifndef SOAP_TYPE_Metros
#define SOAP_TYPE_Metros (59)
#endif

/* ns1__State has binding name 'ns1__State' for type 'ns1:State' */
#ifndef SOAP_TYPE_ns1__State
#define SOAP_TYPE_ns1__State (58)
#endif

/* States has binding name 'States' for type 'ns1:State' */
#ifndef SOAP_TYPE_States
#define SOAP_TYPE_States (57)
#endif

/* ns1__ctid has binding name 'ns1__ctid' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_ns1__ctid
#define SOAP_TYPE_ns1__ctid (56)
#endif

/* ctids has binding name 'ctids' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_ctids
#define SOAP_TYPE_ctids (55)
#endif

/* Counties has binding name 'Counties' for type 'ns1:County' */
#ifndef SOAP_TYPE_Counties
#define SOAP_TYPE_Counties (54)
#endif

/* ns1__County has binding name 'ns1__County' for type 'ns1:County' */
#ifndef SOAP_TYPE_ns1__County
#define SOAP_TYPE_ns1__County (53)
#endif

/* ns1__StateInfo has binding name 'ns1__StateInfo' for type 'ns1:StateInfo' */
#ifndef SOAP_TYPE_ns1__StateInfo
#define SOAP_TYPE_ns1__StateInfo (52)
#endif

/* ns1__CountyInfo has binding name 'ns1__CountyInfo' for type 'ns1:CountyInfo' */
#ifndef SOAP_TYPE_ns1__CountyInfo
#define SOAP_TYPE_ns1__CountyInfo (51)
#endif

/* ns1__CountryInfo has binding name 'ns1__CountryInfo' for type 'ns1:CountryInfo' */
#ifndef SOAP_TYPE_ns1__CountryInfo
#define SOAP_TYPE_ns1__CountryInfo (50)
#endif

/* ns1__AgencyInfo has binding name 'ns1__AgencyInfo' for type 'ns1:AgencyInfo' */
#ifndef SOAP_TYPE_ns1__AgencyInfo
#define SOAP_TYPE_ns1__AgencyInfo (49)
#endif

/* ns1__subcat has binding name 'ns1__subcat' for type 'ns1:subcat' */
#ifndef SOAP_TYPE_ns1__subcat
#define SOAP_TYPE_ns1__subcat (48)
#endif

/* SubCats has binding name 'SubCats' for type 'ns1:subcat' */
#ifndef SOAP_TYPE_SubCats
#define SOAP_TYPE_SubCats (47)
#endif

/* ns1__cat has binding name 'ns1__cat' for type 'ns1:cat' */
#ifndef SOAP_TYPE_ns1__cat
#define SOAP_TYPE_ns1__cat (46)
#endif

/* Cats has binding name 'Cats' for type 'ns1:cat' */
#ifndef SOAP_TYPE_Cats
#define SOAP_TYPE_Cats (45)
#endif

/* Freqs has binding name 'Freqs' for type 'ns1:freq' */
#ifndef SOAP_TYPE_Freqs
#define SOAP_TYPE_Freqs (44)
#endif

/* searchFreqResults has binding name 'searchFreqResults' for type 'ns1:searchFreqResult' */
#ifndef SOAP_TYPE_searchFreqResults
#define SOAP_TYPE_searchFreqResults (43)
#endif

/* ns1__searchFreqResult has binding name 'ns1__searchFreqResult' for type 'ns1:searchFreqResult' */
#ifndef SOAP_TYPE_ns1__searchFreqResult
#define SOAP_TYPE_ns1__searchFreqResult (42)
#endif

/* ns1__freq has binding name 'ns1__freq' for type 'ns1:freq' */
#ifndef SOAP_TYPE_ns1__freq
#define SOAP_TYPE_ns1__freq (41)
#endif

/* TrsVoice has binding name 'TrsVoice' for type 'ns1:trsVoiceDef' */
#ifndef SOAP_TYPE_TrsVoice
#define SOAP_TYPE_TrsVoice (40)
#endif

/* ns1__trsVoiceDef has binding name 'ns1__trsVoiceDef' for type 'ns1:trsVoiceDef' */
#ifndef SOAP_TYPE_ns1__trsVoiceDef
#define SOAP_TYPE_ns1__trsVoiceDef (39)
#endif

/* TrsFlavor has binding name 'TrsFlavor' for type 'ns1:trsFlavorDef' */
#ifndef SOAP_TYPE_TrsFlavor
#define SOAP_TYPE_TrsFlavor (38)
#endif

/* ns1__trsFlavorDef has binding name 'ns1__trsFlavorDef' for type 'ns1:trsFlavorDef' */
#ifndef SOAP_TYPE_ns1__trsFlavorDef
#define SOAP_TYPE_ns1__trsFlavorDef (37)
#endif

/* TrsType has binding name 'TrsType' for type 'ns1:trsTypeDef' */
#ifndef SOAP_TYPE_TrsType
#define SOAP_TYPE_TrsType (36)
#endif

/* ns1__trsTypeDef has binding name 'ns1__trsTypeDef' for type 'ns1:trsTypeDef' */
#ifndef SOAP_TYPE_ns1__trsTypeDef
#define SOAP_TYPE_ns1__trsTypeDef (35)
#endif

/* ns1__TrsFleetmap has binding name 'ns1__TrsFleetmap' for type 'ns1:TrsFleetmap' */
#ifndef SOAP_TYPE_ns1__TrsFleetmap
#define SOAP_TYPE_ns1__TrsFleetmap (34)
#endif

/* TrsBandplan has binding name 'TrsBandplan' for type 'ns1:trsBandplanDef' */
#ifndef SOAP_TYPE_TrsBandplan
#define SOAP_TYPE_TrsBandplan (33)
#endif

/* ns1__trsBandplanDef has binding name 'ns1__trsBandplanDef' for type 'ns1:trsBandplanDef' */
#ifndef SOAP_TYPE_ns1__trsBandplanDef
#define SOAP_TYPE_ns1__trsBandplanDef (32)
#endif

/* TrsSysid has binding name 'TrsSysid' for type 'ns1:trsSysidDef' */
#ifndef SOAP_TYPE_TrsSysid
#define SOAP_TYPE_TrsSysid (31)
#endif

/* ns1__trsSysidDef has binding name 'ns1__trsSysidDef' for type 'ns1:trsSysidDef' */
#ifndef SOAP_TYPE_ns1__trsSysidDef
#define SOAP_TYPE_ns1__trsSysidDef (30)
#endif

/* TrsList has binding name 'TrsList' for type 'ns1:TrsListDef' */
#ifndef SOAP_TYPE_TrsList
#define SOAP_TYPE_TrsList (29)
#endif

/* ns1__TrsListDef has binding name 'ns1__TrsListDef' for type 'ns1:TrsListDef' */
#ifndef SOAP_TYPE_ns1__TrsListDef
#define SOAP_TYPE_ns1__TrsListDef (28)
#endif

/* ns1__Trs has binding name 'ns1__Trs' for type 'ns1:Trs' */
#ifndef SOAP_TYPE_ns1__Trs
#define SOAP_TYPE_ns1__Trs (27)
#endif

/* TrsSiteLicenses has binding name 'TrsSiteLicenses' for type 'ns1:TrsSiteLicense' */
#ifndef SOAP_TYPE_TrsSiteLicenses
#define SOAP_TYPE_TrsSiteLicenses (26)
#endif

/* ns1__TrsSiteLicense has binding name 'ns1__TrsSiteLicense' for type 'ns1:TrsSiteLicense' */
#ifndef SOAP_TYPE_ns1__TrsSiteLicense
#define SOAP_TYPE_ns1__TrsSiteLicense (25)
#endif

/* TrsSiteFreqs has binding name 'TrsSiteFreqs' for type 'ns1:TrsSiteFreq' */
#ifndef SOAP_TYPE_TrsSiteFreqs
#define SOAP_TYPE_TrsSiteFreqs (24)
#endif

/* ns1__TrsSiteFreq has binding name 'ns1__TrsSiteFreq' for type 'ns1:TrsSiteFreq' */
#ifndef SOAP_TYPE_ns1__TrsSiteFreq
#define SOAP_TYPE_ns1__TrsSiteFreq (23)
#endif

/* TrsSites has binding name 'TrsSites' for type 'ns1:TrsSite' */
#ifndef SOAP_TYPE_TrsSites
#define SOAP_TYPE_TrsSites (22)
#endif

/* ns1__TrsSite has binding name 'ns1__TrsSite' for type 'ns1:TrsSite' */
#ifndef SOAP_TYPE_ns1__TrsSite
#define SOAP_TYPE_ns1__TrsSite (21)
#endif

/* TalkgroupCats has binding name 'TalkgroupCats' for type 'ns1:TalkgroupCat' */
#ifndef SOAP_TYPE_TalkgroupCats
#define SOAP_TYPE_TalkgroupCats (20)
#endif

/* ns1__TalkgroupCat has binding name 'ns1__TalkgroupCat' for type 'ns1:TalkgroupCat' */
#ifndef SOAP_TYPE_ns1__TalkgroupCat
#define SOAP_TYPE_ns1__TalkgroupCat (19)
#endif

/* Talkgroups has binding name 'Talkgroups' for type 'ns1:Talkgroup' */
#ifndef SOAP_TYPE_Talkgroups
#define SOAP_TYPE_Talkgroups (18)
#endif

/* ns1__Talkgroup has binding name 'ns1__Talkgroup' for type 'ns1:Talkgroup' */
#ifndef SOAP_TYPE_ns1__Talkgroup
#define SOAP_TYPE_ns1__Talkgroup (17)
#endif

/* ctidList has binding name 'ctidList' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_ctidList
#define SOAP_TYPE_ctidList (16)
#endif

/* stidList has binding name 'stidList' for type 'ns1:stid' */
#ifndef SOAP_TYPE_stidList
#define SOAP_TYPE_stidList (15)
#endif

/* userFeedBroadcasts has binding name 'userFeedBroadcasts' for type 'ns1:userFeedBroadcast' */
#ifndef SOAP_TYPE_userFeedBroadcasts
#define SOAP_TYPE_userFeedBroadcasts (14)
#endif

/* ns1__userFeedBroadcast has binding name 'ns1__userFeedBroadcast' for type 'ns1:userFeedBroadcast' */
#ifndef SOAP_TYPE_ns1__userFeedBroadcast
#define SOAP_TYPE_ns1__userFeedBroadcast (13)
#endif

/* ns1__authInfo has binding name 'ns1__authInfo' for type 'ns1:authInfo' */
#ifndef SOAP_TYPE_ns1__authInfo
#define SOAP_TYPE_ns1__authInfo (12)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (11)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (10)
#endif

/* SOAP_ENC__Array has binding name 'SOAP_ENC__Array' for type 'SOAP-ENC:Array' */
#ifndef SOAP_TYPE_SOAP_ENC__Array
#define SOAP_TYPE_SOAP_ENC__Array (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (320)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (319)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (316)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (314)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (313)
#endif

/* struct ns1__getUserFeedBroadcasts has binding name 'ns1__getUserFeedBroadcasts' for type 'ns1:getUserFeedBroadcasts' */
#ifndef SOAP_TYPE_ns1__getUserFeedBroadcasts
#define SOAP_TYPE_ns1__getUserFeedBroadcasts (312)
#endif

/* struct ns1__getUserFeedBroadcastsResponse has binding name 'ns1__getUserFeedBroadcastsResponse' for type 'ns1:getUserFeedBroadcastsResponse' */
#ifndef SOAP_TYPE_ns1__getUserFeedBroadcastsResponse
#define SOAP_TYPE_ns1__getUserFeedBroadcastsResponse (308)
#endif

/* struct ns1__getUserData has binding name 'ns1__getUserData' for type 'ns1:getUserData' */
#ifndef SOAP_TYPE_ns1__getUserData
#define SOAP_TYPE_ns1__getUserData (307)
#endif

/* struct ns1__getUserDataResponse has binding name 'ns1__getUserDataResponse' for type 'ns1:getUserDataResponse' */
#ifndef SOAP_TYPE_ns1__getUserDataResponse
#define SOAP_TYPE_ns1__getUserDataResponse (303)
#endif

/* struct ns1__fccGetProxCallsigns has binding name 'ns1__fccGetProxCallsigns' for type 'ns1:fccGetProxCallsigns' */
#ifndef SOAP_TYPE_ns1__fccGetProxCallsigns
#define SOAP_TYPE_ns1__fccGetProxCallsigns (302)
#endif

/* struct ns1__fccGetProxCallsignsResponse has binding name 'ns1__fccGetProxCallsignsResponse' for type 'ns1:fccGetProxCallsignsResponse' */
#ifndef SOAP_TYPE_ns1__fccGetProxCallsignsResponse
#define SOAP_TYPE_ns1__fccGetProxCallsignsResponse (298)
#endif

/* struct ns1__fccGetRadioServiceCode has binding name 'ns1__fccGetRadioServiceCode' for type 'ns1:fccGetRadioServiceCode' */
#ifndef SOAP_TYPE_ns1__fccGetRadioServiceCode
#define SOAP_TYPE_ns1__fccGetRadioServiceCode (297)
#endif

/* struct ns1__fccGetRadioServiceCodeResponse has binding name 'ns1__fccGetRadioServiceCodeResponse' for type 'ns1:fccGetRadioServiceCodeResponse' */
#ifndef SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse
#define SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse (293)
#endif

/* struct ns1__fccGetCallsign has binding name 'ns1__fccGetCallsign' for type 'ns1:fccGetCallsign' */
#ifndef SOAP_TYPE_ns1__fccGetCallsign
#define SOAP_TYPE_ns1__fccGetCallsign (292)
#endif

/* struct ns1__fccGetCallsignResponse has binding name 'ns1__fccGetCallsignResponse' for type 'ns1:fccGetCallsignResponse' */
#ifndef SOAP_TYPE_ns1__fccGetCallsignResponse
#define SOAP_TYPE_ns1__fccGetCallsignResponse (288)
#endif

/* struct ns1__getZipcodeInfo has binding name 'ns1__getZipcodeInfo' for type 'ns1:getZipcodeInfo' */
#ifndef SOAP_TYPE_ns1__getZipcodeInfo
#define SOAP_TYPE_ns1__getZipcodeInfo (287)
#endif

/* struct ns1__getZipcodeInfoResponse has binding name 'ns1__getZipcodeInfoResponse' for type 'ns1:getZipcodeInfoResponse' */
#ifndef SOAP_TYPE_ns1__getZipcodeInfoResponse
#define SOAP_TYPE_ns1__getZipcodeInfoResponse (283)
#endif

/* struct ns1__getMetroAreaInfo has binding name 'ns1__getMetroAreaInfo' for type 'ns1:getMetroAreaInfo' */
#ifndef SOAP_TYPE_ns1__getMetroAreaInfo
#define SOAP_TYPE_ns1__getMetroAreaInfo (282)
#endif

/* struct ns1__getMetroAreaInfoResponse has binding name 'ns1__getMetroAreaInfoResponse' for type 'ns1:getMetroAreaInfoResponse' */
#ifndef SOAP_TYPE_ns1__getMetroAreaInfoResponse
#define SOAP_TYPE_ns1__getMetroAreaInfoResponse (279)
#endif

/* struct ns1__getMetroArea has binding name 'ns1__getMetroArea' for type 'ns1:getMetroArea' */
#ifndef SOAP_TYPE_ns1__getMetroArea
#define SOAP_TYPE_ns1__getMetroArea (278)
#endif

/* struct ns1__getMetroAreaResponse has binding name 'ns1__getMetroAreaResponse' for type 'ns1:getMetroAreaResponse' */
#ifndef SOAP_TYPE_ns1__getMetroAreaResponse
#define SOAP_TYPE_ns1__getMetroAreaResponse (274)
#endif

/* struct ns1__getAgencyFreqsByTag has binding name 'ns1__getAgencyFreqsByTag' for type 'ns1:getAgencyFreqsByTag' */
#ifndef SOAP_TYPE_ns1__getAgencyFreqsByTag
#define SOAP_TYPE_ns1__getAgencyFreqsByTag (273)
#endif

/* struct ns1__getAgencyFreqsByTagResponse has binding name 'ns1__getAgencyFreqsByTagResponse' for type 'ns1:getAgencyFreqsByTagResponse' */
#ifndef SOAP_TYPE_ns1__getAgencyFreqsByTagResponse
#define SOAP_TYPE_ns1__getAgencyFreqsByTagResponse (270)
#endif

/* struct ns1__getCountyFreqsByTag has binding name 'ns1__getCountyFreqsByTag' for type 'ns1:getCountyFreqsByTag' */
#ifndef SOAP_TYPE_ns1__getCountyFreqsByTag
#define SOAP_TYPE_ns1__getCountyFreqsByTag (269)
#endif

/* struct ns1__getCountyFreqsByTagResponse has binding name 'ns1__getCountyFreqsByTagResponse' for type 'ns1:getCountyFreqsByTagResponse' */
#ifndef SOAP_TYPE_ns1__getCountyFreqsByTagResponse
#define SOAP_TYPE_ns1__getCountyFreqsByTagResponse (266)
#endif

/* struct ns1__searchMetroFreq has binding name 'ns1__searchMetroFreq' for type 'ns1:searchMetroFreq' */
#ifndef SOAP_TYPE_ns1__searchMetroFreq
#define SOAP_TYPE_ns1__searchMetroFreq (265)
#endif

/* struct ns1__searchMetroFreqResponse has binding name 'ns1__searchMetroFreqResponse' for type 'ns1:searchMetroFreqResponse' */
#ifndef SOAP_TYPE_ns1__searchMetroFreqResponse
#define SOAP_TYPE_ns1__searchMetroFreqResponse (262)
#endif

/* struct ns1__searchStateFreq has binding name 'ns1__searchStateFreq' for type 'ns1:searchStateFreq' */
#ifndef SOAP_TYPE_ns1__searchStateFreq
#define SOAP_TYPE_ns1__searchStateFreq (261)
#endif

/* struct ns1__searchStateFreqResponse has binding name 'ns1__searchStateFreqResponse' for type 'ns1:searchStateFreqResponse' */
#ifndef SOAP_TYPE_ns1__searchStateFreqResponse
#define SOAP_TYPE_ns1__searchStateFreqResponse (258)
#endif

/* struct ns1__searchCountyFreq has binding name 'ns1__searchCountyFreq' for type 'ns1:searchCountyFreq' */
#ifndef SOAP_TYPE_ns1__searchCountyFreq
#define SOAP_TYPE_ns1__searchCountyFreq (257)
#endif

/* struct ns1__searchCountyFreqResponse has binding name 'ns1__searchCountyFreqResponse' for type 'ns1:searchCountyFreqResponse' */
#ifndef SOAP_TYPE_ns1__searchCountyFreqResponse
#define SOAP_TYPE_ns1__searchCountyFreqResponse (253)
#endif

/* struct ns1__getSubcatFreqs has binding name 'ns1__getSubcatFreqs' for type 'ns1:getSubcatFreqs' */
#ifndef SOAP_TYPE_ns1__getSubcatFreqs
#define SOAP_TYPE_ns1__getSubcatFreqs (252)
#endif

/* struct ns1__getSubcatFreqsResponse has binding name 'ns1__getSubcatFreqsResponse' for type 'ns1:getSubcatFreqsResponse' */
#ifndef SOAP_TYPE_ns1__getSubcatFreqsResponse
#define SOAP_TYPE_ns1__getSubcatFreqsResponse (248)
#endif

/* struct ns1__getAgencyInfo has binding name 'ns1__getAgencyInfo' for type 'ns1:getAgencyInfo' */
#ifndef SOAP_TYPE_ns1__getAgencyInfo
#define SOAP_TYPE_ns1__getAgencyInfo (247)
#endif

/* struct ns1__getAgencyInfoResponse has binding name 'ns1__getAgencyInfoResponse' for type 'ns1:getAgencyInfoResponse' */
#ifndef SOAP_TYPE_ns1__getAgencyInfoResponse
#define SOAP_TYPE_ns1__getAgencyInfoResponse (243)
#endif

/* struct ns1__getCountyInfo has binding name 'ns1__getCountyInfo' for type 'ns1:getCountyInfo' */
#ifndef SOAP_TYPE_ns1__getCountyInfo
#define SOAP_TYPE_ns1__getCountyInfo (242)
#endif

/* struct ns1__getCountyInfoResponse has binding name 'ns1__getCountyInfoResponse' for type 'ns1:getCountyInfoResponse' */
#ifndef SOAP_TYPE_ns1__getCountyInfoResponse
#define SOAP_TYPE_ns1__getCountyInfoResponse (238)
#endif

/* struct ns1__getStateInfo has binding name 'ns1__getStateInfo' for type 'ns1:getStateInfo' */
#ifndef SOAP_TYPE_ns1__getStateInfo
#define SOAP_TYPE_ns1__getStateInfo (237)
#endif

/* struct ns1__getStateInfoResponse has binding name 'ns1__getStateInfoResponse' for type 'ns1:getStateInfoResponse' */
#ifndef SOAP_TYPE_ns1__getStateInfoResponse
#define SOAP_TYPE_ns1__getStateInfoResponse (233)
#endif

/* struct ns1__getCountryInfo has binding name 'ns1__getCountryInfo' for type 'ns1:getCountryInfo' */
#ifndef SOAP_TYPE_ns1__getCountryInfo
#define SOAP_TYPE_ns1__getCountryInfo (232)
#endif

/* struct ns1__getCountryInfoResponse has binding name 'ns1__getCountryInfoResponse' for type 'ns1:getCountryInfoResponse' */
#ifndef SOAP_TYPE_ns1__getCountryInfoResponse
#define SOAP_TYPE_ns1__getCountryInfoResponse (228)
#endif

/* struct ns1__getCountryList has binding name 'ns1__getCountryList' for type 'ns1:getCountryList' */
#ifndef SOAP_TYPE_ns1__getCountryList
#define SOAP_TYPE_ns1__getCountryList (227)
#endif

/* struct ns1__getCountryListResponse has binding name 'ns1__getCountryListResponse' for type 'ns1:getCountryListResponse' */
#ifndef SOAP_TYPE_ns1__getCountryListResponse
#define SOAP_TYPE_ns1__getCountryListResponse (223)
#endif

/* struct ns1__getTrsVoice has binding name 'ns1__getTrsVoice' for type 'ns1:getTrsVoice' */
#ifndef SOAP_TYPE_ns1__getTrsVoice
#define SOAP_TYPE_ns1__getTrsVoice (222)
#endif

/* struct ns1__getTrsVoiceResponse has binding name 'ns1__getTrsVoiceResponse' for type 'ns1:getTrsVoiceResponse' */
#ifndef SOAP_TYPE_ns1__getTrsVoiceResponse
#define SOAP_TYPE_ns1__getTrsVoiceResponse (218)
#endif

/* struct ns1__getTrsFlavor has binding name 'ns1__getTrsFlavor' for type 'ns1:getTrsFlavor' */
#ifndef SOAP_TYPE_ns1__getTrsFlavor
#define SOAP_TYPE_ns1__getTrsFlavor (217)
#endif

/* struct ns1__getTrsFlavorResponse has binding name 'ns1__getTrsFlavorResponse' for type 'ns1:getTrsFlavorResponse' */
#ifndef SOAP_TYPE_ns1__getTrsFlavorResponse
#define SOAP_TYPE_ns1__getTrsFlavorResponse (213)
#endif

/* struct ns1__getTrsType has binding name 'ns1__getTrsType' for type 'ns1:getTrsType' */
#ifndef SOAP_TYPE_ns1__getTrsType
#define SOAP_TYPE_ns1__getTrsType (212)
#endif

/* struct ns1__getTrsTypeResponse has binding name 'ns1__getTrsTypeResponse' for type 'ns1:getTrsTypeResponse' */
#ifndef SOAP_TYPE_ns1__getTrsTypeResponse
#define SOAP_TYPE_ns1__getTrsTypeResponse (208)
#endif

/* struct ns1__getMode has binding name 'ns1__getMode' for type 'ns1:getMode' */
#ifndef SOAP_TYPE_ns1__getMode
#define SOAP_TYPE_ns1__getMode (207)
#endif

/* struct ns1__getModeResponse has binding name 'ns1__getModeResponse' for type 'ns1:getModeResponse' */
#ifndef SOAP_TYPE_ns1__getModeResponse
#define SOAP_TYPE_ns1__getModeResponse (203)
#endif

/* struct ns1__getTag has binding name 'ns1__getTag' for type 'ns1:getTag' */
#ifndef SOAP_TYPE_ns1__getTag
#define SOAP_TYPE_ns1__getTag (202)
#endif

/* struct ns1__getTagResponse has binding name 'ns1__getTagResponse' for type 'ns1:getTagResponse' */
#ifndef SOAP_TYPE_ns1__getTagResponse
#define SOAP_TYPE_ns1__getTagResponse (199)
#endif

/* struct ns1__getCountiesByList has binding name 'ns1__getCountiesByList' for type 'ns1:getCountiesByList' */
#ifndef SOAP_TYPE_ns1__getCountiesByList
#define SOAP_TYPE_ns1__getCountiesByList (198)
#endif

/* struct ns1__getCountiesByListResponse has binding name 'ns1__getCountiesByListResponse' for type 'ns1:getCountiesByListResponse' */
#ifndef SOAP_TYPE_ns1__getCountiesByListResponse
#define SOAP_TYPE_ns1__getCountiesByListResponse (194)
#endif

/* struct ns1__getStatesByList has binding name 'ns1__getStatesByList' for type 'ns1:getStatesByList' */
#ifndef SOAP_TYPE_ns1__getStatesByList
#define SOAP_TYPE_ns1__getStatesByList (193)
#endif

/* struct ns1__getStatesByListResponse has binding name 'ns1__getStatesByListResponse' for type 'ns1:getStatesByListResponse' */
#ifndef SOAP_TYPE_ns1__getStatesByListResponse
#define SOAP_TYPE_ns1__getStatesByListResponse (189)
#endif

/* struct ns1__getTrsSites has binding name 'ns1__getTrsSites' for type 'ns1:getTrsSites' */
#ifndef SOAP_TYPE_ns1__getTrsSites
#define SOAP_TYPE_ns1__getTrsSites (188)
#endif

/* struct ns1__getTrsSitesResponse has binding name 'ns1__getTrsSitesResponse' for type 'ns1:getTrsSitesResponse' */
#ifndef SOAP_TYPE_ns1__getTrsSitesResponse
#define SOAP_TYPE_ns1__getTrsSitesResponse (184)
#endif

/* struct ns1__getTrsBySysid has binding name 'ns1__getTrsBySysid' for type 'ns1:getTrsBySysid' */
#ifndef SOAP_TYPE_ns1__getTrsBySysid
#define SOAP_TYPE_ns1__getTrsBySysid (183)
#endif

/* struct ns1__getTrsBySysidResponse has binding name 'ns1__getTrsBySysidResponse' for type 'ns1:getTrsBySysidResponse' */
#ifndef SOAP_TYPE_ns1__getTrsBySysidResponse
#define SOAP_TYPE_ns1__getTrsBySysidResponse (180)
#endif

/* struct ns1__getTrsDetails has binding name 'ns1__getTrsDetails' for type 'ns1:getTrsDetails' */
#ifndef SOAP_TYPE_ns1__getTrsDetails
#define SOAP_TYPE_ns1__getTrsDetails (179)
#endif

/* struct ns1__getTrsDetailsResponse has binding name 'ns1__getTrsDetailsResponse' for type 'ns1:getTrsDetailsResponse' */
#ifndef SOAP_TYPE_ns1__getTrsDetailsResponse
#define SOAP_TYPE_ns1__getTrsDetailsResponse (175)
#endif

/* struct ns1__getTrsTalkgroupCats has binding name 'ns1__getTrsTalkgroupCats' for type 'ns1:getTrsTalkgroupCats' */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroupCats
#define SOAP_TYPE_ns1__getTrsTalkgroupCats (174)
#endif

/* struct ns1__getTrsTalkgroupCatsResponse has binding name 'ns1__getTrsTalkgroupCatsResponse' for type 'ns1:getTrsTalkgroupCatsResponse' */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse
#define SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse (170)
#endif

/* struct ns1__getTrsTalkgroups has binding name 'ns1__getTrsTalkgroups' for type 'ns1:getTrsTalkgroups' */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroups
#define SOAP_TYPE_ns1__getTrsTalkgroups (169)
#endif

/* struct ns1__getTrsTalkgroupsResponse has binding name 'ns1__getTrsTalkgroupsResponse' for type 'ns1:getTrsTalkgroupsResponse' */
#ifndef SOAP_TYPE_ns1__getTrsTalkgroupsResponse
#define SOAP_TYPE_ns1__getTrsTalkgroupsResponse (164)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (322)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (321)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (315)
#endif

/* userFeedBroadcasts * has binding name 'PointerTouserFeedBroadcasts' for type 'ns1:userFeedBroadcast' */
#ifndef SOAP_TYPE_PointerTouserFeedBroadcasts
#define SOAP_TYPE_PointerTouserFeedBroadcasts (309)
#endif

/* ns1__UserInfo * has binding name 'PointerTons1__UserInfo' for type 'ns1:UserInfo' */
#ifndef SOAP_TYPE_PointerTons1__UserInfo
#define SOAP_TYPE_PointerTons1__UserInfo (304)
#endif

/* proxCallsignResults * has binding name 'PointerToproxCallsignResults' for type 'ns1:proxCallsignResult' */
#ifndef SOAP_TYPE_PointerToproxCallsignResults
#define SOAP_TYPE_PointerToproxCallsignResults (299)
#endif

/* fccRadioServiceCodes * has binding name 'PointerTofccRadioServiceCodes' for type 'ns1:fccRadioServiceCode' */
#ifndef SOAP_TYPE_PointerTofccRadioServiceCodes
#define SOAP_TYPE_PointerTofccRadioServiceCodes (294)
#endif

/* ns1__fccCallsignDetails * has binding name 'PointerTons1__fccCallsignDetails' for type 'ns1:fccCallsignDetails' */
#ifndef SOAP_TYPE_PointerTons1__fccCallsignDetails
#define SOAP_TYPE_PointerTons1__fccCallsignDetails (289)
#endif

/* ns1__ZipInfo * has binding name 'PointerTons1__ZipInfo' for type 'ns1:ZipInfo' */
#ifndef SOAP_TYPE_PointerTons1__ZipInfo
#define SOAP_TYPE_PointerTons1__ZipInfo (284)
#endif

/* Metros * has binding name 'PointerToMetros' for type 'ns1:Metro' */
#ifndef SOAP_TYPE_PointerToMetros
#define SOAP_TYPE_PointerToMetros (275)
#endif

/* searchFreqResults * has binding name 'PointerTosearchFreqResults' for type 'ns1:searchFreqResult' */
#ifndef SOAP_TYPE_PointerTosearchFreqResults
#define SOAP_TYPE_PointerTosearchFreqResults (254)
#endif

/* Freqs * has binding name 'PointerToFreqs' for type 'ns1:freq' */
#ifndef SOAP_TYPE_PointerToFreqs
#define SOAP_TYPE_PointerToFreqs (249)
#endif

/* ns1__AgencyInfo * has binding name 'PointerTons1__AgencyInfo' for type 'ns1:AgencyInfo' */
#ifndef SOAP_TYPE_PointerTons1__AgencyInfo
#define SOAP_TYPE_PointerTons1__AgencyInfo (244)
#endif

/* ns1__CountyInfo * has binding name 'PointerTons1__CountyInfo' for type 'ns1:CountyInfo' */
#ifndef SOAP_TYPE_PointerTons1__CountyInfo
#define SOAP_TYPE_PointerTons1__CountyInfo (239)
#endif

/* ns1__StateInfo * has binding name 'PointerTons1__StateInfo' for type 'ns1:StateInfo' */
#ifndef SOAP_TYPE_PointerTons1__StateInfo
#define SOAP_TYPE_PointerTons1__StateInfo (234)
#endif

/* ns1__CountryInfo * has binding name 'PointerTons1__CountryInfo' for type 'ns1:CountryInfo' */
#ifndef SOAP_TYPE_PointerTons1__CountryInfo
#define SOAP_TYPE_PointerTons1__CountryInfo (229)
#endif

/* Countries * has binding name 'PointerToCountries' for type 'ns1:Country' */
#ifndef SOAP_TYPE_PointerToCountries
#define SOAP_TYPE_PointerToCountries (224)
#endif

/* TrsVoice * has binding name 'PointerToTrsVoice' for type 'ns1:trsVoiceDef' */
#ifndef SOAP_TYPE_PointerToTrsVoice
#define SOAP_TYPE_PointerToTrsVoice (219)
#endif

/* TrsFlavor * has binding name 'PointerToTrsFlavor' for type 'ns1:trsFlavorDef' */
#ifndef SOAP_TYPE_PointerToTrsFlavor
#define SOAP_TYPE_PointerToTrsFlavor (214)
#endif

/* TrsType * has binding name 'PointerToTrsType' for type 'ns1:trsTypeDef' */
#ifndef SOAP_TYPE_PointerToTrsType
#define SOAP_TYPE_PointerToTrsType (209)
#endif

/* modes * has binding name 'PointerTomodes' for type 'ns1:mode' */
#ifndef SOAP_TYPE_PointerTomodes
#define SOAP_TYPE_PointerTomodes (204)
#endif

/* ctidList * has binding name 'PointerToctidList' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_PointerToctidList
#define SOAP_TYPE_PointerToctidList (195)
#endif

/* stidList * has binding name 'PointerTostidList' for type 'ns1:stid' */
#ifndef SOAP_TYPE_PointerTostidList
#define SOAP_TYPE_PointerTostidList (190)
#endif

/* TrsSites * has binding name 'PointerToTrsSites' for type 'ns1:TrsSite' */
#ifndef SOAP_TYPE_PointerToTrsSites
#define SOAP_TYPE_PointerToTrsSites (185)
#endif

/* ns1__Trs * has binding name 'PointerTons1__Trs' for type 'ns1:Trs' */
#ifndef SOAP_TYPE_PointerTons1__Trs
#define SOAP_TYPE_PointerTons1__Trs (176)
#endif

/* TalkgroupCats * has binding name 'PointerToTalkgroupCats' for type 'ns1:TalkgroupCat' */
#ifndef SOAP_TYPE_PointerToTalkgroupCats
#define SOAP_TYPE_PointerToTalkgroupCats (171)
#endif

/* ns1__authInfo * has binding name 'PointerTons1__authInfo' for type 'ns1:authInfo' */
#ifndef SOAP_TYPE_PointerTons1__authInfo
#define SOAP_TYPE_PointerTons1__authInfo (166)
#endif

/* Talkgroups * has binding name 'PointerToTalkgroups' for type 'ns1:Talkgroup' */
#ifndef SOAP_TYPE_PointerToTalkgroups
#define SOAP_TYPE_PointerToTalkgroups (165)
#endif

/* ns1__fccRadioServiceCode ** has binding name 'PointerToPointerTons1__fccRadioServiceCode' for type 'ns1:fccRadioServiceCode' */
#ifndef SOAP_TYPE_PointerToPointerTons1__fccRadioServiceCode
#define SOAP_TYPE_PointerToPointerTons1__fccRadioServiceCode (163)
#endif

/* ns1__fccRadioServiceCode * has binding name 'PointerTons1__fccRadioServiceCode' for type 'ns1:fccRadioServiceCode' */
#ifndef SOAP_TYPE_PointerTons1__fccRadioServiceCode
#define SOAP_TYPE_PointerTons1__fccRadioServiceCode (162)
#endif

/* ns1__proxCallsignResult ** has binding name 'PointerToPointerTons1__proxCallsignResult' for type 'ns1:proxCallsignResult' */
#ifndef SOAP_TYPE_PointerToPointerTons1__proxCallsignResult
#define SOAP_TYPE_PointerToPointerTons1__proxCallsignResult (161)
#endif

/* ns1__proxCallsignResult * has binding name 'PointerTons1__proxCallsignResult' for type 'ns1:proxCallsignResult' */
#ifndef SOAP_TYPE_PointerTons1__proxCallsignResult
#define SOAP_TYPE_PointerTons1__proxCallsignResult (160)
#endif

/* ns1__fccLocation ** has binding name 'PointerToPointerTons1__fccLocation' for type 'ns1:fccLocation' */
#ifndef SOAP_TYPE_PointerToPointerTons1__fccLocation
#define SOAP_TYPE_PointerToPointerTons1__fccLocation (159)
#endif

/* ns1__fccLocation * has binding name 'PointerTons1__fccLocation' for type 'ns1:fccLocation' */
#ifndef SOAP_TYPE_PointerTons1__fccLocation
#define SOAP_TYPE_PointerTons1__fccLocation (158)
#endif

/* ns1__fccFrequency ** has binding name 'PointerToPointerTons1__fccFrequency' for type 'ns1:fccFrequency' */
#ifndef SOAP_TYPE_PointerToPointerTons1__fccFrequency
#define SOAP_TYPE_PointerToPointerTons1__fccFrequency (157)
#endif

/* ns1__fccFrequency * has binding name 'PointerTons1__fccFrequency' for type 'ns1:fccFrequency' */
#ifndef SOAP_TYPE_PointerTons1__fccFrequency
#define SOAP_TYPE_PointerTons1__fccFrequency (156)
#endif

/* ns1__mode ** has binding name 'PointerToPointerTons1__mode' for type 'ns1:mode' */
#ifndef SOAP_TYPE_PointerToPointerTons1__mode
#define SOAP_TYPE_PointerToPointerTons1__mode (155)
#endif

/* ns1__mode * has binding name 'PointerTons1__mode' for type 'ns1:mode' */
#ifndef SOAP_TYPE_PointerTons1__mode
#define SOAP_TYPE_PointerTons1__mode (154)
#endif

/* ns1__tag ** has binding name 'PointerToPointerTons1__tag' for type 'ns1:tag' */
#ifndef SOAP_TYPE_PointerToPointerTons1__tag
#define SOAP_TYPE_PointerToPointerTons1__tag (153)
#endif

/* ns1__tag * has binding name 'PointerTons1__tag' for type 'ns1:tag' */
#ifndef SOAP_TYPE_PointerTons1__tag
#define SOAP_TYPE_PointerTons1__tag (152)
#endif

/* ns1__sid ** has binding name 'PointerToPointerTons1__sid' for type 'ns1:sid' */
#ifndef SOAP_TYPE_PointerToPointerTons1__sid
#define SOAP_TYPE_PointerToPointerTons1__sid (151)
#endif

/* ns1__sid * has binding name 'PointerTons1__sid' for type 'ns1:sid' */
#ifndef SOAP_TYPE_PointerTons1__sid
#define SOAP_TYPE_PointerTons1__sid (150)
#endif

/* ns1__Agency ** has binding name 'PointerToPointerTons1__Agency' for type 'ns1:Agency' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Agency
#define SOAP_TYPE_PointerToPointerTons1__Agency (149)
#endif

/* ns1__Agency * has binding name 'PointerTons1__Agency' for type 'ns1:Agency' */
#ifndef SOAP_TYPE_PointerTons1__Agency
#define SOAP_TYPE_PointerTons1__Agency (148)
#endif

/* ns1__Country ** has binding name 'PointerToPointerTons1__Country' for type 'ns1:Country' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Country
#define SOAP_TYPE_PointerToPointerTons1__Country (147)
#endif

/* ns1__Country * has binding name 'PointerTons1__Country' for type 'ns1:Country' */
#ifndef SOAP_TYPE_PointerTons1__Country
#define SOAP_TYPE_PointerTons1__Country (146)
#endif

/* ns1__Metro ** has binding name 'PointerToPointerTons1__Metro' for type 'ns1:Metro' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Metro
#define SOAP_TYPE_PointerToPointerTons1__Metro (145)
#endif

/* ns1__Metro * has binding name 'PointerTons1__Metro' for type 'ns1:Metro' */
#ifndef SOAP_TYPE_PointerTons1__Metro
#define SOAP_TYPE_PointerTons1__Metro (144)
#endif

/* ns1__State ** has binding name 'PointerToPointerTons1__State' for type 'ns1:State' */
#ifndef SOAP_TYPE_PointerToPointerTons1__State
#define SOAP_TYPE_PointerToPointerTons1__State (143)
#endif

/* ns1__State * has binding name 'PointerTons1__State' for type 'ns1:State' */
#ifndef SOAP_TYPE_PointerTons1__State
#define SOAP_TYPE_PointerTons1__State (142)
#endif

/* ns1__County ** has binding name 'PointerToPointerTons1__County' for type 'ns1:County' */
#ifndef SOAP_TYPE_PointerToPointerTons1__County
#define SOAP_TYPE_PointerToPointerTons1__County (141)
#endif

/* ns1__County * has binding name 'PointerTons1__County' for type 'ns1:County' */
#ifndef SOAP_TYPE_PointerTons1__County
#define SOAP_TYPE_PointerTons1__County (140)
#endif

/* ns1__subcat ** has binding name 'PointerToPointerTons1__subcat' for type 'ns1:subcat' */
#ifndef SOAP_TYPE_PointerToPointerTons1__subcat
#define SOAP_TYPE_PointerToPointerTons1__subcat (139)
#endif

/* ns1__subcat * has binding name 'PointerTons1__subcat' for type 'ns1:subcat' */
#ifndef SOAP_TYPE_PointerTons1__subcat
#define SOAP_TYPE_PointerTons1__subcat (138)
#endif

/* ns1__cat ** has binding name 'PointerToPointerTons1__cat' for type 'ns1:cat' */
#ifndef SOAP_TYPE_PointerToPointerTons1__cat
#define SOAP_TYPE_PointerToPointerTons1__cat (137)
#endif

/* ns1__cat * has binding name 'PointerTons1__cat' for type 'ns1:cat' */
#ifndef SOAP_TYPE_PointerTons1__cat
#define SOAP_TYPE_PointerTons1__cat (136)
#endif

/* ns1__freq ** has binding name 'PointerToPointerTons1__freq' for type 'ns1:freq' */
#ifndef SOAP_TYPE_PointerToPointerTons1__freq
#define SOAP_TYPE_PointerToPointerTons1__freq (135)
#endif

/* ns1__freq * has binding name 'PointerTons1__freq' for type 'ns1:freq' */
#ifndef SOAP_TYPE_PointerTons1__freq
#define SOAP_TYPE_PointerTons1__freq (134)
#endif

/* ns1__searchFreqResult ** has binding name 'PointerToPointerTons1__searchFreqResult' for type 'ns1:searchFreqResult' */
#ifndef SOAP_TYPE_PointerToPointerTons1__searchFreqResult
#define SOAP_TYPE_PointerToPointerTons1__searchFreqResult (133)
#endif

/* ns1__searchFreqResult * has binding name 'PointerTons1__searchFreqResult' for type 'ns1:searchFreqResult' */
#ifndef SOAP_TYPE_PointerTons1__searchFreqResult
#define SOAP_TYPE_PointerTons1__searchFreqResult (132)
#endif

/* ns1__trsVoiceDef ** has binding name 'PointerToPointerTons1__trsVoiceDef' for type 'ns1:trsVoiceDef' */
#ifndef SOAP_TYPE_PointerToPointerTons1__trsVoiceDef
#define SOAP_TYPE_PointerToPointerTons1__trsVoiceDef (131)
#endif

/* ns1__trsVoiceDef * has binding name 'PointerTons1__trsVoiceDef' for type 'ns1:trsVoiceDef' */
#ifndef SOAP_TYPE_PointerTons1__trsVoiceDef
#define SOAP_TYPE_PointerTons1__trsVoiceDef (130)
#endif

/* ns1__trsFlavorDef ** has binding name 'PointerToPointerTons1__trsFlavorDef' for type 'ns1:trsFlavorDef' */
#ifndef SOAP_TYPE_PointerToPointerTons1__trsFlavorDef
#define SOAP_TYPE_PointerToPointerTons1__trsFlavorDef (129)
#endif

/* ns1__trsFlavorDef * has binding name 'PointerTons1__trsFlavorDef' for type 'ns1:trsFlavorDef' */
#ifndef SOAP_TYPE_PointerTons1__trsFlavorDef
#define SOAP_TYPE_PointerTons1__trsFlavorDef (128)
#endif

/* ns1__trsTypeDef ** has binding name 'PointerToPointerTons1__trsTypeDef' for type 'ns1:trsTypeDef' */
#ifndef SOAP_TYPE_PointerToPointerTons1__trsTypeDef
#define SOAP_TYPE_PointerToPointerTons1__trsTypeDef (127)
#endif

/* ns1__trsTypeDef * has binding name 'PointerTons1__trsTypeDef' for type 'ns1:trsTypeDef' */
#ifndef SOAP_TYPE_PointerTons1__trsTypeDef
#define SOAP_TYPE_PointerTons1__trsTypeDef (126)
#endif

/* ns1__trsBandplanDef ** has binding name 'PointerToPointerTons1__trsBandplanDef' for type 'ns1:trsBandplanDef' */
#ifndef SOAP_TYPE_PointerToPointerTons1__trsBandplanDef
#define SOAP_TYPE_PointerToPointerTons1__trsBandplanDef (125)
#endif

/* ns1__trsBandplanDef * has binding name 'PointerTons1__trsBandplanDef' for type 'ns1:trsBandplanDef' */
#ifndef SOAP_TYPE_PointerTons1__trsBandplanDef
#define SOAP_TYPE_PointerTons1__trsBandplanDef (124)
#endif

/* ns1__trsSysidDef ** has binding name 'PointerToPointerTons1__trsSysidDef' for type 'ns1:trsSysidDef' */
#ifndef SOAP_TYPE_PointerToPointerTons1__trsSysidDef
#define SOAP_TYPE_PointerToPointerTons1__trsSysidDef (123)
#endif

/* ns1__trsSysidDef * has binding name 'PointerTons1__trsSysidDef' for type 'ns1:trsSysidDef' */
#ifndef SOAP_TYPE_PointerTons1__trsSysidDef
#define SOAP_TYPE_PointerTons1__trsSysidDef (122)
#endif

/* ns1__TrsListDef ** has binding name 'PointerToPointerTons1__TrsListDef' for type 'ns1:TrsListDef' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TrsListDef
#define SOAP_TYPE_PointerToPointerTons1__TrsListDef (121)
#endif

/* ns1__TrsListDef * has binding name 'PointerTons1__TrsListDef' for type 'ns1:TrsListDef' */
#ifndef SOAP_TYPE_PointerTons1__TrsListDef
#define SOAP_TYPE_PointerTons1__TrsListDef (120)
#endif

/* ns1__TrsSiteLicense ** has binding name 'PointerToPointerTons1__TrsSiteLicense' for type 'ns1:TrsSiteLicense' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TrsSiteLicense
#define SOAP_TYPE_PointerToPointerTons1__TrsSiteLicense (119)
#endif

/* ns1__TrsSiteLicense * has binding name 'PointerTons1__TrsSiteLicense' for type 'ns1:TrsSiteLicense' */
#ifndef SOAP_TYPE_PointerTons1__TrsSiteLicense
#define SOAP_TYPE_PointerTons1__TrsSiteLicense (118)
#endif

/* ns1__TrsSiteFreq ** has binding name 'PointerToPointerTons1__TrsSiteFreq' for type 'ns1:TrsSiteFreq' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TrsSiteFreq
#define SOAP_TYPE_PointerToPointerTons1__TrsSiteFreq (117)
#endif

/* ns1__TrsSiteFreq * has binding name 'PointerTons1__TrsSiteFreq' for type 'ns1:TrsSiteFreq' */
#ifndef SOAP_TYPE_PointerTons1__TrsSiteFreq
#define SOAP_TYPE_PointerTons1__TrsSiteFreq (116)
#endif

/* ns1__TrsSite ** has binding name 'PointerToPointerTons1__TrsSite' for type 'ns1:TrsSite' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TrsSite
#define SOAP_TYPE_PointerToPointerTons1__TrsSite (115)
#endif

/* ns1__TrsSite * has binding name 'PointerTons1__TrsSite' for type 'ns1:TrsSite' */
#ifndef SOAP_TYPE_PointerTons1__TrsSite
#define SOAP_TYPE_PointerTons1__TrsSite (114)
#endif

/* ns1__TalkgroupCat ** has binding name 'PointerToPointerTons1__TalkgroupCat' for type 'ns1:TalkgroupCat' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TalkgroupCat
#define SOAP_TYPE_PointerToPointerTons1__TalkgroupCat (113)
#endif

/* ns1__TalkgroupCat * has binding name 'PointerTons1__TalkgroupCat' for type 'ns1:TalkgroupCat' */
#ifndef SOAP_TYPE_PointerTons1__TalkgroupCat
#define SOAP_TYPE_PointerTons1__TalkgroupCat (112)
#endif

/* ns1__Talkgroup ** has binding name 'PointerToPointerTons1__Talkgroup' for type 'ns1:Talkgroup' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Talkgroup
#define SOAP_TYPE_PointerToPointerTons1__Talkgroup (111)
#endif

/* ns1__Talkgroup * has binding name 'PointerTons1__Talkgroup' for type 'ns1:Talkgroup' */
#ifndef SOAP_TYPE_PointerTons1__Talkgroup
#define SOAP_TYPE_PointerTons1__Talkgroup (110)
#endif

/* ns1__ctid ** has binding name 'PointerToPointerTons1__ctid' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_PointerToPointerTons1__ctid
#define SOAP_TYPE_PointerToPointerTons1__ctid (109)
#endif

/* ns1__ctid * has binding name 'PointerTons1__ctid' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_PointerTons1__ctid
#define SOAP_TYPE_PointerTons1__ctid (108)
#endif

/* ns1__stid ** has binding name 'PointerToPointerTons1__stid' for type 'ns1:stid' */
#ifndef SOAP_TYPE_PointerToPointerTons1__stid
#define SOAP_TYPE_PointerToPointerTons1__stid (107)
#endif

/* ns1__stid * has binding name 'PointerTons1__stid' for type 'ns1:stid' */
#ifndef SOAP_TYPE_PointerTons1__stid
#define SOAP_TYPE_PointerTons1__stid (106)
#endif

/* ns1__userFeedBroadcast ** has binding name 'PointerToPointerTons1__userFeedBroadcast' for type 'ns1:userFeedBroadcast' */
#ifndef SOAP_TYPE_PointerToPointerTons1__userFeedBroadcast
#define SOAP_TYPE_PointerToPointerTons1__userFeedBroadcast (105)
#endif

/* ns1__userFeedBroadcast * has binding name 'PointerTons1__userFeedBroadcast' for type 'ns1:userFeedBroadcast' */
#ifndef SOAP_TYPE_PointerTons1__userFeedBroadcast
#define SOAP_TYPE_PointerTons1__userFeedBroadcast (104)
#endif

/* fccFrequencies * has binding name 'PointerTofccFrequencies' for type 'ns1:fccFrequency' */
#ifndef SOAP_TYPE_PointerTofccFrequencies
#define SOAP_TYPE_PointerTofccFrequencies (103)
#endif

/* fccLocations * has binding name 'PointerTofccLocations' for type 'ns1:fccLocation' */
#ifndef SOAP_TYPE_PointerTofccLocations
#define SOAP_TYPE_PointerTofccLocations (102)
#endif

/* Counties * has binding name 'PointerToCounties' for type 'ns1:County' */
#ifndef SOAP_TYPE_PointerToCounties
#define SOAP_TYPE_PointerToCounties (101)
#endif

/* TrsList * has binding name 'PointerToTrsList' for type 'ns1:TrsListDef' */
#ifndef SOAP_TYPE_PointerToTrsList
#define SOAP_TYPE_PointerToTrsList (100)
#endif

/* States * has binding name 'PointerToStates' for type 'ns1:State' */
#ifndef SOAP_TYPE_PointerToStates
#define SOAP_TYPE_PointerToStates (99)
#endif

/* Agencies * has binding name 'PointerToAgencies' for type 'ns1:Agency' */
#ifndef SOAP_TYPE_PointerToAgencies
#define SOAP_TYPE_PointerToAgencies (98)
#endif

/* Cats * has binding name 'PointerToCats' for type 'ns1:cat' */
#ifndef SOAP_TYPE_PointerToCats
#define SOAP_TYPE_PointerToCats (97)
#endif

/* sids * has binding name 'PointerTosids' for type 'ns1:sid' */
#ifndef SOAP_TYPE_PointerTosids
#define SOAP_TYPE_PointerTosids (96)
#endif

/* SubCats * has binding name 'PointerToSubCats' for type 'ns1:subcat' */
#ifndef SOAP_TYPE_PointerToSubCats
#define SOAP_TYPE_PointerToSubCats (95)
#endif

/* ns1__TrsFleetmap * has binding name 'PointerTons1__TrsFleetmap' for type 'ns1:TrsFleetmap' */
#ifndef SOAP_TYPE_PointerTons1__TrsFleetmap
#define SOAP_TYPE_PointerTons1__TrsFleetmap (94)
#endif

/* TrsSysid * has binding name 'PointerToTrsSysid' for type 'ns1:trsSysidDef' */
#ifndef SOAP_TYPE_PointerToTrsSysid
#define SOAP_TYPE_PointerToTrsSysid (93)
#endif

/* stids * has binding name 'PointerTostids' for type 'ns1:stid' */
#ifndef SOAP_TYPE_PointerTostids
#define SOAP_TYPE_PointerTostids (92)
#endif

/* ctids * has binding name 'PointerToctids' for type 'ns1:ctid' */
#ifndef SOAP_TYPE_PointerToctids
#define SOAP_TYPE_PointerToctids (91)
#endif

/* TrsBandplan * has binding name 'PointerToTrsBandplan' for type 'ns1:trsBandplanDef' */
#ifndef SOAP_TYPE_PointerToTrsBandplan
#define SOAP_TYPE_PointerToTrsBandplan (90)
#endif

/* TrsSiteFreqs * has binding name 'PointerToTrsSiteFreqs' for type 'ns1:TrsSiteFreq' */
#ifndef SOAP_TYPE_PointerToTrsSiteFreqs
#define SOAP_TYPE_PointerToTrsSiteFreqs (89)
#endif

/* TrsSiteLicenses * has binding name 'PointerToTrsSiteLicenses' for type 'ns1:TrsSiteLicense' */
#ifndef SOAP_TYPE_PointerToTrsSiteLicenses
#define SOAP_TYPE_PointerToTrsSiteLicenses (88)
#endif

/* tags * has binding name 'PointerTotags' for type 'ns1:tag' */
#ifndef SOAP_TYPE_PointerTotags
#define SOAP_TYPE_PointerTotags (86)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (9)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of rrapi_Stub.h */
