/* rrapi_C.cpp
   Generated by gSOAP 2.8.109 for api.radioreference.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "rrapi_H.h"

SOAP_SOURCE_STAMP("@(#) rrapi_C.cpp ver 2.8.109 2020-12-15 04:43:32 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_fccRadioServiceCodes:
		return soap_in_fccRadioServiceCodes(soap, tag, NULL, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_ns1__fccRadioServiceCode:
		return soap_in_ns1__fccRadioServiceCode(soap, tag, NULL, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_proxCallsignResults:
		return soap_in_proxCallsignResults(soap, tag, NULL, "ns1:proxCallsignResult");
	case SOAP_TYPE_ns1__proxCallsignResult:
		return soap_in_ns1__proxCallsignResult(soap, tag, NULL, "ns1:proxCallsignResult");
	case SOAP_TYPE_fccLocations:
		return soap_in_fccLocations(soap, tag, NULL, "ns1:fccLocation");
	case SOAP_TYPE_ns1__fccLocation:
		return soap_in_ns1__fccLocation(soap, tag, NULL, "ns1:fccLocation");
	case SOAP_TYPE_fccFrequencies:
		return soap_in_fccFrequencies(soap, tag, NULL, "ns1:fccFrequency");
	case SOAP_TYPE_ns1__fccFrequency:
		return soap_in_ns1__fccFrequency(soap, tag, NULL, "ns1:fccFrequency");
	case SOAP_TYPE_ns1__fccCallsignDetails:
		return soap_in_ns1__fccCallsignDetails(soap, tag, NULL, "ns1:fccCallsignDetails");
	case SOAP_TYPE_ns1__UserInfo:
		return soap_in_ns1__UserInfo(soap, tag, NULL, "ns1:UserInfo");
	case SOAP_TYPE_ns1__ZipInfo:
		return soap_in_ns1__ZipInfo(soap, tag, NULL, "ns1:ZipInfo");
	case SOAP_TYPE_ns1__mode:
		return soap_in_ns1__mode(soap, tag, NULL, "ns1:mode");
	case SOAP_TYPE_modes:
		return soap_in_modes(soap, tag, NULL, "ns1:mode");
	case SOAP_TYPE_ns1__tag:
		return soap_in_ns1__tag(soap, tag, NULL, "ns1:tag");
	case SOAP_TYPE_tags:
		return soap_in_tags(soap, tag, NULL, "ns1:tag");
	case SOAP_TYPE_ns1__sid:
		return soap_in_ns1__sid(soap, tag, NULL, "ns1:sid");
	case SOAP_TYPE_sids:
		return soap_in_sids(soap, tag, NULL, "ns1:sid");
	case SOAP_TYPE_ns1__stid:
		return soap_in_ns1__stid(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_stids:
		return soap_in_stids(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_ns1__Agency:
		return soap_in_ns1__Agency(soap, tag, NULL, "ns1:Agency");
	case SOAP_TYPE_Agencies:
		return soap_in_Agencies(soap, tag, NULL, "ns1:Agency");
	case SOAP_TYPE_ns1__Country:
		return soap_in_ns1__Country(soap, tag, NULL, "ns1:Country");
	case SOAP_TYPE_Countries:
		return soap_in_Countries(soap, tag, NULL, "ns1:Country");
	case SOAP_TYPE_ns1__Metro:
		return soap_in_ns1__Metro(soap, tag, NULL, "ns1:Metro");
	case SOAP_TYPE_Metros:
		return soap_in_Metros(soap, tag, NULL, "ns1:Metro");
	case SOAP_TYPE_ns1__State:
		return soap_in_ns1__State(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_States:
		return soap_in_States(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_ns1__ctid:
		return soap_in_ns1__ctid(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_ctids:
		return soap_in_ctids(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_Counties:
		return soap_in_Counties(soap, tag, NULL, "ns1:County");
	case SOAP_TYPE_ns1__County:
		return soap_in_ns1__County(soap, tag, NULL, "ns1:County");
	case SOAP_TYPE_ns1__StateInfo:
		return soap_in_ns1__StateInfo(soap, tag, NULL, "ns1:StateInfo");
	case SOAP_TYPE_ns1__CountyInfo:
		return soap_in_ns1__CountyInfo(soap, tag, NULL, "ns1:CountyInfo");
	case SOAP_TYPE_ns1__CountryInfo:
		return soap_in_ns1__CountryInfo(soap, tag, NULL, "ns1:CountryInfo");
	case SOAP_TYPE_ns1__AgencyInfo:
		return soap_in_ns1__AgencyInfo(soap, tag, NULL, "ns1:AgencyInfo");
	case SOAP_TYPE_ns1__subcat:
		return soap_in_ns1__subcat(soap, tag, NULL, "ns1:subcat");
	case SOAP_TYPE_SubCats:
		return soap_in_SubCats(soap, tag, NULL, "ns1:subcat");
	case SOAP_TYPE_ns1__cat:
		return soap_in_ns1__cat(soap, tag, NULL, "ns1:cat");
	case SOAP_TYPE_Cats:
		return soap_in_Cats(soap, tag, NULL, "ns1:cat");
	case SOAP_TYPE_Freqs:
		return soap_in_Freqs(soap, tag, NULL, "ns1:freq");
	case SOAP_TYPE_searchFreqResults:
		return soap_in_searchFreqResults(soap, tag, NULL, "ns1:searchFreqResult");
	case SOAP_TYPE_ns1__searchFreqResult:
		return soap_in_ns1__searchFreqResult(soap, tag, NULL, "ns1:searchFreqResult");
	case SOAP_TYPE_ns1__freq:
		return soap_in_ns1__freq(soap, tag, NULL, "ns1:freq");
	case SOAP_TYPE_TrsVoice:
		return soap_in_TrsVoice(soap, tag, NULL, "ns1:trsVoiceDef");
	case SOAP_TYPE_ns1__trsVoiceDef:
		return soap_in_ns1__trsVoiceDef(soap, tag, NULL, "ns1:trsVoiceDef");
	case SOAP_TYPE_TrsFlavor:
		return soap_in_TrsFlavor(soap, tag, NULL, "ns1:trsFlavorDef");
	case SOAP_TYPE_ns1__trsFlavorDef:
		return soap_in_ns1__trsFlavorDef(soap, tag, NULL, "ns1:trsFlavorDef");
	case SOAP_TYPE_TrsType:
		return soap_in_TrsType(soap, tag, NULL, "ns1:trsTypeDef");
	case SOAP_TYPE_ns1__trsTypeDef:
		return soap_in_ns1__trsTypeDef(soap, tag, NULL, "ns1:trsTypeDef");
	case SOAP_TYPE_ns1__TrsFleetmap:
		return soap_in_ns1__TrsFleetmap(soap, tag, NULL, "ns1:TrsFleetmap");
	case SOAP_TYPE_TrsBandplan:
		return soap_in_TrsBandplan(soap, tag, NULL, "ns1:trsBandplanDef");
	case SOAP_TYPE_ns1__trsBandplanDef:
		return soap_in_ns1__trsBandplanDef(soap, tag, NULL, "ns1:trsBandplanDef");
	case SOAP_TYPE_TrsSysid:
		return soap_in_TrsSysid(soap, tag, NULL, "ns1:trsSysidDef");
	case SOAP_TYPE_ns1__trsSysidDef:
		return soap_in_ns1__trsSysidDef(soap, tag, NULL, "ns1:trsSysidDef");
	case SOAP_TYPE_TrsList:
		return soap_in_TrsList(soap, tag, NULL, "ns1:TrsListDef");
	case SOAP_TYPE_ns1__TrsListDef:
		return soap_in_ns1__TrsListDef(soap, tag, NULL, "ns1:TrsListDef");
	case SOAP_TYPE_ns1__Trs:
		return soap_in_ns1__Trs(soap, tag, NULL, "ns1:Trs");
	case SOAP_TYPE_TrsSiteLicenses:
		return soap_in_TrsSiteLicenses(soap, tag, NULL, "ns1:TrsSiteLicense");
	case SOAP_TYPE_ns1__TrsSiteLicense:
		return soap_in_ns1__TrsSiteLicense(soap, tag, NULL, "ns1:TrsSiteLicense");
	case SOAP_TYPE_TrsSiteFreqs:
		return soap_in_TrsSiteFreqs(soap, tag, NULL, "ns1:TrsSiteFreq");
	case SOAP_TYPE_ns1__TrsSiteFreq:
		return soap_in_ns1__TrsSiteFreq(soap, tag, NULL, "ns1:TrsSiteFreq");
	case SOAP_TYPE_TrsSites:
		return soap_in_TrsSites(soap, tag, NULL, "ns1:TrsSite");
	case SOAP_TYPE_ns1__TrsSite:
		return soap_in_ns1__TrsSite(soap, tag, NULL, "ns1:TrsSite");
	case SOAP_TYPE_TalkgroupCats:
		return soap_in_TalkgroupCats(soap, tag, NULL, "ns1:TalkgroupCat");
	case SOAP_TYPE_ns1__TalkgroupCat:
		return soap_in_ns1__TalkgroupCat(soap, tag, NULL, "ns1:TalkgroupCat");
	case SOAP_TYPE_Talkgroups:
		return soap_in_Talkgroups(soap, tag, NULL, "ns1:Talkgroup");
	case SOAP_TYPE_ns1__Talkgroup:
		return soap_in_ns1__Talkgroup(soap, tag, NULL, "ns1:Talkgroup");
	case SOAP_TYPE_ctidList:
		return soap_in_ctidList(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_stidList:
		return soap_in_stidList(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_userFeedBroadcasts:
		return soap_in_userFeedBroadcasts(soap, tag, NULL, "ns1:userFeedBroadcast");
	case SOAP_TYPE_ns1__userFeedBroadcast:
		return soap_in_ns1__userFeedBroadcast(soap, tag, NULL, "ns1:userFeedBroadcast");
	case SOAP_TYPE_ns1__authInfo:
		return soap_in_ns1__authInfo(soap, tag, NULL, "ns1:authInfo");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_SOAP_ENC__Array:
		return soap_in_SOAP_ENC__Array(soap, tag, NULL, "SOAP-ENC:Array");
	case SOAP_TYPE_ns1__getUserFeedBroadcasts:
		return soap_in_ns1__getUserFeedBroadcasts(soap, tag, NULL, "ns1:getUserFeedBroadcasts");
	case SOAP_TYPE_ns1__getUserFeedBroadcastsResponse:
		return soap_in_ns1__getUserFeedBroadcastsResponse(soap, tag, NULL, "ns1:getUserFeedBroadcastsResponse");
	case SOAP_TYPE_ns1__getUserData:
		return soap_in_ns1__getUserData(soap, tag, NULL, "ns1:getUserData");
	case SOAP_TYPE_ns1__getUserDataResponse:
		return soap_in_ns1__getUserDataResponse(soap, tag, NULL, "ns1:getUserDataResponse");
	case SOAP_TYPE_ns1__fccGetProxCallsigns:
		return soap_in_ns1__fccGetProxCallsigns(soap, tag, NULL, "ns1:fccGetProxCallsigns");
	case SOAP_TYPE_ns1__fccGetProxCallsignsResponse:
		return soap_in_ns1__fccGetProxCallsignsResponse(soap, tag, NULL, "ns1:fccGetProxCallsignsResponse");
	case SOAP_TYPE_ns1__fccGetRadioServiceCode:
		return soap_in_ns1__fccGetRadioServiceCode(soap, tag, NULL, "ns1:fccGetRadioServiceCode");
	case SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse:
		return soap_in_ns1__fccGetRadioServiceCodeResponse(soap, tag, NULL, "ns1:fccGetRadioServiceCodeResponse");
	case SOAP_TYPE_ns1__fccGetCallsign:
		return soap_in_ns1__fccGetCallsign(soap, tag, NULL, "ns1:fccGetCallsign");
	case SOAP_TYPE_ns1__fccGetCallsignResponse:
		return soap_in_ns1__fccGetCallsignResponse(soap, tag, NULL, "ns1:fccGetCallsignResponse");
	case SOAP_TYPE_ns1__getZipcodeInfo:
		return soap_in_ns1__getZipcodeInfo(soap, tag, NULL, "ns1:getZipcodeInfo");
	case SOAP_TYPE_ns1__getZipcodeInfoResponse:
		return soap_in_ns1__getZipcodeInfoResponse(soap, tag, NULL, "ns1:getZipcodeInfoResponse");
	case SOAP_TYPE_ns1__getMetroAreaInfo:
		return soap_in_ns1__getMetroAreaInfo(soap, tag, NULL, "ns1:getMetroAreaInfo");
	case SOAP_TYPE_ns1__getMetroAreaInfoResponse:
		return soap_in_ns1__getMetroAreaInfoResponse(soap, tag, NULL, "ns1:getMetroAreaInfoResponse");
	case SOAP_TYPE_ns1__getMetroArea:
		return soap_in_ns1__getMetroArea(soap, tag, NULL, "ns1:getMetroArea");
	case SOAP_TYPE_ns1__getMetroAreaResponse:
		return soap_in_ns1__getMetroAreaResponse(soap, tag, NULL, "ns1:getMetroAreaResponse");
	case SOAP_TYPE_ns1__getAgencyFreqsByTag:
		return soap_in_ns1__getAgencyFreqsByTag(soap, tag, NULL, "ns1:getAgencyFreqsByTag");
	case SOAP_TYPE_ns1__getAgencyFreqsByTagResponse:
		return soap_in_ns1__getAgencyFreqsByTagResponse(soap, tag, NULL, "ns1:getAgencyFreqsByTagResponse");
	case SOAP_TYPE_ns1__getCountyFreqsByTag:
		return soap_in_ns1__getCountyFreqsByTag(soap, tag, NULL, "ns1:getCountyFreqsByTag");
	case SOAP_TYPE_ns1__getCountyFreqsByTagResponse:
		return soap_in_ns1__getCountyFreqsByTagResponse(soap, tag, NULL, "ns1:getCountyFreqsByTagResponse");
	case SOAP_TYPE_ns1__searchMetroFreq:
		return soap_in_ns1__searchMetroFreq(soap, tag, NULL, "ns1:searchMetroFreq");
	case SOAP_TYPE_ns1__searchMetroFreqResponse:
		return soap_in_ns1__searchMetroFreqResponse(soap, tag, NULL, "ns1:searchMetroFreqResponse");
	case SOAP_TYPE_ns1__searchStateFreq:
		return soap_in_ns1__searchStateFreq(soap, tag, NULL, "ns1:searchStateFreq");
	case SOAP_TYPE_ns1__searchStateFreqResponse:
		return soap_in_ns1__searchStateFreqResponse(soap, tag, NULL, "ns1:searchStateFreqResponse");
	case SOAP_TYPE_ns1__searchCountyFreq:
		return soap_in_ns1__searchCountyFreq(soap, tag, NULL, "ns1:searchCountyFreq");
	case SOAP_TYPE_ns1__searchCountyFreqResponse:
		return soap_in_ns1__searchCountyFreqResponse(soap, tag, NULL, "ns1:searchCountyFreqResponse");
	case SOAP_TYPE_ns1__getSubcatFreqs:
		return soap_in_ns1__getSubcatFreqs(soap, tag, NULL, "ns1:getSubcatFreqs");
	case SOAP_TYPE_ns1__getSubcatFreqsResponse:
		return soap_in_ns1__getSubcatFreqsResponse(soap, tag, NULL, "ns1:getSubcatFreqsResponse");
	case SOAP_TYPE_ns1__getAgencyInfo:
		return soap_in_ns1__getAgencyInfo(soap, tag, NULL, "ns1:getAgencyInfo");
	case SOAP_TYPE_ns1__getAgencyInfoResponse:
		return soap_in_ns1__getAgencyInfoResponse(soap, tag, NULL, "ns1:getAgencyInfoResponse");
	case SOAP_TYPE_ns1__getCountyInfo:
		return soap_in_ns1__getCountyInfo(soap, tag, NULL, "ns1:getCountyInfo");
	case SOAP_TYPE_ns1__getCountyInfoResponse:
		return soap_in_ns1__getCountyInfoResponse(soap, tag, NULL, "ns1:getCountyInfoResponse");
	case SOAP_TYPE_ns1__getStateInfo:
		return soap_in_ns1__getStateInfo(soap, tag, NULL, "ns1:getStateInfo");
	case SOAP_TYPE_ns1__getStateInfoResponse:
		return soap_in_ns1__getStateInfoResponse(soap, tag, NULL, "ns1:getStateInfoResponse");
	case SOAP_TYPE_ns1__getCountryInfo:
		return soap_in_ns1__getCountryInfo(soap, tag, NULL, "ns1:getCountryInfo");
	case SOAP_TYPE_ns1__getCountryInfoResponse:
		return soap_in_ns1__getCountryInfoResponse(soap, tag, NULL, "ns1:getCountryInfoResponse");
	case SOAP_TYPE_ns1__getCountryList:
		return soap_in_ns1__getCountryList(soap, tag, NULL, "ns1:getCountryList");
	case SOAP_TYPE_ns1__getCountryListResponse:
		return soap_in_ns1__getCountryListResponse(soap, tag, NULL, "ns1:getCountryListResponse");
	case SOAP_TYPE_ns1__getTrsVoice:
		return soap_in_ns1__getTrsVoice(soap, tag, NULL, "ns1:getTrsVoice");
	case SOAP_TYPE_ns1__getTrsVoiceResponse:
		return soap_in_ns1__getTrsVoiceResponse(soap, tag, NULL, "ns1:getTrsVoiceResponse");
	case SOAP_TYPE_ns1__getTrsFlavor:
		return soap_in_ns1__getTrsFlavor(soap, tag, NULL, "ns1:getTrsFlavor");
	case SOAP_TYPE_ns1__getTrsFlavorResponse:
		return soap_in_ns1__getTrsFlavorResponse(soap, tag, NULL, "ns1:getTrsFlavorResponse");
	case SOAP_TYPE_ns1__getTrsType:
		return soap_in_ns1__getTrsType(soap, tag, NULL, "ns1:getTrsType");
	case SOAP_TYPE_ns1__getTrsTypeResponse:
		return soap_in_ns1__getTrsTypeResponse(soap, tag, NULL, "ns1:getTrsTypeResponse");
	case SOAP_TYPE_ns1__getMode:
		return soap_in_ns1__getMode(soap, tag, NULL, "ns1:getMode");
	case SOAP_TYPE_ns1__getModeResponse:
		return soap_in_ns1__getModeResponse(soap, tag, NULL, "ns1:getModeResponse");
	case SOAP_TYPE_ns1__getTag:
		return soap_in_ns1__getTag(soap, tag, NULL, "ns1:getTag");
	case SOAP_TYPE_ns1__getTagResponse:
		return soap_in_ns1__getTagResponse(soap, tag, NULL, "ns1:getTagResponse");
	case SOAP_TYPE_ns1__getCountiesByList:
		return soap_in_ns1__getCountiesByList(soap, tag, NULL, "ns1:getCountiesByList");
	case SOAP_TYPE_ns1__getCountiesByListResponse:
		return soap_in_ns1__getCountiesByListResponse(soap, tag, NULL, "ns1:getCountiesByListResponse");
	case SOAP_TYPE_ns1__getStatesByList:
		return soap_in_ns1__getStatesByList(soap, tag, NULL, "ns1:getStatesByList");
	case SOAP_TYPE_ns1__getStatesByListResponse:
		return soap_in_ns1__getStatesByListResponse(soap, tag, NULL, "ns1:getStatesByListResponse");
	case SOAP_TYPE_ns1__getTrsSites:
		return soap_in_ns1__getTrsSites(soap, tag, NULL, "ns1:getTrsSites");
	case SOAP_TYPE_ns1__getTrsSitesResponse:
		return soap_in_ns1__getTrsSitesResponse(soap, tag, NULL, "ns1:getTrsSitesResponse");
	case SOAP_TYPE_ns1__getTrsBySysid:
		return soap_in_ns1__getTrsBySysid(soap, tag, NULL, "ns1:getTrsBySysid");
	case SOAP_TYPE_ns1__getTrsBySysidResponse:
		return soap_in_ns1__getTrsBySysidResponse(soap, tag, NULL, "ns1:getTrsBySysidResponse");
	case SOAP_TYPE_ns1__getTrsDetails:
		return soap_in_ns1__getTrsDetails(soap, tag, NULL, "ns1:getTrsDetails");
	case SOAP_TYPE_ns1__getTrsDetailsResponse:
		return soap_in_ns1__getTrsDetailsResponse(soap, tag, NULL, "ns1:getTrsDetailsResponse");
	case SOAP_TYPE_ns1__getTrsTalkgroupCats:
		return soap_in_ns1__getTrsTalkgroupCats(soap, tag, NULL, "ns1:getTrsTalkgroupCats");
	case SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse:
		return soap_in_ns1__getTrsTalkgroupCatsResponse(soap, tag, NULL, "ns1:getTrsTalkgroupCatsResponse");
	case SOAP_TYPE_ns1__getTrsTalkgroups:
		return soap_in_ns1__getTrsTalkgroups(soap, tag, NULL, "ns1:getTrsTalkgroups");
	case SOAP_TYPE_ns1__getTrsTalkgroupsResponse:
		return soap_in_ns1__getTrsTalkgroupsResponse(soap, tag, NULL, "ns1:getTrsTalkgroupsResponse");
	case SOAP_TYPE_PointerTouserFeedBroadcasts:
		return soap_in_PointerTouserFeedBroadcasts(soap, tag, NULL, "ns1:userFeedBroadcast");
	case SOAP_TYPE_PointerTons1__UserInfo:
		return soap_in_PointerTons1__UserInfo(soap, tag, NULL, "ns1:UserInfo");
	case SOAP_TYPE_PointerToproxCallsignResults:
		return soap_in_PointerToproxCallsignResults(soap, tag, NULL, "ns1:proxCallsignResult");
	case SOAP_TYPE_PointerTofccRadioServiceCodes:
		return soap_in_PointerTofccRadioServiceCodes(soap, tag, NULL, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_PointerTons1__fccCallsignDetails:
		return soap_in_PointerTons1__fccCallsignDetails(soap, tag, NULL, "ns1:fccCallsignDetails");
	case SOAP_TYPE_PointerTons1__ZipInfo:
		return soap_in_PointerTons1__ZipInfo(soap, tag, NULL, "ns1:ZipInfo");
	case SOAP_TYPE_PointerToMetros:
		return soap_in_PointerToMetros(soap, tag, NULL, "ns1:Metro");
	case SOAP_TYPE_PointerTosearchFreqResults:
		return soap_in_PointerTosearchFreqResults(soap, tag, NULL, "ns1:searchFreqResult");
	case SOAP_TYPE_PointerToFreqs:
		return soap_in_PointerToFreqs(soap, tag, NULL, "ns1:freq");
	case SOAP_TYPE_PointerTons1__AgencyInfo:
		return soap_in_PointerTons1__AgencyInfo(soap, tag, NULL, "ns1:AgencyInfo");
	case SOAP_TYPE_PointerTons1__CountyInfo:
		return soap_in_PointerTons1__CountyInfo(soap, tag, NULL, "ns1:CountyInfo");
	case SOAP_TYPE_PointerTons1__StateInfo:
		return soap_in_PointerTons1__StateInfo(soap, tag, NULL, "ns1:StateInfo");
	case SOAP_TYPE_PointerTons1__CountryInfo:
		return soap_in_PointerTons1__CountryInfo(soap, tag, NULL, "ns1:CountryInfo");
	case SOAP_TYPE_PointerToCountries:
		return soap_in_PointerToCountries(soap, tag, NULL, "ns1:Country");
	case SOAP_TYPE_PointerToTrsVoice:
		return soap_in_PointerToTrsVoice(soap, tag, NULL, "ns1:trsVoiceDef");
	case SOAP_TYPE_PointerToTrsFlavor:
		return soap_in_PointerToTrsFlavor(soap, tag, NULL, "ns1:trsFlavorDef");
	case SOAP_TYPE_PointerToTrsType:
		return soap_in_PointerToTrsType(soap, tag, NULL, "ns1:trsTypeDef");
	case SOAP_TYPE_PointerTomodes:
		return soap_in_PointerTomodes(soap, tag, NULL, "ns1:mode");
	case SOAP_TYPE_PointerToctidList:
		return soap_in_PointerToctidList(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_PointerTostidList:
		return soap_in_PointerTostidList(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_PointerToTrsSites:
		return soap_in_PointerToTrsSites(soap, tag, NULL, "ns1:TrsSite");
	case SOAP_TYPE_PointerTons1__Trs:
		return soap_in_PointerTons1__Trs(soap, tag, NULL, "ns1:Trs");
	case SOAP_TYPE_PointerToTalkgroupCats:
		return soap_in_PointerToTalkgroupCats(soap, tag, NULL, "ns1:TalkgroupCat");
	case SOAP_TYPE_PointerTons1__authInfo:
		return soap_in_PointerTons1__authInfo(soap, tag, NULL, "ns1:authInfo");
	case SOAP_TYPE_PointerToTalkgroups:
		return soap_in_PointerToTalkgroups(soap, tag, NULL, "ns1:Talkgroup");
	case SOAP_TYPE_PointerToPointerTons1__fccRadioServiceCode:
		return soap_in_PointerToPointerTons1__fccRadioServiceCode(soap, tag, NULL, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_PointerTons1__fccRadioServiceCode:
		return soap_in_PointerTons1__fccRadioServiceCode(soap, tag, NULL, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_PointerToPointerTons1__proxCallsignResult:
		return soap_in_PointerToPointerTons1__proxCallsignResult(soap, tag, NULL, "ns1:proxCallsignResult");
	case SOAP_TYPE_PointerTons1__proxCallsignResult:
		return soap_in_PointerTons1__proxCallsignResult(soap, tag, NULL, "ns1:proxCallsignResult");
	case SOAP_TYPE_PointerToPointerTons1__fccLocation:
		return soap_in_PointerToPointerTons1__fccLocation(soap, tag, NULL, "ns1:fccLocation");
	case SOAP_TYPE_PointerTons1__fccLocation:
		return soap_in_PointerTons1__fccLocation(soap, tag, NULL, "ns1:fccLocation");
	case SOAP_TYPE_PointerToPointerTons1__fccFrequency:
		return soap_in_PointerToPointerTons1__fccFrequency(soap, tag, NULL, "ns1:fccFrequency");
	case SOAP_TYPE_PointerTons1__fccFrequency:
		return soap_in_PointerTons1__fccFrequency(soap, tag, NULL, "ns1:fccFrequency");
	case SOAP_TYPE_PointerToPointerTons1__mode:
		return soap_in_PointerToPointerTons1__mode(soap, tag, NULL, "ns1:mode");
	case SOAP_TYPE_PointerTons1__mode:
		return soap_in_PointerTons1__mode(soap, tag, NULL, "ns1:mode");
	case SOAP_TYPE_PointerToPointerTons1__tag:
		return soap_in_PointerToPointerTons1__tag(soap, tag, NULL, "ns1:tag");
	case SOAP_TYPE_PointerTons1__tag:
		return soap_in_PointerTons1__tag(soap, tag, NULL, "ns1:tag");
	case SOAP_TYPE_PointerToPointerTons1__sid:
		return soap_in_PointerToPointerTons1__sid(soap, tag, NULL, "ns1:sid");
	case SOAP_TYPE_PointerTons1__sid:
		return soap_in_PointerTons1__sid(soap, tag, NULL, "ns1:sid");
	case SOAP_TYPE_PointerToPointerTons1__Agency:
		return soap_in_PointerToPointerTons1__Agency(soap, tag, NULL, "ns1:Agency");
	case SOAP_TYPE_PointerTons1__Agency:
		return soap_in_PointerTons1__Agency(soap, tag, NULL, "ns1:Agency");
	case SOAP_TYPE_PointerToPointerTons1__Country:
		return soap_in_PointerToPointerTons1__Country(soap, tag, NULL, "ns1:Country");
	case SOAP_TYPE_PointerTons1__Country:
		return soap_in_PointerTons1__Country(soap, tag, NULL, "ns1:Country");
	case SOAP_TYPE_PointerToPointerTons1__Metro:
		return soap_in_PointerToPointerTons1__Metro(soap, tag, NULL, "ns1:Metro");
	case SOAP_TYPE_PointerTons1__Metro:
		return soap_in_PointerTons1__Metro(soap, tag, NULL, "ns1:Metro");
	case SOAP_TYPE_PointerToPointerTons1__State:
		return soap_in_PointerToPointerTons1__State(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_PointerTons1__State:
		return soap_in_PointerTons1__State(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_PointerToPointerTons1__County:
		return soap_in_PointerToPointerTons1__County(soap, tag, NULL, "ns1:County");
	case SOAP_TYPE_PointerTons1__County:
		return soap_in_PointerTons1__County(soap, tag, NULL, "ns1:County");
	case SOAP_TYPE_PointerToPointerTons1__subcat:
		return soap_in_PointerToPointerTons1__subcat(soap, tag, NULL, "ns1:subcat");
	case SOAP_TYPE_PointerTons1__subcat:
		return soap_in_PointerTons1__subcat(soap, tag, NULL, "ns1:subcat");
	case SOAP_TYPE_PointerToPointerTons1__cat:
		return soap_in_PointerToPointerTons1__cat(soap, tag, NULL, "ns1:cat");
	case SOAP_TYPE_PointerTons1__cat:
		return soap_in_PointerTons1__cat(soap, tag, NULL, "ns1:cat");
	case SOAP_TYPE_PointerToPointerTons1__freq:
		return soap_in_PointerToPointerTons1__freq(soap, tag, NULL, "ns1:freq");
	case SOAP_TYPE_PointerTons1__freq:
		return soap_in_PointerTons1__freq(soap, tag, NULL, "ns1:freq");
	case SOAP_TYPE_PointerToPointerTons1__searchFreqResult:
		return soap_in_PointerToPointerTons1__searchFreqResult(soap, tag, NULL, "ns1:searchFreqResult");
	case SOAP_TYPE_PointerTons1__searchFreqResult:
		return soap_in_PointerTons1__searchFreqResult(soap, tag, NULL, "ns1:searchFreqResult");
	case SOAP_TYPE_PointerToPointerTons1__trsVoiceDef:
		return soap_in_PointerToPointerTons1__trsVoiceDef(soap, tag, NULL, "ns1:trsVoiceDef");
	case SOAP_TYPE_PointerTons1__trsVoiceDef:
		return soap_in_PointerTons1__trsVoiceDef(soap, tag, NULL, "ns1:trsVoiceDef");
	case SOAP_TYPE_PointerToPointerTons1__trsFlavorDef:
		return soap_in_PointerToPointerTons1__trsFlavorDef(soap, tag, NULL, "ns1:trsFlavorDef");
	case SOAP_TYPE_PointerTons1__trsFlavorDef:
		return soap_in_PointerTons1__trsFlavorDef(soap, tag, NULL, "ns1:trsFlavorDef");
	case SOAP_TYPE_PointerToPointerTons1__trsTypeDef:
		return soap_in_PointerToPointerTons1__trsTypeDef(soap, tag, NULL, "ns1:trsTypeDef");
	case SOAP_TYPE_PointerTons1__trsTypeDef:
		return soap_in_PointerTons1__trsTypeDef(soap, tag, NULL, "ns1:trsTypeDef");
	case SOAP_TYPE_PointerToPointerTons1__trsBandplanDef:
		return soap_in_PointerToPointerTons1__trsBandplanDef(soap, tag, NULL, "ns1:trsBandplanDef");
	case SOAP_TYPE_PointerTons1__trsBandplanDef:
		return soap_in_PointerTons1__trsBandplanDef(soap, tag, NULL, "ns1:trsBandplanDef");
	case SOAP_TYPE_PointerToPointerTons1__trsSysidDef:
		return soap_in_PointerToPointerTons1__trsSysidDef(soap, tag, NULL, "ns1:trsSysidDef");
	case SOAP_TYPE_PointerTons1__trsSysidDef:
		return soap_in_PointerTons1__trsSysidDef(soap, tag, NULL, "ns1:trsSysidDef");
	case SOAP_TYPE_PointerToPointerTons1__TrsListDef:
		return soap_in_PointerToPointerTons1__TrsListDef(soap, tag, NULL, "ns1:TrsListDef");
	case SOAP_TYPE_PointerTons1__TrsListDef:
		return soap_in_PointerTons1__TrsListDef(soap, tag, NULL, "ns1:TrsListDef");
	case SOAP_TYPE_PointerToPointerTons1__TrsSiteLicense:
		return soap_in_PointerToPointerTons1__TrsSiteLicense(soap, tag, NULL, "ns1:TrsSiteLicense");
	case SOAP_TYPE_PointerTons1__TrsSiteLicense:
		return soap_in_PointerTons1__TrsSiteLicense(soap, tag, NULL, "ns1:TrsSiteLicense");
	case SOAP_TYPE_PointerToPointerTons1__TrsSiteFreq:
		return soap_in_PointerToPointerTons1__TrsSiteFreq(soap, tag, NULL, "ns1:TrsSiteFreq");
	case SOAP_TYPE_PointerTons1__TrsSiteFreq:
		return soap_in_PointerTons1__TrsSiteFreq(soap, tag, NULL, "ns1:TrsSiteFreq");
	case SOAP_TYPE_PointerToPointerTons1__TrsSite:
		return soap_in_PointerToPointerTons1__TrsSite(soap, tag, NULL, "ns1:TrsSite");
	case SOAP_TYPE_PointerTons1__TrsSite:
		return soap_in_PointerTons1__TrsSite(soap, tag, NULL, "ns1:TrsSite");
	case SOAP_TYPE_PointerToPointerTons1__TalkgroupCat:
		return soap_in_PointerToPointerTons1__TalkgroupCat(soap, tag, NULL, "ns1:TalkgroupCat");
	case SOAP_TYPE_PointerTons1__TalkgroupCat:
		return soap_in_PointerTons1__TalkgroupCat(soap, tag, NULL, "ns1:TalkgroupCat");
	case SOAP_TYPE_PointerToPointerTons1__Talkgroup:
		return soap_in_PointerToPointerTons1__Talkgroup(soap, tag, NULL, "ns1:Talkgroup");
	case SOAP_TYPE_PointerTons1__Talkgroup:
		return soap_in_PointerTons1__Talkgroup(soap, tag, NULL, "ns1:Talkgroup");
	case SOAP_TYPE_PointerToPointerTons1__ctid:
		return soap_in_PointerToPointerTons1__ctid(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_PointerTons1__ctid:
		return soap_in_PointerTons1__ctid(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_PointerToPointerTons1__stid:
		return soap_in_PointerToPointerTons1__stid(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_PointerTons1__stid:
		return soap_in_PointerTons1__stid(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_PointerToPointerTons1__userFeedBroadcast:
		return soap_in_PointerToPointerTons1__userFeedBroadcast(soap, tag, NULL, "ns1:userFeedBroadcast");
	case SOAP_TYPE_PointerTons1__userFeedBroadcast:
		return soap_in_PointerTons1__userFeedBroadcast(soap, tag, NULL, "ns1:userFeedBroadcast");
	case SOAP_TYPE_PointerTofccFrequencies:
		return soap_in_PointerTofccFrequencies(soap, tag, NULL, "ns1:fccFrequency");
	case SOAP_TYPE_PointerTofccLocations:
		return soap_in_PointerTofccLocations(soap, tag, NULL, "ns1:fccLocation");
	case SOAP_TYPE_PointerToCounties:
		return soap_in_PointerToCounties(soap, tag, NULL, "ns1:County");
	case SOAP_TYPE_PointerToTrsList:
		return soap_in_PointerToTrsList(soap, tag, NULL, "ns1:TrsListDef");
	case SOAP_TYPE_PointerToStates:
		return soap_in_PointerToStates(soap, tag, NULL, "ns1:State");
	case SOAP_TYPE_PointerToAgencies:
		return soap_in_PointerToAgencies(soap, tag, NULL, "ns1:Agency");
	case SOAP_TYPE_PointerToCats:
		return soap_in_PointerToCats(soap, tag, NULL, "ns1:cat");
	case SOAP_TYPE_PointerTosids:
		return soap_in_PointerTosids(soap, tag, NULL, "ns1:sid");
	case SOAP_TYPE_PointerToSubCats:
		return soap_in_PointerToSubCats(soap, tag, NULL, "ns1:subcat");
	case SOAP_TYPE_PointerTons1__TrsFleetmap:
		return soap_in_PointerTons1__TrsFleetmap(soap, tag, NULL, "ns1:TrsFleetmap");
	case SOAP_TYPE_PointerToTrsSysid:
		return soap_in_PointerToTrsSysid(soap, tag, NULL, "ns1:trsSysidDef");
	case SOAP_TYPE_PointerTostids:
		return soap_in_PointerTostids(soap, tag, NULL, "ns1:stid");
	case SOAP_TYPE_PointerToctids:
		return soap_in_PointerToctids(soap, tag, NULL, "ns1:ctid");
	case SOAP_TYPE_PointerToTrsBandplan:
		return soap_in_PointerToTrsBandplan(soap, tag, NULL, "ns1:trsBandplanDef");
	case SOAP_TYPE_PointerToTrsSiteFreqs:
		return soap_in_PointerToTrsSiteFreqs(soap, tag, NULL, "ns1:TrsSiteFreq");
	case SOAP_TYPE_PointerToTrsSiteLicenses:
		return soap_in_PointerToTrsSiteLicenses(soap, tag, NULL, "ns1:TrsSiteLicense");
	case SOAP_TYPE_PointerTotags:
		return soap_in_PointerTotags(soap, tag, NULL, "ns1:tag");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (*soap->arrayType && !soap_match_array(soap, "ns1:fccRadioServiceCode"))
		{	*type = SOAP_TYPE_fccRadioServiceCodes;
			return soap_in_fccRadioServiceCodes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccRadioServiceCode"))
		{	*type = SOAP_TYPE_ns1__fccRadioServiceCode;
			return soap_in_ns1__fccRadioServiceCode(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:proxCallsignResult"))
		{	*type = SOAP_TYPE_proxCallsignResults;
			return soap_in_proxCallsignResults(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:proxCallsignResult"))
		{	*type = SOAP_TYPE_ns1__proxCallsignResult;
			return soap_in_ns1__proxCallsignResult(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:fccLocation"))
		{	*type = SOAP_TYPE_fccLocations;
			return soap_in_fccLocations(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccLocation"))
		{	*type = SOAP_TYPE_ns1__fccLocation;
			return soap_in_ns1__fccLocation(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:fccFrequency"))
		{	*type = SOAP_TYPE_fccFrequencies;
			return soap_in_fccFrequencies(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccFrequency"))
		{	*type = SOAP_TYPE_ns1__fccFrequency;
			return soap_in_ns1__fccFrequency(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccCallsignDetails"))
		{	*type = SOAP_TYPE_ns1__fccCallsignDetails;
			return soap_in_ns1__fccCallsignDetails(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserInfo"))
		{	*type = SOAP_TYPE_ns1__UserInfo;
			return soap_in_ns1__UserInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ZipInfo"))
		{	*type = SOAP_TYPE_ns1__ZipInfo;
			return soap_in_ns1__ZipInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:mode"))
		{	*type = SOAP_TYPE_ns1__mode;
			return soap_in_ns1__mode(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:mode"))
		{	*type = SOAP_TYPE_modes;
			return soap_in_modes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tag"))
		{	*type = SOAP_TYPE_ns1__tag;
			return soap_in_ns1__tag(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:tag"))
		{	*type = SOAP_TYPE_tags;
			return soap_in_tags(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sid"))
		{	*type = SOAP_TYPE_ns1__sid;
			return soap_in_ns1__sid(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:sid"))
		{	*type = SOAP_TYPE_sids;
			return soap_in_sids(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:stid"))
		{	*type = SOAP_TYPE_ns1__stid;
			return soap_in_ns1__stid(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:stid"))
		{	*type = SOAP_TYPE_stids;
			return soap_in_stids(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Agency"))
		{	*type = SOAP_TYPE_ns1__Agency;
			return soap_in_ns1__Agency(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Agency"))
		{	*type = SOAP_TYPE_Agencies;
			return soap_in_Agencies(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Country"))
		{	*type = SOAP_TYPE_ns1__Country;
			return soap_in_ns1__Country(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Country"))
		{	*type = SOAP_TYPE_Countries;
			return soap_in_Countries(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Metro"))
		{	*type = SOAP_TYPE_ns1__Metro;
			return soap_in_ns1__Metro(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Metro"))
		{	*type = SOAP_TYPE_Metros;
			return soap_in_Metros(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:State"))
		{	*type = SOAP_TYPE_ns1__State;
			return soap_in_ns1__State(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:State"))
		{	*type = SOAP_TYPE_States;
			return soap_in_States(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ctid"))
		{	*type = SOAP_TYPE_ns1__ctid;
			return soap_in_ns1__ctid(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ctid"))
		{	*type = SOAP_TYPE_ctids;
			return soap_in_ctids(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:County"))
		{	*type = SOAP_TYPE_Counties;
			return soap_in_Counties(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:County"))
		{	*type = SOAP_TYPE_ns1__County;
			return soap_in_ns1__County(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StateInfo"))
		{	*type = SOAP_TYPE_ns1__StateInfo;
			return soap_in_ns1__StateInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountyInfo"))
		{	*type = SOAP_TYPE_ns1__CountyInfo;
			return soap_in_ns1__CountyInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CountryInfo"))
		{	*type = SOAP_TYPE_ns1__CountryInfo;
			return soap_in_ns1__CountryInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AgencyInfo"))
		{	*type = SOAP_TYPE_ns1__AgencyInfo;
			return soap_in_ns1__AgencyInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subcat"))
		{	*type = SOAP_TYPE_ns1__subcat;
			return soap_in_ns1__subcat(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:subcat"))
		{	*type = SOAP_TYPE_SubCats;
			return soap_in_SubCats(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cat"))
		{	*type = SOAP_TYPE_ns1__cat;
			return soap_in_ns1__cat(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:cat"))
		{	*type = SOAP_TYPE_Cats;
			return soap_in_Cats(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:freq"))
		{	*type = SOAP_TYPE_Freqs;
			return soap_in_Freqs(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:searchFreqResult"))
		{	*type = SOAP_TYPE_searchFreqResults;
			return soap_in_searchFreqResults(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchFreqResult"))
		{	*type = SOAP_TYPE_ns1__searchFreqResult;
			return soap_in_ns1__searchFreqResult(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:freq"))
		{	*type = SOAP_TYPE_ns1__freq;
			return soap_in_ns1__freq(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:trsVoiceDef"))
		{	*type = SOAP_TYPE_TrsVoice;
			return soap_in_TrsVoice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trsVoiceDef"))
		{	*type = SOAP_TYPE_ns1__trsVoiceDef;
			return soap_in_ns1__trsVoiceDef(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:trsFlavorDef"))
		{	*type = SOAP_TYPE_TrsFlavor;
			return soap_in_TrsFlavor(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trsFlavorDef"))
		{	*type = SOAP_TYPE_ns1__trsFlavorDef;
			return soap_in_ns1__trsFlavorDef(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:trsTypeDef"))
		{	*type = SOAP_TYPE_TrsType;
			return soap_in_TrsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trsTypeDef"))
		{	*type = SOAP_TYPE_ns1__trsTypeDef;
			return soap_in_ns1__trsTypeDef(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrsFleetmap"))
		{	*type = SOAP_TYPE_ns1__TrsFleetmap;
			return soap_in_ns1__TrsFleetmap(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:trsBandplanDef"))
		{	*type = SOAP_TYPE_TrsBandplan;
			return soap_in_TrsBandplan(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trsBandplanDef"))
		{	*type = SOAP_TYPE_ns1__trsBandplanDef;
			return soap_in_ns1__trsBandplanDef(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:trsSysidDef"))
		{	*type = SOAP_TYPE_TrsSysid;
			return soap_in_TrsSysid(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:trsSysidDef"))
		{	*type = SOAP_TYPE_ns1__trsSysidDef;
			return soap_in_ns1__trsSysidDef(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:TrsListDef"))
		{	*type = SOAP_TYPE_TrsList;
			return soap_in_TrsList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrsListDef"))
		{	*type = SOAP_TYPE_ns1__TrsListDef;
			return soap_in_ns1__TrsListDef(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Trs"))
		{	*type = SOAP_TYPE_ns1__Trs;
			return soap_in_ns1__Trs(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:TrsSiteLicense"))
		{	*type = SOAP_TYPE_TrsSiteLicenses;
			return soap_in_TrsSiteLicenses(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrsSiteLicense"))
		{	*type = SOAP_TYPE_ns1__TrsSiteLicense;
			return soap_in_ns1__TrsSiteLicense(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:TrsSiteFreq"))
		{	*type = SOAP_TYPE_TrsSiteFreqs;
			return soap_in_TrsSiteFreqs(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrsSiteFreq"))
		{	*type = SOAP_TYPE_ns1__TrsSiteFreq;
			return soap_in_ns1__TrsSiteFreq(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:TrsSite"))
		{	*type = SOAP_TYPE_TrsSites;
			return soap_in_TrsSites(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TrsSite"))
		{	*type = SOAP_TYPE_ns1__TrsSite;
			return soap_in_ns1__TrsSite(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:TalkgroupCat"))
		{	*type = SOAP_TYPE_TalkgroupCats;
			return soap_in_TalkgroupCats(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TalkgroupCat"))
		{	*type = SOAP_TYPE_ns1__TalkgroupCat;
			return soap_in_ns1__TalkgroupCat(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:Talkgroup"))
		{	*type = SOAP_TYPE_Talkgroups;
			return soap_in_Talkgroups(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Talkgroup"))
		{	*type = SOAP_TYPE_ns1__Talkgroup;
			return soap_in_ns1__Talkgroup(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ctid"))
		{	*type = SOAP_TYPE_ctidList;
			return soap_in_ctidList(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:stid"))
		{	*type = SOAP_TYPE_stidList;
			return soap_in_stidList(soap, tag, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:userFeedBroadcast"))
		{	*type = SOAP_TYPE_userFeedBroadcasts;
			return soap_in_userFeedBroadcasts(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:userFeedBroadcast"))
		{	*type = SOAP_TYPE_ns1__userFeedBroadcast;
			return soap_in_ns1__userFeedBroadcast(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:authInfo"))
		{	*type = SOAP_TYPE_ns1__authInfo;
			return soap_in_ns1__authInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENC:Array"))
		{	*type = SOAP_TYPE_SOAP_ENC__Array;
			return soap_in_SOAP_ENC__Array(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserFeedBroadcasts"))
		{	*type = SOAP_TYPE_ns1__getUserFeedBroadcasts;
			return soap_in_ns1__getUserFeedBroadcasts(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserFeedBroadcastsResponse"))
		{	*type = SOAP_TYPE_ns1__getUserFeedBroadcastsResponse;
			return soap_in_ns1__getUserFeedBroadcastsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserData"))
		{	*type = SOAP_TYPE_ns1__getUserData;
			return soap_in_ns1__getUserData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserDataResponse"))
		{	*type = SOAP_TYPE_ns1__getUserDataResponse;
			return soap_in_ns1__getUserDataResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccGetProxCallsigns"))
		{	*type = SOAP_TYPE_ns1__fccGetProxCallsigns;
			return soap_in_ns1__fccGetProxCallsigns(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccGetProxCallsignsResponse"))
		{	*type = SOAP_TYPE_ns1__fccGetProxCallsignsResponse;
			return soap_in_ns1__fccGetProxCallsignsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccGetRadioServiceCode"))
		{	*type = SOAP_TYPE_ns1__fccGetRadioServiceCode;
			return soap_in_ns1__fccGetRadioServiceCode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccGetRadioServiceCodeResponse"))
		{	*type = SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse;
			return soap_in_ns1__fccGetRadioServiceCodeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccGetCallsign"))
		{	*type = SOAP_TYPE_ns1__fccGetCallsign;
			return soap_in_ns1__fccGetCallsign(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fccGetCallsignResponse"))
		{	*type = SOAP_TYPE_ns1__fccGetCallsignResponse;
			return soap_in_ns1__fccGetCallsignResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getZipcodeInfo"))
		{	*type = SOAP_TYPE_ns1__getZipcodeInfo;
			return soap_in_ns1__getZipcodeInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getZipcodeInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getZipcodeInfoResponse;
			return soap_in_ns1__getZipcodeInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetroAreaInfo"))
		{	*type = SOAP_TYPE_ns1__getMetroAreaInfo;
			return soap_in_ns1__getMetroAreaInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetroAreaInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getMetroAreaInfoResponse;
			return soap_in_ns1__getMetroAreaInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetroArea"))
		{	*type = SOAP_TYPE_ns1__getMetroArea;
			return soap_in_ns1__getMetroArea(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetroAreaResponse"))
		{	*type = SOAP_TYPE_ns1__getMetroAreaResponse;
			return soap_in_ns1__getMetroAreaResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAgencyFreqsByTag"))
		{	*type = SOAP_TYPE_ns1__getAgencyFreqsByTag;
			return soap_in_ns1__getAgencyFreqsByTag(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAgencyFreqsByTagResponse"))
		{	*type = SOAP_TYPE_ns1__getAgencyFreqsByTagResponse;
			return soap_in_ns1__getAgencyFreqsByTagResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountyFreqsByTag"))
		{	*type = SOAP_TYPE_ns1__getCountyFreqsByTag;
			return soap_in_ns1__getCountyFreqsByTag(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountyFreqsByTagResponse"))
		{	*type = SOAP_TYPE_ns1__getCountyFreqsByTagResponse;
			return soap_in_ns1__getCountyFreqsByTagResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchMetroFreq"))
		{	*type = SOAP_TYPE_ns1__searchMetroFreq;
			return soap_in_ns1__searchMetroFreq(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchMetroFreqResponse"))
		{	*type = SOAP_TYPE_ns1__searchMetroFreqResponse;
			return soap_in_ns1__searchMetroFreqResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchStateFreq"))
		{	*type = SOAP_TYPE_ns1__searchStateFreq;
			return soap_in_ns1__searchStateFreq(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchStateFreqResponse"))
		{	*type = SOAP_TYPE_ns1__searchStateFreqResponse;
			return soap_in_ns1__searchStateFreqResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchCountyFreq"))
		{	*type = SOAP_TYPE_ns1__searchCountyFreq;
			return soap_in_ns1__searchCountyFreq(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:searchCountyFreqResponse"))
		{	*type = SOAP_TYPE_ns1__searchCountyFreqResponse;
			return soap_in_ns1__searchCountyFreqResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSubcatFreqs"))
		{	*type = SOAP_TYPE_ns1__getSubcatFreqs;
			return soap_in_ns1__getSubcatFreqs(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getSubcatFreqsResponse"))
		{	*type = SOAP_TYPE_ns1__getSubcatFreqsResponse;
			return soap_in_ns1__getSubcatFreqsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAgencyInfo"))
		{	*type = SOAP_TYPE_ns1__getAgencyInfo;
			return soap_in_ns1__getAgencyInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAgencyInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getAgencyInfoResponse;
			return soap_in_ns1__getAgencyInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountyInfo"))
		{	*type = SOAP_TYPE_ns1__getCountyInfo;
			return soap_in_ns1__getCountyInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountyInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getCountyInfoResponse;
			return soap_in_ns1__getCountyInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStateInfo"))
		{	*type = SOAP_TYPE_ns1__getStateInfo;
			return soap_in_ns1__getStateInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStateInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getStateInfoResponse;
			return soap_in_ns1__getStateInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountryInfo"))
		{	*type = SOAP_TYPE_ns1__getCountryInfo;
			return soap_in_ns1__getCountryInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountryInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getCountryInfoResponse;
			return soap_in_ns1__getCountryInfoResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountryList"))
		{	*type = SOAP_TYPE_ns1__getCountryList;
			return soap_in_ns1__getCountryList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountryListResponse"))
		{	*type = SOAP_TYPE_ns1__getCountryListResponse;
			return soap_in_ns1__getCountryListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsVoice"))
		{	*type = SOAP_TYPE_ns1__getTrsVoice;
			return soap_in_ns1__getTrsVoice(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsVoiceResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsVoiceResponse;
			return soap_in_ns1__getTrsVoiceResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsFlavor"))
		{	*type = SOAP_TYPE_ns1__getTrsFlavor;
			return soap_in_ns1__getTrsFlavor(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsFlavorResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsFlavorResponse;
			return soap_in_ns1__getTrsFlavorResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsType"))
		{	*type = SOAP_TYPE_ns1__getTrsType;
			return soap_in_ns1__getTrsType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsTypeResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsTypeResponse;
			return soap_in_ns1__getTrsTypeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMode"))
		{	*type = SOAP_TYPE_ns1__getMode;
			return soap_in_ns1__getMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getModeResponse"))
		{	*type = SOAP_TYPE_ns1__getModeResponse;
			return soap_in_ns1__getModeResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTag"))
		{	*type = SOAP_TYPE_ns1__getTag;
			return soap_in_ns1__getTag(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTagResponse"))
		{	*type = SOAP_TYPE_ns1__getTagResponse;
			return soap_in_ns1__getTagResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountiesByList"))
		{	*type = SOAP_TYPE_ns1__getCountiesByList;
			return soap_in_ns1__getCountiesByList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCountiesByListResponse"))
		{	*type = SOAP_TYPE_ns1__getCountiesByListResponse;
			return soap_in_ns1__getCountiesByListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStatesByList"))
		{	*type = SOAP_TYPE_ns1__getStatesByList;
			return soap_in_ns1__getStatesByList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getStatesByListResponse"))
		{	*type = SOAP_TYPE_ns1__getStatesByListResponse;
			return soap_in_ns1__getStatesByListResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsSites"))
		{	*type = SOAP_TYPE_ns1__getTrsSites;
			return soap_in_ns1__getTrsSites(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsSitesResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsSitesResponse;
			return soap_in_ns1__getTrsSitesResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsBySysid"))
		{	*type = SOAP_TYPE_ns1__getTrsBySysid;
			return soap_in_ns1__getTrsBySysid(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsBySysidResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsBySysidResponse;
			return soap_in_ns1__getTrsBySysidResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsDetails"))
		{	*type = SOAP_TYPE_ns1__getTrsDetails;
			return soap_in_ns1__getTrsDetails(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsDetailsResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsDetailsResponse;
			return soap_in_ns1__getTrsDetailsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsTalkgroupCats"))
		{	*type = SOAP_TYPE_ns1__getTrsTalkgroupCats;
			return soap_in_ns1__getTrsTalkgroupCats(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsTalkgroupCatsResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse;
			return soap_in_ns1__getTrsTalkgroupCatsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsTalkgroups"))
		{	*type = SOAP_TYPE_ns1__getTrsTalkgroups;
			return soap_in_ns1__getTrsTalkgroups(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTrsTalkgroupsResponse"))
		{	*type = SOAP_TYPE_ns1__getTrsTalkgroupsResponse;
			return soap_in_ns1__getTrsTalkgroupsResponse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_fccRadioServiceCodes:
		return ((fccRadioServiceCodes *)ptr)->soap_out(soap, tag, id, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_ns1__fccRadioServiceCode:
		return ((ns1__fccRadioServiceCode *)ptr)->soap_out(soap, tag, id, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_proxCallsignResults:
		return ((proxCallsignResults *)ptr)->soap_out(soap, tag, id, "ns1:proxCallsignResult");
	case SOAP_TYPE_ns1__proxCallsignResult:
		return ((ns1__proxCallsignResult *)ptr)->soap_out(soap, tag, id, "ns1:proxCallsignResult");
	case SOAP_TYPE_fccLocations:
		return ((fccLocations *)ptr)->soap_out(soap, tag, id, "ns1:fccLocation");
	case SOAP_TYPE_ns1__fccLocation:
		return ((ns1__fccLocation *)ptr)->soap_out(soap, tag, id, "ns1:fccLocation");
	case SOAP_TYPE_fccFrequencies:
		return ((fccFrequencies *)ptr)->soap_out(soap, tag, id, "ns1:fccFrequency");
	case SOAP_TYPE_ns1__fccFrequency:
		return ((ns1__fccFrequency *)ptr)->soap_out(soap, tag, id, "ns1:fccFrequency");
	case SOAP_TYPE_ns1__fccCallsignDetails:
		return ((ns1__fccCallsignDetails *)ptr)->soap_out(soap, tag, id, "ns1:fccCallsignDetails");
	case SOAP_TYPE_ns1__UserInfo:
		return ((ns1__UserInfo *)ptr)->soap_out(soap, tag, id, "ns1:UserInfo");
	case SOAP_TYPE_ns1__ZipInfo:
		return ((ns1__ZipInfo *)ptr)->soap_out(soap, tag, id, "ns1:ZipInfo");
	case SOAP_TYPE_ns1__mode:
		return ((ns1__mode *)ptr)->soap_out(soap, tag, id, "ns1:mode");
	case SOAP_TYPE_modes:
		return ((modes *)ptr)->soap_out(soap, tag, id, "ns1:mode");
	case SOAP_TYPE_ns1__tag:
		return ((ns1__tag *)ptr)->soap_out(soap, tag, id, "ns1:tag");
	case SOAP_TYPE_tags:
		return ((tags *)ptr)->soap_out(soap, tag, id, "ns1:tag");
	case SOAP_TYPE_ns1__sid:
		return ((ns1__sid *)ptr)->soap_out(soap, tag, id, "ns1:sid");
	case SOAP_TYPE_sids:
		return ((sids *)ptr)->soap_out(soap, tag, id, "ns1:sid");
	case SOAP_TYPE_ns1__stid:
		return ((ns1__stid *)ptr)->soap_out(soap, tag, id, "ns1:stid");
	case SOAP_TYPE_stids:
		return ((stids *)ptr)->soap_out(soap, tag, id, "ns1:stid");
	case SOAP_TYPE_ns1__Agency:
		return ((ns1__Agency *)ptr)->soap_out(soap, tag, id, "ns1:Agency");
	case SOAP_TYPE_Agencies:
		return ((Agencies *)ptr)->soap_out(soap, tag, id, "ns1:Agency");
	case SOAP_TYPE_ns1__Country:
		return ((ns1__Country *)ptr)->soap_out(soap, tag, id, "ns1:Country");
	case SOAP_TYPE_Countries:
		return ((Countries *)ptr)->soap_out(soap, tag, id, "ns1:Country");
	case SOAP_TYPE_ns1__Metro:
		return ((ns1__Metro *)ptr)->soap_out(soap, tag, id, "ns1:Metro");
	case SOAP_TYPE_Metros:
		return ((Metros *)ptr)->soap_out(soap, tag, id, "ns1:Metro");
	case SOAP_TYPE_ns1__State:
		return ((ns1__State *)ptr)->soap_out(soap, tag, id, "ns1:State");
	case SOAP_TYPE_States:
		return ((States *)ptr)->soap_out(soap, tag, id, "ns1:State");
	case SOAP_TYPE_ns1__ctid:
		return ((ns1__ctid *)ptr)->soap_out(soap, tag, id, "ns1:ctid");
	case SOAP_TYPE_ctids:
		return ((ctids *)ptr)->soap_out(soap, tag, id, "ns1:ctid");
	case SOAP_TYPE_Counties:
		return ((Counties *)ptr)->soap_out(soap, tag, id, "ns1:County");
	case SOAP_TYPE_ns1__County:
		return ((ns1__County *)ptr)->soap_out(soap, tag, id, "ns1:County");
	case SOAP_TYPE_ns1__StateInfo:
		return ((ns1__StateInfo *)ptr)->soap_out(soap, tag, id, "ns1:StateInfo");
	case SOAP_TYPE_ns1__CountyInfo:
		return ((ns1__CountyInfo *)ptr)->soap_out(soap, tag, id, "ns1:CountyInfo");
	case SOAP_TYPE_ns1__CountryInfo:
		return ((ns1__CountryInfo *)ptr)->soap_out(soap, tag, id, "ns1:CountryInfo");
	case SOAP_TYPE_ns1__AgencyInfo:
		return ((ns1__AgencyInfo *)ptr)->soap_out(soap, tag, id, "ns1:AgencyInfo");
	case SOAP_TYPE_ns1__subcat:
		return ((ns1__subcat *)ptr)->soap_out(soap, tag, id, "ns1:subcat");
	case SOAP_TYPE_SubCats:
		return ((SubCats *)ptr)->soap_out(soap, tag, id, "ns1:subcat");
	case SOAP_TYPE_ns1__cat:
		return ((ns1__cat *)ptr)->soap_out(soap, tag, id, "ns1:cat");
	case SOAP_TYPE_Cats:
		return ((Cats *)ptr)->soap_out(soap, tag, id, "ns1:cat");
	case SOAP_TYPE_Freqs:
		return ((Freqs *)ptr)->soap_out(soap, tag, id, "ns1:freq");
	case SOAP_TYPE_searchFreqResults:
		return ((searchFreqResults *)ptr)->soap_out(soap, tag, id, "ns1:searchFreqResult");
	case SOAP_TYPE_ns1__searchFreqResult:
		return ((ns1__searchFreqResult *)ptr)->soap_out(soap, tag, id, "ns1:searchFreqResult");
	case SOAP_TYPE_ns1__freq:
		return ((ns1__freq *)ptr)->soap_out(soap, tag, id, "ns1:freq");
	case SOAP_TYPE_TrsVoice:
		return ((TrsVoice *)ptr)->soap_out(soap, tag, id, "ns1:trsVoiceDef");
	case SOAP_TYPE_ns1__trsVoiceDef:
		return ((ns1__trsVoiceDef *)ptr)->soap_out(soap, tag, id, "ns1:trsVoiceDef");
	case SOAP_TYPE_TrsFlavor:
		return ((TrsFlavor *)ptr)->soap_out(soap, tag, id, "ns1:trsFlavorDef");
	case SOAP_TYPE_ns1__trsFlavorDef:
		return ((ns1__trsFlavorDef *)ptr)->soap_out(soap, tag, id, "ns1:trsFlavorDef");
	case SOAP_TYPE_TrsType:
		return ((TrsType *)ptr)->soap_out(soap, tag, id, "ns1:trsTypeDef");
	case SOAP_TYPE_ns1__trsTypeDef:
		return ((ns1__trsTypeDef *)ptr)->soap_out(soap, tag, id, "ns1:trsTypeDef");
	case SOAP_TYPE_ns1__TrsFleetmap:
		return ((ns1__TrsFleetmap *)ptr)->soap_out(soap, tag, id, "ns1:TrsFleetmap");
	case SOAP_TYPE_TrsBandplan:
		return ((TrsBandplan *)ptr)->soap_out(soap, tag, id, "ns1:trsBandplanDef");
	case SOAP_TYPE_ns1__trsBandplanDef:
		return ((ns1__trsBandplanDef *)ptr)->soap_out(soap, tag, id, "ns1:trsBandplanDef");
	case SOAP_TYPE_TrsSysid:
		return ((TrsSysid *)ptr)->soap_out(soap, tag, id, "ns1:trsSysidDef");
	case SOAP_TYPE_ns1__trsSysidDef:
		return ((ns1__trsSysidDef *)ptr)->soap_out(soap, tag, id, "ns1:trsSysidDef");
	case SOAP_TYPE_TrsList:
		return ((TrsList *)ptr)->soap_out(soap, tag, id, "ns1:TrsListDef");
	case SOAP_TYPE_ns1__TrsListDef:
		return ((ns1__TrsListDef *)ptr)->soap_out(soap, tag, id, "ns1:TrsListDef");
	case SOAP_TYPE_ns1__Trs:
		return ((ns1__Trs *)ptr)->soap_out(soap, tag, id, "ns1:Trs");
	case SOAP_TYPE_TrsSiteLicenses:
		return ((TrsSiteLicenses *)ptr)->soap_out(soap, tag, id, "ns1:TrsSiteLicense");
	case SOAP_TYPE_ns1__TrsSiteLicense:
		return ((ns1__TrsSiteLicense *)ptr)->soap_out(soap, tag, id, "ns1:TrsSiteLicense");
	case SOAP_TYPE_TrsSiteFreqs:
		return ((TrsSiteFreqs *)ptr)->soap_out(soap, tag, id, "ns1:TrsSiteFreq");
	case SOAP_TYPE_ns1__TrsSiteFreq:
		return ((ns1__TrsSiteFreq *)ptr)->soap_out(soap, tag, id, "ns1:TrsSiteFreq");
	case SOAP_TYPE_TrsSites:
		return ((TrsSites *)ptr)->soap_out(soap, tag, id, "ns1:TrsSite");
	case SOAP_TYPE_ns1__TrsSite:
		return ((ns1__TrsSite *)ptr)->soap_out(soap, tag, id, "ns1:TrsSite");
	case SOAP_TYPE_TalkgroupCats:
		return ((TalkgroupCats *)ptr)->soap_out(soap, tag, id, "ns1:TalkgroupCat");
	case SOAP_TYPE_ns1__TalkgroupCat:
		return ((ns1__TalkgroupCat *)ptr)->soap_out(soap, tag, id, "ns1:TalkgroupCat");
	case SOAP_TYPE_Talkgroups:
		return ((Talkgroups *)ptr)->soap_out(soap, tag, id, "ns1:Talkgroup");
	case SOAP_TYPE_ns1__Talkgroup:
		return ((ns1__Talkgroup *)ptr)->soap_out(soap, tag, id, "ns1:Talkgroup");
	case SOAP_TYPE_ctidList:
		return ((ctidList *)ptr)->soap_out(soap, tag, id, "ns1:ctid");
	case SOAP_TYPE_stidList:
		return ((stidList *)ptr)->soap_out(soap, tag, id, "ns1:stid");
	case SOAP_TYPE_userFeedBroadcasts:
		return ((userFeedBroadcasts *)ptr)->soap_out(soap, tag, id, "ns1:userFeedBroadcast");
	case SOAP_TYPE_ns1__userFeedBroadcast:
		return ((ns1__userFeedBroadcast *)ptr)->soap_out(soap, tag, id, "ns1:userFeedBroadcast");
	case SOAP_TYPE_ns1__authInfo:
		return ((ns1__authInfo *)ptr)->soap_out(soap, tag, id, "ns1:authInfo");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_SOAP_ENC__Array:
		return ((SOAP_ENC__Array *)ptr)->soap_out(soap, tag, id, "SOAP-ENC:Array");
	case SOAP_TYPE_ns1__getUserFeedBroadcasts:
		return soap_out_ns1__getUserFeedBroadcasts(soap, tag, id, (const struct ns1__getUserFeedBroadcasts *)ptr, "ns1:getUserFeedBroadcasts");
	case SOAP_TYPE_ns1__getUserFeedBroadcastsResponse:
		return soap_out_ns1__getUserFeedBroadcastsResponse(soap, tag, id, (const struct ns1__getUserFeedBroadcastsResponse *)ptr, "ns1:getUserFeedBroadcastsResponse");
	case SOAP_TYPE_ns1__getUserData:
		return soap_out_ns1__getUserData(soap, tag, id, (const struct ns1__getUserData *)ptr, "ns1:getUserData");
	case SOAP_TYPE_ns1__getUserDataResponse:
		return soap_out_ns1__getUserDataResponse(soap, tag, id, (const struct ns1__getUserDataResponse *)ptr, "ns1:getUserDataResponse");
	case SOAP_TYPE_ns1__fccGetProxCallsigns:
		return soap_out_ns1__fccGetProxCallsigns(soap, tag, id, (const struct ns1__fccGetProxCallsigns *)ptr, "ns1:fccGetProxCallsigns");
	case SOAP_TYPE_ns1__fccGetProxCallsignsResponse:
		return soap_out_ns1__fccGetProxCallsignsResponse(soap, tag, id, (const struct ns1__fccGetProxCallsignsResponse *)ptr, "ns1:fccGetProxCallsignsResponse");
	case SOAP_TYPE_ns1__fccGetRadioServiceCode:
		return soap_out_ns1__fccGetRadioServiceCode(soap, tag, id, (const struct ns1__fccGetRadioServiceCode *)ptr, "ns1:fccGetRadioServiceCode");
	case SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse:
		return soap_out_ns1__fccGetRadioServiceCodeResponse(soap, tag, id, (const struct ns1__fccGetRadioServiceCodeResponse *)ptr, "ns1:fccGetRadioServiceCodeResponse");
	case SOAP_TYPE_ns1__fccGetCallsign:
		return soap_out_ns1__fccGetCallsign(soap, tag, id, (const struct ns1__fccGetCallsign *)ptr, "ns1:fccGetCallsign");
	case SOAP_TYPE_ns1__fccGetCallsignResponse:
		return soap_out_ns1__fccGetCallsignResponse(soap, tag, id, (const struct ns1__fccGetCallsignResponse *)ptr, "ns1:fccGetCallsignResponse");
	case SOAP_TYPE_ns1__getZipcodeInfo:
		return soap_out_ns1__getZipcodeInfo(soap, tag, id, (const struct ns1__getZipcodeInfo *)ptr, "ns1:getZipcodeInfo");
	case SOAP_TYPE_ns1__getZipcodeInfoResponse:
		return soap_out_ns1__getZipcodeInfoResponse(soap, tag, id, (const struct ns1__getZipcodeInfoResponse *)ptr, "ns1:getZipcodeInfoResponse");
	case SOAP_TYPE_ns1__getMetroAreaInfo:
		return soap_out_ns1__getMetroAreaInfo(soap, tag, id, (const struct ns1__getMetroAreaInfo *)ptr, "ns1:getMetroAreaInfo");
	case SOAP_TYPE_ns1__getMetroAreaInfoResponse:
		return soap_out_ns1__getMetroAreaInfoResponse(soap, tag, id, (const struct ns1__getMetroAreaInfoResponse *)ptr, "ns1:getMetroAreaInfoResponse");
	case SOAP_TYPE_ns1__getMetroArea:
		return soap_out_ns1__getMetroArea(soap, tag, id, (const struct ns1__getMetroArea *)ptr, "ns1:getMetroArea");
	case SOAP_TYPE_ns1__getMetroAreaResponse:
		return soap_out_ns1__getMetroAreaResponse(soap, tag, id, (const struct ns1__getMetroAreaResponse *)ptr, "ns1:getMetroAreaResponse");
	case SOAP_TYPE_ns1__getAgencyFreqsByTag:
		return soap_out_ns1__getAgencyFreqsByTag(soap, tag, id, (const struct ns1__getAgencyFreqsByTag *)ptr, "ns1:getAgencyFreqsByTag");
	case SOAP_TYPE_ns1__getAgencyFreqsByTagResponse:
		return soap_out_ns1__getAgencyFreqsByTagResponse(soap, tag, id, (const struct ns1__getAgencyFreqsByTagResponse *)ptr, "ns1:getAgencyFreqsByTagResponse");
	case SOAP_TYPE_ns1__getCountyFreqsByTag:
		return soap_out_ns1__getCountyFreqsByTag(soap, tag, id, (const struct ns1__getCountyFreqsByTag *)ptr, "ns1:getCountyFreqsByTag");
	case SOAP_TYPE_ns1__getCountyFreqsByTagResponse:
		return soap_out_ns1__getCountyFreqsByTagResponse(soap, tag, id, (const struct ns1__getCountyFreqsByTagResponse *)ptr, "ns1:getCountyFreqsByTagResponse");
	case SOAP_TYPE_ns1__searchMetroFreq:
		return soap_out_ns1__searchMetroFreq(soap, tag, id, (const struct ns1__searchMetroFreq *)ptr, "ns1:searchMetroFreq");
	case SOAP_TYPE_ns1__searchMetroFreqResponse:
		return soap_out_ns1__searchMetroFreqResponse(soap, tag, id, (const struct ns1__searchMetroFreqResponse *)ptr, "ns1:searchMetroFreqResponse");
	case SOAP_TYPE_ns1__searchStateFreq:
		return soap_out_ns1__searchStateFreq(soap, tag, id, (const struct ns1__searchStateFreq *)ptr, "ns1:searchStateFreq");
	case SOAP_TYPE_ns1__searchStateFreqResponse:
		return soap_out_ns1__searchStateFreqResponse(soap, tag, id, (const struct ns1__searchStateFreqResponse *)ptr, "ns1:searchStateFreqResponse");
	case SOAP_TYPE_ns1__searchCountyFreq:
		return soap_out_ns1__searchCountyFreq(soap, tag, id, (const struct ns1__searchCountyFreq *)ptr, "ns1:searchCountyFreq");
	case SOAP_TYPE_ns1__searchCountyFreqResponse:
		return soap_out_ns1__searchCountyFreqResponse(soap, tag, id, (const struct ns1__searchCountyFreqResponse *)ptr, "ns1:searchCountyFreqResponse");
	case SOAP_TYPE_ns1__getSubcatFreqs:
		return soap_out_ns1__getSubcatFreqs(soap, tag, id, (const struct ns1__getSubcatFreqs *)ptr, "ns1:getSubcatFreqs");
	case SOAP_TYPE_ns1__getSubcatFreqsResponse:
		return soap_out_ns1__getSubcatFreqsResponse(soap, tag, id, (const struct ns1__getSubcatFreqsResponse *)ptr, "ns1:getSubcatFreqsResponse");
	case SOAP_TYPE_ns1__getAgencyInfo:
		return soap_out_ns1__getAgencyInfo(soap, tag, id, (const struct ns1__getAgencyInfo *)ptr, "ns1:getAgencyInfo");
	case SOAP_TYPE_ns1__getAgencyInfoResponse:
		return soap_out_ns1__getAgencyInfoResponse(soap, tag, id, (const struct ns1__getAgencyInfoResponse *)ptr, "ns1:getAgencyInfoResponse");
	case SOAP_TYPE_ns1__getCountyInfo:
		return soap_out_ns1__getCountyInfo(soap, tag, id, (const struct ns1__getCountyInfo *)ptr, "ns1:getCountyInfo");
	case SOAP_TYPE_ns1__getCountyInfoResponse:
		return soap_out_ns1__getCountyInfoResponse(soap, tag, id, (const struct ns1__getCountyInfoResponse *)ptr, "ns1:getCountyInfoResponse");
	case SOAP_TYPE_ns1__getStateInfo:
		return soap_out_ns1__getStateInfo(soap, tag, id, (const struct ns1__getStateInfo *)ptr, "ns1:getStateInfo");
	case SOAP_TYPE_ns1__getStateInfoResponse:
		return soap_out_ns1__getStateInfoResponse(soap, tag, id, (const struct ns1__getStateInfoResponse *)ptr, "ns1:getStateInfoResponse");
	case SOAP_TYPE_ns1__getCountryInfo:
		return soap_out_ns1__getCountryInfo(soap, tag, id, (const struct ns1__getCountryInfo *)ptr, "ns1:getCountryInfo");
	case SOAP_TYPE_ns1__getCountryInfoResponse:
		return soap_out_ns1__getCountryInfoResponse(soap, tag, id, (const struct ns1__getCountryInfoResponse *)ptr, "ns1:getCountryInfoResponse");
	case SOAP_TYPE_ns1__getCountryList:
		return soap_out_ns1__getCountryList(soap, tag, id, (const struct ns1__getCountryList *)ptr, "ns1:getCountryList");
	case SOAP_TYPE_ns1__getCountryListResponse:
		return soap_out_ns1__getCountryListResponse(soap, tag, id, (const struct ns1__getCountryListResponse *)ptr, "ns1:getCountryListResponse");
	case SOAP_TYPE_ns1__getTrsVoice:
		return soap_out_ns1__getTrsVoice(soap, tag, id, (const struct ns1__getTrsVoice *)ptr, "ns1:getTrsVoice");
	case SOAP_TYPE_ns1__getTrsVoiceResponse:
		return soap_out_ns1__getTrsVoiceResponse(soap, tag, id, (const struct ns1__getTrsVoiceResponse *)ptr, "ns1:getTrsVoiceResponse");
	case SOAP_TYPE_ns1__getTrsFlavor:
		return soap_out_ns1__getTrsFlavor(soap, tag, id, (const struct ns1__getTrsFlavor *)ptr, "ns1:getTrsFlavor");
	case SOAP_TYPE_ns1__getTrsFlavorResponse:
		return soap_out_ns1__getTrsFlavorResponse(soap, tag, id, (const struct ns1__getTrsFlavorResponse *)ptr, "ns1:getTrsFlavorResponse");
	case SOAP_TYPE_ns1__getTrsType:
		return soap_out_ns1__getTrsType(soap, tag, id, (const struct ns1__getTrsType *)ptr, "ns1:getTrsType");
	case SOAP_TYPE_ns1__getTrsTypeResponse:
		return soap_out_ns1__getTrsTypeResponse(soap, tag, id, (const struct ns1__getTrsTypeResponse *)ptr, "ns1:getTrsTypeResponse");
	case SOAP_TYPE_ns1__getMode:
		return soap_out_ns1__getMode(soap, tag, id, (const struct ns1__getMode *)ptr, "ns1:getMode");
	case SOAP_TYPE_ns1__getModeResponse:
		return soap_out_ns1__getModeResponse(soap, tag, id, (const struct ns1__getModeResponse *)ptr, "ns1:getModeResponse");
	case SOAP_TYPE_ns1__getTag:
		return soap_out_ns1__getTag(soap, tag, id, (const struct ns1__getTag *)ptr, "ns1:getTag");
	case SOAP_TYPE_ns1__getTagResponse:
		return soap_out_ns1__getTagResponse(soap, tag, id, (const struct ns1__getTagResponse *)ptr, "ns1:getTagResponse");
	case SOAP_TYPE_ns1__getCountiesByList:
		return soap_out_ns1__getCountiesByList(soap, tag, id, (const struct ns1__getCountiesByList *)ptr, "ns1:getCountiesByList");
	case SOAP_TYPE_ns1__getCountiesByListResponse:
		return soap_out_ns1__getCountiesByListResponse(soap, tag, id, (const struct ns1__getCountiesByListResponse *)ptr, "ns1:getCountiesByListResponse");
	case SOAP_TYPE_ns1__getStatesByList:
		return soap_out_ns1__getStatesByList(soap, tag, id, (const struct ns1__getStatesByList *)ptr, "ns1:getStatesByList");
	case SOAP_TYPE_ns1__getStatesByListResponse:
		return soap_out_ns1__getStatesByListResponse(soap, tag, id, (const struct ns1__getStatesByListResponse *)ptr, "ns1:getStatesByListResponse");
	case SOAP_TYPE_ns1__getTrsSites:
		return soap_out_ns1__getTrsSites(soap, tag, id, (const struct ns1__getTrsSites *)ptr, "ns1:getTrsSites");
	case SOAP_TYPE_ns1__getTrsSitesResponse:
		return soap_out_ns1__getTrsSitesResponse(soap, tag, id, (const struct ns1__getTrsSitesResponse *)ptr, "ns1:getTrsSitesResponse");
	case SOAP_TYPE_ns1__getTrsBySysid:
		return soap_out_ns1__getTrsBySysid(soap, tag, id, (const struct ns1__getTrsBySysid *)ptr, "ns1:getTrsBySysid");
	case SOAP_TYPE_ns1__getTrsBySysidResponse:
		return soap_out_ns1__getTrsBySysidResponse(soap, tag, id, (const struct ns1__getTrsBySysidResponse *)ptr, "ns1:getTrsBySysidResponse");
	case SOAP_TYPE_ns1__getTrsDetails:
		return soap_out_ns1__getTrsDetails(soap, tag, id, (const struct ns1__getTrsDetails *)ptr, "ns1:getTrsDetails");
	case SOAP_TYPE_ns1__getTrsDetailsResponse:
		return soap_out_ns1__getTrsDetailsResponse(soap, tag, id, (const struct ns1__getTrsDetailsResponse *)ptr, "ns1:getTrsDetailsResponse");
	case SOAP_TYPE_ns1__getTrsTalkgroupCats:
		return soap_out_ns1__getTrsTalkgroupCats(soap, tag, id, (const struct ns1__getTrsTalkgroupCats *)ptr, "ns1:getTrsTalkgroupCats");
	case SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse:
		return soap_out_ns1__getTrsTalkgroupCatsResponse(soap, tag, id, (const struct ns1__getTrsTalkgroupCatsResponse *)ptr, "ns1:getTrsTalkgroupCatsResponse");
	case SOAP_TYPE_ns1__getTrsTalkgroups:
		return soap_out_ns1__getTrsTalkgroups(soap, tag, id, (const struct ns1__getTrsTalkgroups *)ptr, "ns1:getTrsTalkgroups");
	case SOAP_TYPE_ns1__getTrsTalkgroupsResponse:
		return soap_out_ns1__getTrsTalkgroupsResponse(soap, tag, id, (const struct ns1__getTrsTalkgroupsResponse *)ptr, "ns1:getTrsTalkgroupsResponse");
	case SOAP_TYPE_PointerTouserFeedBroadcasts:
		return soap_out_PointerTouserFeedBroadcasts(soap, tag, id, (userFeedBroadcasts *const*)ptr, "ns1:userFeedBroadcast");
	case SOAP_TYPE_PointerTons1__UserInfo:
		return soap_out_PointerTons1__UserInfo(soap, tag, id, (ns1__UserInfo *const*)ptr, "ns1:UserInfo");
	case SOAP_TYPE_PointerToproxCallsignResults:
		return soap_out_PointerToproxCallsignResults(soap, tag, id, (proxCallsignResults *const*)ptr, "ns1:proxCallsignResult");
	case SOAP_TYPE_PointerTofccRadioServiceCodes:
		return soap_out_PointerTofccRadioServiceCodes(soap, tag, id, (fccRadioServiceCodes *const*)ptr, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_PointerTons1__fccCallsignDetails:
		return soap_out_PointerTons1__fccCallsignDetails(soap, tag, id, (ns1__fccCallsignDetails *const*)ptr, "ns1:fccCallsignDetails");
	case SOAP_TYPE_PointerTons1__ZipInfo:
		return soap_out_PointerTons1__ZipInfo(soap, tag, id, (ns1__ZipInfo *const*)ptr, "ns1:ZipInfo");
	case SOAP_TYPE_PointerToMetros:
		return soap_out_PointerToMetros(soap, tag, id, (Metros *const*)ptr, "ns1:Metro");
	case SOAP_TYPE_PointerTosearchFreqResults:
		return soap_out_PointerTosearchFreqResults(soap, tag, id, (searchFreqResults *const*)ptr, "ns1:searchFreqResult");
	case SOAP_TYPE_PointerToFreqs:
		return soap_out_PointerToFreqs(soap, tag, id, (Freqs *const*)ptr, "ns1:freq");
	case SOAP_TYPE_PointerTons1__AgencyInfo:
		return soap_out_PointerTons1__AgencyInfo(soap, tag, id, (ns1__AgencyInfo *const*)ptr, "ns1:AgencyInfo");
	case SOAP_TYPE_PointerTons1__CountyInfo:
		return soap_out_PointerTons1__CountyInfo(soap, tag, id, (ns1__CountyInfo *const*)ptr, "ns1:CountyInfo");
	case SOAP_TYPE_PointerTons1__StateInfo:
		return soap_out_PointerTons1__StateInfo(soap, tag, id, (ns1__StateInfo *const*)ptr, "ns1:StateInfo");
	case SOAP_TYPE_PointerTons1__CountryInfo:
		return soap_out_PointerTons1__CountryInfo(soap, tag, id, (ns1__CountryInfo *const*)ptr, "ns1:CountryInfo");
	case SOAP_TYPE_PointerToCountries:
		return soap_out_PointerToCountries(soap, tag, id, (Countries *const*)ptr, "ns1:Country");
	case SOAP_TYPE_PointerToTrsVoice:
		return soap_out_PointerToTrsVoice(soap, tag, id, (TrsVoice *const*)ptr, "ns1:trsVoiceDef");
	case SOAP_TYPE_PointerToTrsFlavor:
		return soap_out_PointerToTrsFlavor(soap, tag, id, (TrsFlavor *const*)ptr, "ns1:trsFlavorDef");
	case SOAP_TYPE_PointerToTrsType:
		return soap_out_PointerToTrsType(soap, tag, id, (TrsType *const*)ptr, "ns1:trsTypeDef");
	case SOAP_TYPE_PointerTomodes:
		return soap_out_PointerTomodes(soap, tag, id, (modes *const*)ptr, "ns1:mode");
	case SOAP_TYPE_PointerToctidList:
		return soap_out_PointerToctidList(soap, tag, id, (ctidList *const*)ptr, "ns1:ctid");
	case SOAP_TYPE_PointerTostidList:
		return soap_out_PointerTostidList(soap, tag, id, (stidList *const*)ptr, "ns1:stid");
	case SOAP_TYPE_PointerToTrsSites:
		return soap_out_PointerToTrsSites(soap, tag, id, (TrsSites *const*)ptr, "ns1:TrsSite");
	case SOAP_TYPE_PointerTons1__Trs:
		return soap_out_PointerTons1__Trs(soap, tag, id, (ns1__Trs *const*)ptr, "ns1:Trs");
	case SOAP_TYPE_PointerToTalkgroupCats:
		return soap_out_PointerToTalkgroupCats(soap, tag, id, (TalkgroupCats *const*)ptr, "ns1:TalkgroupCat");
	case SOAP_TYPE_PointerTons1__authInfo:
		return soap_out_PointerTons1__authInfo(soap, tag, id, (ns1__authInfo *const*)ptr, "ns1:authInfo");
	case SOAP_TYPE_PointerToTalkgroups:
		return soap_out_PointerToTalkgroups(soap, tag, id, (Talkgroups *const*)ptr, "ns1:Talkgroup");
	case SOAP_TYPE_PointerToPointerTons1__fccRadioServiceCode:
		return soap_out_PointerToPointerTons1__fccRadioServiceCode(soap, tag, id, (ns1__fccRadioServiceCode **const*)ptr, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_PointerTons1__fccRadioServiceCode:
		return soap_out_PointerTons1__fccRadioServiceCode(soap, tag, id, (ns1__fccRadioServiceCode *const*)ptr, "ns1:fccRadioServiceCode");
	case SOAP_TYPE_PointerToPointerTons1__proxCallsignResult:
		return soap_out_PointerToPointerTons1__proxCallsignResult(soap, tag, id, (ns1__proxCallsignResult **const*)ptr, "ns1:proxCallsignResult");
	case SOAP_TYPE_PointerTons1__proxCallsignResult:
		return soap_out_PointerTons1__proxCallsignResult(soap, tag, id, (ns1__proxCallsignResult *const*)ptr, "ns1:proxCallsignResult");
	case SOAP_TYPE_PointerToPointerTons1__fccLocation:
		return soap_out_PointerToPointerTons1__fccLocation(soap, tag, id, (ns1__fccLocation **const*)ptr, "ns1:fccLocation");
	case SOAP_TYPE_PointerTons1__fccLocation:
		return soap_out_PointerTons1__fccLocation(soap, tag, id, (ns1__fccLocation *const*)ptr, "ns1:fccLocation");
	case SOAP_TYPE_PointerToPointerTons1__fccFrequency:
		return soap_out_PointerToPointerTons1__fccFrequency(soap, tag, id, (ns1__fccFrequency **const*)ptr, "ns1:fccFrequency");
	case SOAP_TYPE_PointerTons1__fccFrequency:
		return soap_out_PointerTons1__fccFrequency(soap, tag, id, (ns1__fccFrequency *const*)ptr, "ns1:fccFrequency");
	case SOAP_TYPE_PointerToPointerTons1__mode:
		return soap_out_PointerToPointerTons1__mode(soap, tag, id, (ns1__mode **const*)ptr, "ns1:mode");
	case SOAP_TYPE_PointerTons1__mode:
		return soap_out_PointerTons1__mode(soap, tag, id, (ns1__mode *const*)ptr, "ns1:mode");
	case SOAP_TYPE_PointerToPointerTons1__tag:
		return soap_out_PointerToPointerTons1__tag(soap, tag, id, (ns1__tag **const*)ptr, "ns1:tag");
	case SOAP_TYPE_PointerTons1__tag:
		return soap_out_PointerTons1__tag(soap, tag, id, (ns1__tag *const*)ptr, "ns1:tag");
	case SOAP_TYPE_PointerToPointerTons1__sid:
		return soap_out_PointerToPointerTons1__sid(soap, tag, id, (ns1__sid **const*)ptr, "ns1:sid");
	case SOAP_TYPE_PointerTons1__sid:
		return soap_out_PointerTons1__sid(soap, tag, id, (ns1__sid *const*)ptr, "ns1:sid");
	case SOAP_TYPE_PointerToPointerTons1__Agency:
		return soap_out_PointerToPointerTons1__Agency(soap, tag, id, (ns1__Agency **const*)ptr, "ns1:Agency");
	case SOAP_TYPE_PointerTons1__Agency:
		return soap_out_PointerTons1__Agency(soap, tag, id, (ns1__Agency *const*)ptr, "ns1:Agency");
	case SOAP_TYPE_PointerToPointerTons1__Country:
		return soap_out_PointerToPointerTons1__Country(soap, tag, id, (ns1__Country **const*)ptr, "ns1:Country");
	case SOAP_TYPE_PointerTons1__Country:
		return soap_out_PointerTons1__Country(soap, tag, id, (ns1__Country *const*)ptr, "ns1:Country");
	case SOAP_TYPE_PointerToPointerTons1__Metro:
		return soap_out_PointerToPointerTons1__Metro(soap, tag, id, (ns1__Metro **const*)ptr, "ns1:Metro");
	case SOAP_TYPE_PointerTons1__Metro:
		return soap_out_PointerTons1__Metro(soap, tag, id, (ns1__Metro *const*)ptr, "ns1:Metro");
	case SOAP_TYPE_PointerToPointerTons1__State:
		return soap_out_PointerToPointerTons1__State(soap, tag, id, (ns1__State **const*)ptr, "ns1:State");
	case SOAP_TYPE_PointerTons1__State:
		return soap_out_PointerTons1__State(soap, tag, id, (ns1__State *const*)ptr, "ns1:State");
	case SOAP_TYPE_PointerToPointerTons1__County:
		return soap_out_PointerToPointerTons1__County(soap, tag, id, (ns1__County **const*)ptr, "ns1:County");
	case SOAP_TYPE_PointerTons1__County:
		return soap_out_PointerTons1__County(soap, tag, id, (ns1__County *const*)ptr, "ns1:County");
	case SOAP_TYPE_PointerToPointerTons1__subcat:
		return soap_out_PointerToPointerTons1__subcat(soap, tag, id, (ns1__subcat **const*)ptr, "ns1:subcat");
	case SOAP_TYPE_PointerTons1__subcat:
		return soap_out_PointerTons1__subcat(soap, tag, id, (ns1__subcat *const*)ptr, "ns1:subcat");
	case SOAP_TYPE_PointerToPointerTons1__cat:
		return soap_out_PointerToPointerTons1__cat(soap, tag, id, (ns1__cat **const*)ptr, "ns1:cat");
	case SOAP_TYPE_PointerTons1__cat:
		return soap_out_PointerTons1__cat(soap, tag, id, (ns1__cat *const*)ptr, "ns1:cat");
	case SOAP_TYPE_PointerToPointerTons1__freq:
		return soap_out_PointerToPointerTons1__freq(soap, tag, id, (ns1__freq **const*)ptr, "ns1:freq");
	case SOAP_TYPE_PointerTons1__freq:
		return soap_out_PointerTons1__freq(soap, tag, id, (ns1__freq *const*)ptr, "ns1:freq");
	case SOAP_TYPE_PointerToPointerTons1__searchFreqResult:
		return soap_out_PointerToPointerTons1__searchFreqResult(soap, tag, id, (ns1__searchFreqResult **const*)ptr, "ns1:searchFreqResult");
	case SOAP_TYPE_PointerTons1__searchFreqResult:
		return soap_out_PointerTons1__searchFreqResult(soap, tag, id, (ns1__searchFreqResult *const*)ptr, "ns1:searchFreqResult");
	case SOAP_TYPE_PointerToPointerTons1__trsVoiceDef:
		return soap_out_PointerToPointerTons1__trsVoiceDef(soap, tag, id, (ns1__trsVoiceDef **const*)ptr, "ns1:trsVoiceDef");
	case SOAP_TYPE_PointerTons1__trsVoiceDef:
		return soap_out_PointerTons1__trsVoiceDef(soap, tag, id, (ns1__trsVoiceDef *const*)ptr, "ns1:trsVoiceDef");
	case SOAP_TYPE_PointerToPointerTons1__trsFlavorDef:
		return soap_out_PointerToPointerTons1__trsFlavorDef(soap, tag, id, (ns1__trsFlavorDef **const*)ptr, "ns1:trsFlavorDef");
	case SOAP_TYPE_PointerTons1__trsFlavorDef:
		return soap_out_PointerTons1__trsFlavorDef(soap, tag, id, (ns1__trsFlavorDef *const*)ptr, "ns1:trsFlavorDef");
	case SOAP_TYPE_PointerToPointerTons1__trsTypeDef:
		return soap_out_PointerToPointerTons1__trsTypeDef(soap, tag, id, (ns1__trsTypeDef **const*)ptr, "ns1:trsTypeDef");
	case SOAP_TYPE_PointerTons1__trsTypeDef:
		return soap_out_PointerTons1__trsTypeDef(soap, tag, id, (ns1__trsTypeDef *const*)ptr, "ns1:trsTypeDef");
	case SOAP_TYPE_PointerToPointerTons1__trsBandplanDef:
		return soap_out_PointerToPointerTons1__trsBandplanDef(soap, tag, id, (ns1__trsBandplanDef **const*)ptr, "ns1:trsBandplanDef");
	case SOAP_TYPE_PointerTons1__trsBandplanDef:
		return soap_out_PointerTons1__trsBandplanDef(soap, tag, id, (ns1__trsBandplanDef *const*)ptr, "ns1:trsBandplanDef");
	case SOAP_TYPE_PointerToPointerTons1__trsSysidDef:
		return soap_out_PointerToPointerTons1__trsSysidDef(soap, tag, id, (ns1__trsSysidDef **const*)ptr, "ns1:trsSysidDef");
	case SOAP_TYPE_PointerTons1__trsSysidDef:
		return soap_out_PointerTons1__trsSysidDef(soap, tag, id, (ns1__trsSysidDef *const*)ptr, "ns1:trsSysidDef");
	case SOAP_TYPE_PointerToPointerTons1__TrsListDef:
		return soap_out_PointerToPointerTons1__TrsListDef(soap, tag, id, (ns1__TrsListDef **const*)ptr, "ns1:TrsListDef");
	case SOAP_TYPE_PointerTons1__TrsListDef:
		return soap_out_PointerTons1__TrsListDef(soap, tag, id, (ns1__TrsListDef *const*)ptr, "ns1:TrsListDef");
	case SOAP_TYPE_PointerToPointerTons1__TrsSiteLicense:
		return soap_out_PointerToPointerTons1__TrsSiteLicense(soap, tag, id, (ns1__TrsSiteLicense **const*)ptr, "ns1:TrsSiteLicense");
	case SOAP_TYPE_PointerTons1__TrsSiteLicense:
		return soap_out_PointerTons1__TrsSiteLicense(soap, tag, id, (ns1__TrsSiteLicense *const*)ptr, "ns1:TrsSiteLicense");
	case SOAP_TYPE_PointerToPointerTons1__TrsSiteFreq:
		return soap_out_PointerToPointerTons1__TrsSiteFreq(soap, tag, id, (ns1__TrsSiteFreq **const*)ptr, "ns1:TrsSiteFreq");
	case SOAP_TYPE_PointerTons1__TrsSiteFreq:
		return soap_out_PointerTons1__TrsSiteFreq(soap, tag, id, (ns1__TrsSiteFreq *const*)ptr, "ns1:TrsSiteFreq");
	case SOAP_TYPE_PointerToPointerTons1__TrsSite:
		return soap_out_PointerToPointerTons1__TrsSite(soap, tag, id, (ns1__TrsSite **const*)ptr, "ns1:TrsSite");
	case SOAP_TYPE_PointerTons1__TrsSite:
		return soap_out_PointerTons1__TrsSite(soap, tag, id, (ns1__TrsSite *const*)ptr, "ns1:TrsSite");
	case SOAP_TYPE_PointerToPointerTons1__TalkgroupCat:
		return soap_out_PointerToPointerTons1__TalkgroupCat(soap, tag, id, (ns1__TalkgroupCat **const*)ptr, "ns1:TalkgroupCat");
	case SOAP_TYPE_PointerTons1__TalkgroupCat:
		return soap_out_PointerTons1__TalkgroupCat(soap, tag, id, (ns1__TalkgroupCat *const*)ptr, "ns1:TalkgroupCat");
	case SOAP_TYPE_PointerToPointerTons1__Talkgroup:
		return soap_out_PointerToPointerTons1__Talkgroup(soap, tag, id, (ns1__Talkgroup **const*)ptr, "ns1:Talkgroup");
	case SOAP_TYPE_PointerTons1__Talkgroup:
		return soap_out_PointerTons1__Talkgroup(soap, tag, id, (ns1__Talkgroup *const*)ptr, "ns1:Talkgroup");
	case SOAP_TYPE_PointerToPointerTons1__ctid:
		return soap_out_PointerToPointerTons1__ctid(soap, tag, id, (ns1__ctid **const*)ptr, "ns1:ctid");
	case SOAP_TYPE_PointerTons1__ctid:
		return soap_out_PointerTons1__ctid(soap, tag, id, (ns1__ctid *const*)ptr, "ns1:ctid");
	case SOAP_TYPE_PointerToPointerTons1__stid:
		return soap_out_PointerToPointerTons1__stid(soap, tag, id, (ns1__stid **const*)ptr, "ns1:stid");
	case SOAP_TYPE_PointerTons1__stid:
		return soap_out_PointerTons1__stid(soap, tag, id, (ns1__stid *const*)ptr, "ns1:stid");
	case SOAP_TYPE_PointerToPointerTons1__userFeedBroadcast:
		return soap_out_PointerToPointerTons1__userFeedBroadcast(soap, tag, id, (ns1__userFeedBroadcast **const*)ptr, "ns1:userFeedBroadcast");
	case SOAP_TYPE_PointerTons1__userFeedBroadcast:
		return soap_out_PointerTons1__userFeedBroadcast(soap, tag, id, (ns1__userFeedBroadcast *const*)ptr, "ns1:userFeedBroadcast");
	case SOAP_TYPE_PointerTofccFrequencies:
		return soap_out_PointerTofccFrequencies(soap, tag, id, (fccFrequencies *const*)ptr, "ns1:fccFrequency");
	case SOAP_TYPE_PointerTofccLocations:
		return soap_out_PointerTofccLocations(soap, tag, id, (fccLocations *const*)ptr, "ns1:fccLocation");
	case SOAP_TYPE_PointerToCounties:
		return soap_out_PointerToCounties(soap, tag, id, (Counties *const*)ptr, "ns1:County");
	case SOAP_TYPE_PointerToTrsList:
		return soap_out_PointerToTrsList(soap, tag, id, (TrsList *const*)ptr, "ns1:TrsListDef");
	case SOAP_TYPE_PointerToStates:
		return soap_out_PointerToStates(soap, tag, id, (States *const*)ptr, "ns1:State");
	case SOAP_TYPE_PointerToAgencies:
		return soap_out_PointerToAgencies(soap, tag, id, (Agencies *const*)ptr, "ns1:Agency");
	case SOAP_TYPE_PointerToCats:
		return soap_out_PointerToCats(soap, tag, id, (Cats *const*)ptr, "ns1:cat");
	case SOAP_TYPE_PointerTosids:
		return soap_out_PointerTosids(soap, tag, id, (sids *const*)ptr, "ns1:sid");
	case SOAP_TYPE_PointerToSubCats:
		return soap_out_PointerToSubCats(soap, tag, id, (SubCats *const*)ptr, "ns1:subcat");
	case SOAP_TYPE_PointerTons1__TrsFleetmap:
		return soap_out_PointerTons1__TrsFleetmap(soap, tag, id, (ns1__TrsFleetmap *const*)ptr, "ns1:TrsFleetmap");
	case SOAP_TYPE_PointerToTrsSysid:
		return soap_out_PointerToTrsSysid(soap, tag, id, (TrsSysid *const*)ptr, "ns1:trsSysidDef");
	case SOAP_TYPE_PointerTostids:
		return soap_out_PointerTostids(soap, tag, id, (stids *const*)ptr, "ns1:stid");
	case SOAP_TYPE_PointerToctids:
		return soap_out_PointerToctids(soap, tag, id, (ctids *const*)ptr, "ns1:ctid");
	case SOAP_TYPE_PointerToTrsBandplan:
		return soap_out_PointerToTrsBandplan(soap, tag, id, (TrsBandplan *const*)ptr, "ns1:trsBandplanDef");
	case SOAP_TYPE_PointerToTrsSiteFreqs:
		return soap_out_PointerToTrsSiteFreqs(soap, tag, id, (TrsSiteFreqs *const*)ptr, "ns1:TrsSiteFreq");
	case SOAP_TYPE_PointerToTrsSiteLicenses:
		return soap_out_PointerToTrsSiteLicenses(soap, tag, id, (TrsSiteLicenses *const*)ptr, "ns1:TrsSiteLicense");
	case SOAP_TYPE_PointerTotags:
		return soap_out_PointerTotags(soap, tag, id, (tags *const*)ptr, "ns1:tag");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in rrapi_C.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_fccRadioServiceCodes:
		((fccRadioServiceCodes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fccRadioServiceCode:
		((ns1__fccRadioServiceCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_proxCallsignResults:
		((proxCallsignResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__proxCallsignResult:
		((ns1__proxCallsignResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fccLocations:
		((fccLocations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fccLocation:
		((ns1__fccLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_fccFrequencies:
		((fccFrequencies *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fccFrequency:
		((ns1__fccFrequency *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fccCallsignDetails:
		((ns1__fccCallsignDetails *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserInfo:
		((ns1__UserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ZipInfo:
		((ns1__ZipInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__mode:
		((ns1__mode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_modes:
		((modes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__tag:
		((ns1__tag *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tags:
		((tags *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sid:
		((ns1__sid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_sids:
		((sids *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__stid:
		((ns1__stid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_stids:
		((stids *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Agency:
		((ns1__Agency *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Agencies:
		((Agencies *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Country:
		((ns1__Country *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Countries:
		((Countries *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Metro:
		((ns1__Metro *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Metros:
		((Metros *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__State:
		((ns1__State *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_States:
		((States *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ctid:
		((ns1__ctid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ctids:
		((ctids *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Counties:
		((Counties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__County:
		((ns1__County *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StateInfo:
		((ns1__StateInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CountyInfo:
		((ns1__CountyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CountryInfo:
		((ns1__CountryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AgencyInfo:
		((ns1__AgencyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__subcat:
		((ns1__subcat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_SubCats:
		((SubCats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cat:
		((ns1__cat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Cats:
		((Cats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Freqs:
		((Freqs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_searchFreqResults:
		((searchFreqResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__searchFreqResult:
		((ns1__searchFreqResult *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__freq:
		((ns1__freq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsVoice:
		((TrsVoice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__trsVoiceDef:
		((ns1__trsVoiceDef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsFlavor:
		((TrsFlavor *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__trsFlavorDef:
		((ns1__trsFlavorDef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsType:
		((TrsType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__trsTypeDef:
		((ns1__trsTypeDef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TrsFleetmap:
		((ns1__TrsFleetmap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsBandplan:
		((TrsBandplan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__trsBandplanDef:
		((ns1__trsBandplanDef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsSysid:
		((TrsSysid *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__trsSysidDef:
		((ns1__trsSysidDef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsList:
		((TrsList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TrsListDef:
		((ns1__TrsListDef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Trs:
		((ns1__Trs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsSiteLicenses:
		((TrsSiteLicenses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TrsSiteLicense:
		((ns1__TrsSiteLicense *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsSiteFreqs:
		((TrsSiteFreqs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TrsSiteFreq:
		((ns1__TrsSiteFreq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TrsSites:
		((TrsSites *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TrsSite:
		((ns1__TrsSite *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_TalkgroupCats:
		((TalkgroupCats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TalkgroupCat:
		((ns1__TalkgroupCat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Talkgroups:
		((Talkgroups *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Talkgroup:
		((ns1__Talkgroup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ctidList:
		((ctidList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_stidList:
		((stidList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_userFeedBroadcasts:
		((userFeedBroadcasts *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__userFeedBroadcast:
		((ns1__userFeedBroadcast *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__authInfo:
		((ns1__authInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENC__Array:
		((SOAP_ENC__Array *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getUserFeedBroadcasts:
		soap_serialize_ns1__getUserFeedBroadcasts(soap, (const struct ns1__getUserFeedBroadcasts *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserFeedBroadcastsResponse:
		soap_serialize_ns1__getUserFeedBroadcastsResponse(soap, (const struct ns1__getUserFeedBroadcastsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserData:
		soap_serialize_ns1__getUserData(soap, (const struct ns1__getUserData *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserDataResponse:
		soap_serialize_ns1__getUserDataResponse(soap, (const struct ns1__getUserDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__fccGetProxCallsigns:
		soap_serialize_ns1__fccGetProxCallsigns(soap, (const struct ns1__fccGetProxCallsigns *)ptr);
		break;
	case SOAP_TYPE_ns1__fccGetProxCallsignsResponse:
		soap_serialize_ns1__fccGetProxCallsignsResponse(soap, (const struct ns1__fccGetProxCallsignsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__fccGetRadioServiceCode:
		soap_serialize_ns1__fccGetRadioServiceCode(soap, (const struct ns1__fccGetRadioServiceCode *)ptr);
		break;
	case SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse:
		soap_serialize_ns1__fccGetRadioServiceCodeResponse(soap, (const struct ns1__fccGetRadioServiceCodeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__fccGetCallsign:
		soap_serialize_ns1__fccGetCallsign(soap, (const struct ns1__fccGetCallsign *)ptr);
		break;
	case SOAP_TYPE_ns1__fccGetCallsignResponse:
		soap_serialize_ns1__fccGetCallsignResponse(soap, (const struct ns1__fccGetCallsignResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getZipcodeInfo:
		soap_serialize_ns1__getZipcodeInfo(soap, (const struct ns1__getZipcodeInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getZipcodeInfoResponse:
		soap_serialize_ns1__getZipcodeInfoResponse(soap, (const struct ns1__getZipcodeInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getMetroAreaInfo:
		soap_serialize_ns1__getMetroAreaInfo(soap, (const struct ns1__getMetroAreaInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getMetroAreaInfoResponse:
		soap_serialize_ns1__getMetroAreaInfoResponse(soap, (const struct ns1__getMetroAreaInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getMetroArea:
		soap_serialize_ns1__getMetroArea(soap, (const struct ns1__getMetroArea *)ptr);
		break;
	case SOAP_TYPE_ns1__getMetroAreaResponse:
		soap_serialize_ns1__getMetroAreaResponse(soap, (const struct ns1__getMetroAreaResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAgencyFreqsByTag:
		soap_serialize_ns1__getAgencyFreqsByTag(soap, (const struct ns1__getAgencyFreqsByTag *)ptr);
		break;
	case SOAP_TYPE_ns1__getAgencyFreqsByTagResponse:
		soap_serialize_ns1__getAgencyFreqsByTagResponse(soap, (const struct ns1__getAgencyFreqsByTagResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountyFreqsByTag:
		soap_serialize_ns1__getCountyFreqsByTag(soap, (const struct ns1__getCountyFreqsByTag *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountyFreqsByTagResponse:
		soap_serialize_ns1__getCountyFreqsByTagResponse(soap, (const struct ns1__getCountyFreqsByTagResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__searchMetroFreq:
		soap_serialize_ns1__searchMetroFreq(soap, (const struct ns1__searchMetroFreq *)ptr);
		break;
	case SOAP_TYPE_ns1__searchMetroFreqResponse:
		soap_serialize_ns1__searchMetroFreqResponse(soap, (const struct ns1__searchMetroFreqResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__searchStateFreq:
		soap_serialize_ns1__searchStateFreq(soap, (const struct ns1__searchStateFreq *)ptr);
		break;
	case SOAP_TYPE_ns1__searchStateFreqResponse:
		soap_serialize_ns1__searchStateFreqResponse(soap, (const struct ns1__searchStateFreqResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__searchCountyFreq:
		soap_serialize_ns1__searchCountyFreq(soap, (const struct ns1__searchCountyFreq *)ptr);
		break;
	case SOAP_TYPE_ns1__searchCountyFreqResponse:
		soap_serialize_ns1__searchCountyFreqResponse(soap, (const struct ns1__searchCountyFreqResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getSubcatFreqs:
		soap_serialize_ns1__getSubcatFreqs(soap, (const struct ns1__getSubcatFreqs *)ptr);
		break;
	case SOAP_TYPE_ns1__getSubcatFreqsResponse:
		soap_serialize_ns1__getSubcatFreqsResponse(soap, (const struct ns1__getSubcatFreqsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAgencyInfo:
		soap_serialize_ns1__getAgencyInfo(soap, (const struct ns1__getAgencyInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getAgencyInfoResponse:
		soap_serialize_ns1__getAgencyInfoResponse(soap, (const struct ns1__getAgencyInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountyInfo:
		soap_serialize_ns1__getCountyInfo(soap, (const struct ns1__getCountyInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountyInfoResponse:
		soap_serialize_ns1__getCountyInfoResponse(soap, (const struct ns1__getCountyInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getStateInfo:
		soap_serialize_ns1__getStateInfo(soap, (const struct ns1__getStateInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getStateInfoResponse:
		soap_serialize_ns1__getStateInfoResponse(soap, (const struct ns1__getStateInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountryInfo:
		soap_serialize_ns1__getCountryInfo(soap, (const struct ns1__getCountryInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountryInfoResponse:
		soap_serialize_ns1__getCountryInfoResponse(soap, (const struct ns1__getCountryInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountryList:
		soap_serialize_ns1__getCountryList(soap, (const struct ns1__getCountryList *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountryListResponse:
		soap_serialize_ns1__getCountryListResponse(soap, (const struct ns1__getCountryListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsVoice:
		soap_serialize_ns1__getTrsVoice(soap, (const struct ns1__getTrsVoice *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsVoiceResponse:
		soap_serialize_ns1__getTrsVoiceResponse(soap, (const struct ns1__getTrsVoiceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsFlavor:
		soap_serialize_ns1__getTrsFlavor(soap, (const struct ns1__getTrsFlavor *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsFlavorResponse:
		soap_serialize_ns1__getTrsFlavorResponse(soap, (const struct ns1__getTrsFlavorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsType:
		soap_serialize_ns1__getTrsType(soap, (const struct ns1__getTrsType *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsTypeResponse:
		soap_serialize_ns1__getTrsTypeResponse(soap, (const struct ns1__getTrsTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getMode:
		soap_serialize_ns1__getMode(soap, (const struct ns1__getMode *)ptr);
		break;
	case SOAP_TYPE_ns1__getModeResponse:
		soap_serialize_ns1__getModeResponse(soap, (const struct ns1__getModeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTag:
		soap_serialize_ns1__getTag(soap, (const struct ns1__getTag *)ptr);
		break;
	case SOAP_TYPE_ns1__getTagResponse:
		soap_serialize_ns1__getTagResponse(soap, (const struct ns1__getTagResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountiesByList:
		soap_serialize_ns1__getCountiesByList(soap, (const struct ns1__getCountiesByList *)ptr);
		break;
	case SOAP_TYPE_ns1__getCountiesByListResponse:
		soap_serialize_ns1__getCountiesByListResponse(soap, (const struct ns1__getCountiesByListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getStatesByList:
		soap_serialize_ns1__getStatesByList(soap, (const struct ns1__getStatesByList *)ptr);
		break;
	case SOAP_TYPE_ns1__getStatesByListResponse:
		soap_serialize_ns1__getStatesByListResponse(soap, (const struct ns1__getStatesByListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsSites:
		soap_serialize_ns1__getTrsSites(soap, (const struct ns1__getTrsSites *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsSitesResponse:
		soap_serialize_ns1__getTrsSitesResponse(soap, (const struct ns1__getTrsSitesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsBySysid:
		soap_serialize_ns1__getTrsBySysid(soap, (const struct ns1__getTrsBySysid *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsBySysidResponse:
		soap_serialize_ns1__getTrsBySysidResponse(soap, (const struct ns1__getTrsBySysidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsDetails:
		soap_serialize_ns1__getTrsDetails(soap, (const struct ns1__getTrsDetails *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsDetailsResponse:
		soap_serialize_ns1__getTrsDetailsResponse(soap, (const struct ns1__getTrsDetailsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupCats:
		soap_serialize_ns1__getTrsTalkgroupCats(soap, (const struct ns1__getTrsTalkgroupCats *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse:
		soap_serialize_ns1__getTrsTalkgroupCatsResponse(soap, (const struct ns1__getTrsTalkgroupCatsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroups:
		soap_serialize_ns1__getTrsTalkgroups(soap, (const struct ns1__getTrsTalkgroups *)ptr);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupsResponse:
		soap_serialize_ns1__getTrsTalkgroupsResponse(soap, (const struct ns1__getTrsTalkgroupsResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTouserFeedBroadcasts:
		soap_serialize_PointerTouserFeedBroadcasts(soap, (userFeedBroadcasts *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserInfo:
		soap_serialize_PointerTons1__UserInfo(soap, (ns1__UserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToproxCallsignResults:
		soap_serialize_PointerToproxCallsignResults(soap, (proxCallsignResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofccRadioServiceCodes:
		soap_serialize_PointerTofccRadioServiceCodes(soap, (fccRadioServiceCodes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fccCallsignDetails:
		soap_serialize_PointerTons1__fccCallsignDetails(soap, (ns1__fccCallsignDetails *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ZipInfo:
		soap_serialize_PointerTons1__ZipInfo(soap, (ns1__ZipInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToMetros:
		soap_serialize_PointerToMetros(soap, (Metros *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosearchFreqResults:
		soap_serialize_PointerTosearchFreqResults(soap, (searchFreqResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerToFreqs:
		soap_serialize_PointerToFreqs(soap, (Freqs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AgencyInfo:
		soap_serialize_PointerTons1__AgencyInfo(soap, (ns1__AgencyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountyInfo:
		soap_serialize_PointerTons1__CountyInfo(soap, (ns1__CountyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StateInfo:
		soap_serialize_PointerTons1__StateInfo(soap, (ns1__StateInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CountryInfo:
		soap_serialize_PointerTons1__CountryInfo(soap, (ns1__CountryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCountries:
		soap_serialize_PointerToCountries(soap, (Countries *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsVoice:
		soap_serialize_PointerToTrsVoice(soap, (TrsVoice *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsFlavor:
		soap_serialize_PointerToTrsFlavor(soap, (TrsFlavor *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsType:
		soap_serialize_PointerToTrsType(soap, (TrsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTomodes:
		soap_serialize_PointerTomodes(soap, (modes *const*)ptr);
		break;
	case SOAP_TYPE_PointerToctidList:
		soap_serialize_PointerToctidList(soap, (ctidList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostidList:
		soap_serialize_PointerTostidList(soap, (stidList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsSites:
		soap_serialize_PointerToTrsSites(soap, (TrsSites *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Trs:
		soap_serialize_PointerTons1__Trs(soap, (ns1__Trs *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTalkgroupCats:
		soap_serialize_PointerToTalkgroupCats(soap, (TalkgroupCats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__authInfo:
		soap_serialize_PointerTons1__authInfo(soap, (ns1__authInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTalkgroups:
		soap_serialize_PointerToTalkgroups(soap, (Talkgroups *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__fccRadioServiceCode:
		soap_serialize_PointerToPointerTons1__fccRadioServiceCode(soap, (ns1__fccRadioServiceCode **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fccRadioServiceCode:
		soap_serialize_PointerTons1__fccRadioServiceCode(soap, (ns1__fccRadioServiceCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__proxCallsignResult:
		soap_serialize_PointerToPointerTons1__proxCallsignResult(soap, (ns1__proxCallsignResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__proxCallsignResult:
		soap_serialize_PointerTons1__proxCallsignResult(soap, (ns1__proxCallsignResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__fccLocation:
		soap_serialize_PointerToPointerTons1__fccLocation(soap, (ns1__fccLocation **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fccLocation:
		soap_serialize_PointerTons1__fccLocation(soap, (ns1__fccLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__fccFrequency:
		soap_serialize_PointerToPointerTons1__fccFrequency(soap, (ns1__fccFrequency **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fccFrequency:
		soap_serialize_PointerTons1__fccFrequency(soap, (ns1__fccFrequency *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__mode:
		soap_serialize_PointerToPointerTons1__mode(soap, (ns1__mode **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__mode:
		soap_serialize_PointerTons1__mode(soap, (ns1__mode *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__tag:
		soap_serialize_PointerToPointerTons1__tag(soap, (ns1__tag **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__tag:
		soap_serialize_PointerTons1__tag(soap, (ns1__tag *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__sid:
		soap_serialize_PointerToPointerTons1__sid(soap, (ns1__sid **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sid:
		soap_serialize_PointerTons1__sid(soap, (ns1__sid *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Agency:
		soap_serialize_PointerToPointerTons1__Agency(soap, (ns1__Agency **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Agency:
		soap_serialize_PointerTons1__Agency(soap, (ns1__Agency *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Country:
		soap_serialize_PointerToPointerTons1__Country(soap, (ns1__Country **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Country:
		soap_serialize_PointerTons1__Country(soap, (ns1__Country *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Metro:
		soap_serialize_PointerToPointerTons1__Metro(soap, (ns1__Metro **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Metro:
		soap_serialize_PointerTons1__Metro(soap, (ns1__Metro *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__State:
		soap_serialize_PointerToPointerTons1__State(soap, (ns1__State **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__State:
		soap_serialize_PointerTons1__State(soap, (ns1__State *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__County:
		soap_serialize_PointerToPointerTons1__County(soap, (ns1__County **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__County:
		soap_serialize_PointerTons1__County(soap, (ns1__County *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__subcat:
		soap_serialize_PointerToPointerTons1__subcat(soap, (ns1__subcat **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__subcat:
		soap_serialize_PointerTons1__subcat(soap, (ns1__subcat *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__cat:
		soap_serialize_PointerToPointerTons1__cat(soap, (ns1__cat **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cat:
		soap_serialize_PointerTons1__cat(soap, (ns1__cat *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__freq:
		soap_serialize_PointerToPointerTons1__freq(soap, (ns1__freq **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__freq:
		soap_serialize_PointerTons1__freq(soap, (ns1__freq *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__searchFreqResult:
		soap_serialize_PointerToPointerTons1__searchFreqResult(soap, (ns1__searchFreqResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__searchFreqResult:
		soap_serialize_PointerTons1__searchFreqResult(soap, (ns1__searchFreqResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__trsVoiceDef:
		soap_serialize_PointerToPointerTons1__trsVoiceDef(soap, (ns1__trsVoiceDef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trsVoiceDef:
		soap_serialize_PointerTons1__trsVoiceDef(soap, (ns1__trsVoiceDef *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__trsFlavorDef:
		soap_serialize_PointerToPointerTons1__trsFlavorDef(soap, (ns1__trsFlavorDef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trsFlavorDef:
		soap_serialize_PointerTons1__trsFlavorDef(soap, (ns1__trsFlavorDef *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__trsTypeDef:
		soap_serialize_PointerToPointerTons1__trsTypeDef(soap, (ns1__trsTypeDef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trsTypeDef:
		soap_serialize_PointerTons1__trsTypeDef(soap, (ns1__trsTypeDef *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__trsBandplanDef:
		soap_serialize_PointerToPointerTons1__trsBandplanDef(soap, (ns1__trsBandplanDef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trsBandplanDef:
		soap_serialize_PointerTons1__trsBandplanDef(soap, (ns1__trsBandplanDef *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__trsSysidDef:
		soap_serialize_PointerToPointerTons1__trsSysidDef(soap, (ns1__trsSysidDef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__trsSysidDef:
		soap_serialize_PointerTons1__trsSysidDef(soap, (ns1__trsSysidDef *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__TrsListDef:
		soap_serialize_PointerToPointerTons1__TrsListDef(soap, (ns1__TrsListDef **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TrsListDef:
		soap_serialize_PointerTons1__TrsListDef(soap, (ns1__TrsListDef *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__TrsSiteLicense:
		soap_serialize_PointerToPointerTons1__TrsSiteLicense(soap, (ns1__TrsSiteLicense **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TrsSiteLicense:
		soap_serialize_PointerTons1__TrsSiteLicense(soap, (ns1__TrsSiteLicense *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__TrsSiteFreq:
		soap_serialize_PointerToPointerTons1__TrsSiteFreq(soap, (ns1__TrsSiteFreq **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TrsSiteFreq:
		soap_serialize_PointerTons1__TrsSiteFreq(soap, (ns1__TrsSiteFreq *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__TrsSite:
		soap_serialize_PointerToPointerTons1__TrsSite(soap, (ns1__TrsSite **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TrsSite:
		soap_serialize_PointerTons1__TrsSite(soap, (ns1__TrsSite *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__TalkgroupCat:
		soap_serialize_PointerToPointerTons1__TalkgroupCat(soap, (ns1__TalkgroupCat **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TalkgroupCat:
		soap_serialize_PointerTons1__TalkgroupCat(soap, (ns1__TalkgroupCat *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__Talkgroup:
		soap_serialize_PointerToPointerTons1__Talkgroup(soap, (ns1__Talkgroup **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Talkgroup:
		soap_serialize_PointerTons1__Talkgroup(soap, (ns1__Talkgroup *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ctid:
		soap_serialize_PointerToPointerTons1__ctid(soap, (ns1__ctid **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ctid:
		soap_serialize_PointerTons1__ctid(soap, (ns1__ctid *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__stid:
		soap_serialize_PointerToPointerTons1__stid(soap, (ns1__stid **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__stid:
		soap_serialize_PointerTons1__stid(soap, (ns1__stid *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__userFeedBroadcast:
		soap_serialize_PointerToPointerTons1__userFeedBroadcast(soap, (ns1__userFeedBroadcast **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__userFeedBroadcast:
		soap_serialize_PointerTons1__userFeedBroadcast(soap, (ns1__userFeedBroadcast *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofccFrequencies:
		soap_serialize_PointerTofccFrequencies(soap, (fccFrequencies *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofccLocations:
		soap_serialize_PointerTofccLocations(soap, (fccLocations *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCounties:
		soap_serialize_PointerToCounties(soap, (Counties *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsList:
		soap_serialize_PointerToTrsList(soap, (TrsList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToStates:
		soap_serialize_PointerToStates(soap, (States *const*)ptr);
		break;
	case SOAP_TYPE_PointerToAgencies:
		soap_serialize_PointerToAgencies(soap, (Agencies *const*)ptr);
		break;
	case SOAP_TYPE_PointerToCats:
		soap_serialize_PointerToCats(soap, (Cats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTosids:
		soap_serialize_PointerTosids(soap, (sids *const*)ptr);
		break;
	case SOAP_TYPE_PointerToSubCats:
		soap_serialize_PointerToSubCats(soap, (SubCats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TrsFleetmap:
		soap_serialize_PointerTons1__TrsFleetmap(soap, (ns1__TrsFleetmap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsSysid:
		soap_serialize_PointerToTrsSysid(soap, (TrsSysid *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostids:
		soap_serialize_PointerTostids(soap, (stids *const*)ptr);
		break;
	case SOAP_TYPE_PointerToctids:
		soap_serialize_PointerToctids(soap, (ctids *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsBandplan:
		soap_serialize_PointerToTrsBandplan(soap, (TrsBandplan *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsSiteFreqs:
		soap_serialize_PointerToTrsSiteFreqs(soap, (TrsSiteFreqs *const*)ptr);
		break;
	case SOAP_TYPE_PointerToTrsSiteLicenses:
		soap_serialize_PointerToTrsSiteLicenses(soap, (TrsSiteLicenses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotags:
		soap_serialize_PointerTotags(soap, (tags *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 rrapi__instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_SOAP_ENC__Array:
		return (void*)rrapi__instantiate_SOAP_ENC__Array(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)rrapi__instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__authInfo:
		return (void*)rrapi__instantiate_ns1__authInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__userFeedBroadcast:
		return (void*)rrapi__instantiate_ns1__userFeedBroadcast(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Talkgroup:
		return (void*)rrapi__instantiate_ns1__Talkgroup(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TalkgroupCat:
		return (void*)rrapi__instantiate_ns1__TalkgroupCat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TrsSite:
		return (void*)rrapi__instantiate_ns1__TrsSite(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TrsSiteFreq:
		return (void*)rrapi__instantiate_ns1__TrsSiteFreq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TrsSiteLicense:
		return (void*)rrapi__instantiate_ns1__TrsSiteLicense(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Trs:
		return (void*)rrapi__instantiate_ns1__Trs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TrsListDef:
		return (void*)rrapi__instantiate_ns1__TrsListDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__trsSysidDef:
		return (void*)rrapi__instantiate_ns1__trsSysidDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__trsBandplanDef:
		return (void*)rrapi__instantiate_ns1__trsBandplanDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TrsFleetmap:
		return (void*)rrapi__instantiate_ns1__TrsFleetmap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__trsTypeDef:
		return (void*)rrapi__instantiate_ns1__trsTypeDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__trsFlavorDef:
		return (void*)rrapi__instantiate_ns1__trsFlavorDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__trsVoiceDef:
		return (void*)rrapi__instantiate_ns1__trsVoiceDef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__freq:
		return (void*)rrapi__instantiate_ns1__freq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchFreqResult:
		return (void*)rrapi__instantiate_ns1__searchFreqResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cat:
		return (void*)rrapi__instantiate_ns1__cat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__subcat:
		return (void*)rrapi__instantiate_ns1__subcat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AgencyInfo:
		return (void*)rrapi__instantiate_ns1__AgencyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CountryInfo:
		return (void*)rrapi__instantiate_ns1__CountryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CountyInfo:
		return (void*)rrapi__instantiate_ns1__CountyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StateInfo:
		return (void*)rrapi__instantiate_ns1__StateInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__County:
		return (void*)rrapi__instantiate_ns1__County(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ctid:
		return (void*)rrapi__instantiate_ns1__ctid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__State:
		return (void*)rrapi__instantiate_ns1__State(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Metro:
		return (void*)rrapi__instantiate_ns1__Metro(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Country:
		return (void*)rrapi__instantiate_ns1__Country(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Agency:
		return (void*)rrapi__instantiate_ns1__Agency(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__stid:
		return (void*)rrapi__instantiate_ns1__stid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sid:
		return (void*)rrapi__instantiate_ns1__sid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__tag:
		return (void*)rrapi__instantiate_ns1__tag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__mode:
		return (void*)rrapi__instantiate_ns1__mode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ZipInfo:
		return (void*)rrapi__instantiate_ns1__ZipInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserInfo:
		return (void*)rrapi__instantiate_ns1__UserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccCallsignDetails:
		return (void*)rrapi__instantiate_ns1__fccCallsignDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccFrequency:
		return (void*)rrapi__instantiate_ns1__fccFrequency(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccLocation:
		return (void*)rrapi__instantiate_ns1__fccLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__proxCallsignResult:
		return (void*)rrapi__instantiate_ns1__proxCallsignResult(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccRadioServiceCode:
		return (void*)rrapi__instantiate_ns1__fccRadioServiceCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_userFeedBroadcasts:
		return (void*)rrapi__instantiate_userFeedBroadcasts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_stidList:
		return (void*)rrapi__instantiate_stidList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ctidList:
		return (void*)rrapi__instantiate_ctidList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Talkgroups:
		return (void*)rrapi__instantiate_Talkgroups(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TalkgroupCats:
		return (void*)rrapi__instantiate_TalkgroupCats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsSites:
		return (void*)rrapi__instantiate_TrsSites(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsSiteFreqs:
		return (void*)rrapi__instantiate_TrsSiteFreqs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsSiteLicenses:
		return (void*)rrapi__instantiate_TrsSiteLicenses(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsList:
		return (void*)rrapi__instantiate_TrsList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsSysid:
		return (void*)rrapi__instantiate_TrsSysid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsBandplan:
		return (void*)rrapi__instantiate_TrsBandplan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsType:
		return (void*)rrapi__instantiate_TrsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsFlavor:
		return (void*)rrapi__instantiate_TrsFlavor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_TrsVoice:
		return (void*)rrapi__instantiate_TrsVoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_searchFreqResults:
		return (void*)rrapi__instantiate_searchFreqResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Freqs:
		return (void*)rrapi__instantiate_Freqs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Cats:
		return (void*)rrapi__instantiate_Cats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SubCats:
		return (void*)rrapi__instantiate_SubCats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Counties:
		return (void*)rrapi__instantiate_Counties(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ctids:
		return (void*)rrapi__instantiate_ctids(soap, -1, type, arrayType, n);
	case SOAP_TYPE_States:
		return (void*)rrapi__instantiate_States(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Metros:
		return (void*)rrapi__instantiate_Metros(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Countries:
		return (void*)rrapi__instantiate_Countries(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Agencies:
		return (void*)rrapi__instantiate_Agencies(soap, -1, type, arrayType, n);
	case SOAP_TYPE_stids:
		return (void*)rrapi__instantiate_stids(soap, -1, type, arrayType, n);
	case SOAP_TYPE_sids:
		return (void*)rrapi__instantiate_sids(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tags:
		return (void*)rrapi__instantiate_tags(soap, -1, type, arrayType, n);
	case SOAP_TYPE_modes:
		return (void*)rrapi__instantiate_modes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fccFrequencies:
		return (void*)rrapi__instantiate_fccFrequencies(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fccLocations:
		return (void*)rrapi__instantiate_fccLocations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_proxCallsignResults:
		return (void*)rrapi__instantiate_proxCallsignResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fccRadioServiceCodes:
		return (void*)rrapi__instantiate_fccRadioServiceCodes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsTalkgroupsResponse:
		return (void*)rrapi__instantiate_ns1__getTrsTalkgroupsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsTalkgroups:
		return (void*)rrapi__instantiate_ns1__getTrsTalkgroups(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse:
		return (void*)rrapi__instantiate_ns1__getTrsTalkgroupCatsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsTalkgroupCats:
		return (void*)rrapi__instantiate_ns1__getTrsTalkgroupCats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsDetailsResponse:
		return (void*)rrapi__instantiate_ns1__getTrsDetailsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsDetails:
		return (void*)rrapi__instantiate_ns1__getTrsDetails(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsBySysidResponse:
		return (void*)rrapi__instantiate_ns1__getTrsBySysidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsBySysid:
		return (void*)rrapi__instantiate_ns1__getTrsBySysid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsSitesResponse:
		return (void*)rrapi__instantiate_ns1__getTrsSitesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsSites:
		return (void*)rrapi__instantiate_ns1__getTrsSites(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStatesByListResponse:
		return (void*)rrapi__instantiate_ns1__getStatesByListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStatesByList:
		return (void*)rrapi__instantiate_ns1__getStatesByList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountiesByListResponse:
		return (void*)rrapi__instantiate_ns1__getCountiesByListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountiesByList:
		return (void*)rrapi__instantiate_ns1__getCountiesByList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTagResponse:
		return (void*)rrapi__instantiate_ns1__getTagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTag:
		return (void*)rrapi__instantiate_ns1__getTag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getModeResponse:
		return (void*)rrapi__instantiate_ns1__getModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMode:
		return (void*)rrapi__instantiate_ns1__getMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsTypeResponse:
		return (void*)rrapi__instantiate_ns1__getTrsTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsType:
		return (void*)rrapi__instantiate_ns1__getTrsType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsFlavorResponse:
		return (void*)rrapi__instantiate_ns1__getTrsFlavorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsFlavor:
		return (void*)rrapi__instantiate_ns1__getTrsFlavor(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsVoiceResponse:
		return (void*)rrapi__instantiate_ns1__getTrsVoiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTrsVoice:
		return (void*)rrapi__instantiate_ns1__getTrsVoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountryListResponse:
		return (void*)rrapi__instantiate_ns1__getCountryListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountryList:
		return (void*)rrapi__instantiate_ns1__getCountryList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountryInfoResponse:
		return (void*)rrapi__instantiate_ns1__getCountryInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountryInfo:
		return (void*)rrapi__instantiate_ns1__getCountryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStateInfoResponse:
		return (void*)rrapi__instantiate_ns1__getStateInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getStateInfo:
		return (void*)rrapi__instantiate_ns1__getStateInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountyInfoResponse:
		return (void*)rrapi__instantiate_ns1__getCountyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountyInfo:
		return (void*)rrapi__instantiate_ns1__getCountyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAgencyInfoResponse:
		return (void*)rrapi__instantiate_ns1__getAgencyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAgencyInfo:
		return (void*)rrapi__instantiate_ns1__getAgencyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSubcatFreqsResponse:
		return (void*)rrapi__instantiate_ns1__getSubcatFreqsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getSubcatFreqs:
		return (void*)rrapi__instantiate_ns1__getSubcatFreqs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchCountyFreqResponse:
		return (void*)rrapi__instantiate_ns1__searchCountyFreqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchCountyFreq:
		return (void*)rrapi__instantiate_ns1__searchCountyFreq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchStateFreqResponse:
		return (void*)rrapi__instantiate_ns1__searchStateFreqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchStateFreq:
		return (void*)rrapi__instantiate_ns1__searchStateFreq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchMetroFreqResponse:
		return (void*)rrapi__instantiate_ns1__searchMetroFreqResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__searchMetroFreq:
		return (void*)rrapi__instantiate_ns1__searchMetroFreq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountyFreqsByTagResponse:
		return (void*)rrapi__instantiate_ns1__getCountyFreqsByTagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCountyFreqsByTag:
		return (void*)rrapi__instantiate_ns1__getCountyFreqsByTag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAgencyFreqsByTagResponse:
		return (void*)rrapi__instantiate_ns1__getAgencyFreqsByTagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAgencyFreqsByTag:
		return (void*)rrapi__instantiate_ns1__getAgencyFreqsByTag(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetroAreaResponse:
		return (void*)rrapi__instantiate_ns1__getMetroAreaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetroArea:
		return (void*)rrapi__instantiate_ns1__getMetroArea(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetroAreaInfoResponse:
		return (void*)rrapi__instantiate_ns1__getMetroAreaInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetroAreaInfo:
		return (void*)rrapi__instantiate_ns1__getMetroAreaInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getZipcodeInfoResponse:
		return (void*)rrapi__instantiate_ns1__getZipcodeInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getZipcodeInfo:
		return (void*)rrapi__instantiate_ns1__getZipcodeInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccGetCallsignResponse:
		return (void*)rrapi__instantiate_ns1__fccGetCallsignResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccGetCallsign:
		return (void*)rrapi__instantiate_ns1__fccGetCallsign(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse:
		return (void*)rrapi__instantiate_ns1__fccGetRadioServiceCodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccGetRadioServiceCode:
		return (void*)rrapi__instantiate_ns1__fccGetRadioServiceCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccGetProxCallsignsResponse:
		return (void*)rrapi__instantiate_ns1__fccGetProxCallsignsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fccGetProxCallsigns:
		return (void*)rrapi__instantiate_ns1__fccGetProxCallsigns(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserDataResponse:
		return (void*)rrapi__instantiate_ns1__getUserDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserData:
		return (void*)rrapi__instantiate_ns1__getUserData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserFeedBroadcastsResponse:
		return (void*)rrapi__instantiate_ns1__getUserFeedBroadcastsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserFeedBroadcasts:
		return (void*)rrapi__instantiate_ns1__getUserFeedBroadcasts(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)rrapi__instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)rrapi__instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)rrapi__instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)rrapi__instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)rrapi__instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__decimal:
		return (void*)rrapi__instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 rrapi__fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE_SOAP_ENC__Array:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<SOAP_ENC__Array*>(p->ptr), SOAP_ENC__Array);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<SOAP_ENC__Array*>(p->ptr), SOAP_ENC__Array);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_ns1__authInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__authInfo*>(p->ptr), ns1__authInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__authInfo*>(p->ptr), ns1__authInfo);
		break;
	case SOAP_TYPE_ns1__userFeedBroadcast:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__userFeedBroadcast*>(p->ptr), ns1__userFeedBroadcast);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__userFeedBroadcast*>(p->ptr), ns1__userFeedBroadcast);
		break;
	case SOAP_TYPE_ns1__Talkgroup:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Talkgroup*>(p->ptr), ns1__Talkgroup);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Talkgroup*>(p->ptr), ns1__Talkgroup);
		break;
	case SOAP_TYPE_ns1__TalkgroupCat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TalkgroupCat*>(p->ptr), ns1__TalkgroupCat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TalkgroupCat*>(p->ptr), ns1__TalkgroupCat);
		break;
	case SOAP_TYPE_ns1__TrsSite:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TrsSite*>(p->ptr), ns1__TrsSite);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TrsSite*>(p->ptr), ns1__TrsSite);
		break;
	case SOAP_TYPE_ns1__TrsSiteFreq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TrsSiteFreq*>(p->ptr), ns1__TrsSiteFreq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TrsSiteFreq*>(p->ptr), ns1__TrsSiteFreq);
		break;
	case SOAP_TYPE_ns1__TrsSiteLicense:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TrsSiteLicense*>(p->ptr), ns1__TrsSiteLicense);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TrsSiteLicense*>(p->ptr), ns1__TrsSiteLicense);
		break;
	case SOAP_TYPE_ns1__Trs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Trs*>(p->ptr), ns1__Trs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Trs*>(p->ptr), ns1__Trs);
		break;
	case SOAP_TYPE_ns1__TrsListDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TrsListDef*>(p->ptr), ns1__TrsListDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TrsListDef*>(p->ptr), ns1__TrsListDef);
		break;
	case SOAP_TYPE_ns1__trsSysidDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__trsSysidDef*>(p->ptr), ns1__trsSysidDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__trsSysidDef*>(p->ptr), ns1__trsSysidDef);
		break;
	case SOAP_TYPE_ns1__trsBandplanDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__trsBandplanDef*>(p->ptr), ns1__trsBandplanDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__trsBandplanDef*>(p->ptr), ns1__trsBandplanDef);
		break;
	case SOAP_TYPE_ns1__TrsFleetmap:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__TrsFleetmap*>(p->ptr), ns1__TrsFleetmap);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__TrsFleetmap*>(p->ptr), ns1__TrsFleetmap);
		break;
	case SOAP_TYPE_ns1__trsTypeDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__trsTypeDef*>(p->ptr), ns1__trsTypeDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__trsTypeDef*>(p->ptr), ns1__trsTypeDef);
		break;
	case SOAP_TYPE_ns1__trsFlavorDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__trsFlavorDef*>(p->ptr), ns1__trsFlavorDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__trsFlavorDef*>(p->ptr), ns1__trsFlavorDef);
		break;
	case SOAP_TYPE_ns1__trsVoiceDef:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__trsVoiceDef*>(p->ptr), ns1__trsVoiceDef);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__trsVoiceDef*>(p->ptr), ns1__trsVoiceDef);
		break;
	case SOAP_TYPE_ns1__freq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__freq*>(p->ptr), ns1__freq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__freq*>(p->ptr), ns1__freq);
		break;
	case SOAP_TYPE_ns1__searchFreqResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__searchFreqResult*>(p->ptr), ns1__searchFreqResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__searchFreqResult*>(p->ptr), ns1__searchFreqResult);
		break;
	case SOAP_TYPE_ns1__cat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__cat*>(p->ptr), ns1__cat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__cat*>(p->ptr), ns1__cat);
		break;
	case SOAP_TYPE_ns1__subcat:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__subcat*>(p->ptr), ns1__subcat);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__subcat*>(p->ptr), ns1__subcat);
		break;
	case SOAP_TYPE_ns1__AgencyInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__AgencyInfo*>(p->ptr), ns1__AgencyInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__AgencyInfo*>(p->ptr), ns1__AgencyInfo);
		break;
	case SOAP_TYPE_ns1__CountryInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CountryInfo*>(p->ptr), ns1__CountryInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CountryInfo*>(p->ptr), ns1__CountryInfo);
		break;
	case SOAP_TYPE_ns1__CountyInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__CountyInfo*>(p->ptr), ns1__CountyInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__CountyInfo*>(p->ptr), ns1__CountyInfo);
		break;
	case SOAP_TYPE_ns1__StateInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__StateInfo*>(p->ptr), ns1__StateInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__StateInfo*>(p->ptr), ns1__StateInfo);
		break;
	case SOAP_TYPE_ns1__County:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__County*>(p->ptr), ns1__County);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__County*>(p->ptr), ns1__County);
		break;
	case SOAP_TYPE_ns1__ctid:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ctid*>(p->ptr), ns1__ctid);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ctid*>(p->ptr), ns1__ctid);
		break;
	case SOAP_TYPE_ns1__State:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__State*>(p->ptr), ns1__State);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__State*>(p->ptr), ns1__State);
		break;
	case SOAP_TYPE_ns1__Metro:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Metro*>(p->ptr), ns1__Metro);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Metro*>(p->ptr), ns1__Metro);
		break;
	case SOAP_TYPE_ns1__Country:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Country*>(p->ptr), ns1__Country);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Country*>(p->ptr), ns1__Country);
		break;
	case SOAP_TYPE_ns1__Agency:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__Agency*>(p->ptr), ns1__Agency);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__Agency*>(p->ptr), ns1__Agency);
		break;
	case SOAP_TYPE_ns1__stid:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__stid*>(p->ptr), ns1__stid);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__stid*>(p->ptr), ns1__stid);
		break;
	case SOAP_TYPE_ns1__sid:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__sid*>(p->ptr), ns1__sid);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__sid*>(p->ptr), ns1__sid);
		break;
	case SOAP_TYPE_ns1__tag:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__tag*>(p->ptr), ns1__tag);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__tag*>(p->ptr), ns1__tag);
		break;
	case SOAP_TYPE_ns1__mode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__mode*>(p->ptr), ns1__mode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__mode*>(p->ptr), ns1__mode);
		break;
	case SOAP_TYPE_ns1__ZipInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__ZipInfo*>(p->ptr), ns1__ZipInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__ZipInfo*>(p->ptr), ns1__ZipInfo);
		break;
	case SOAP_TYPE_ns1__UserInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__UserInfo*>(p->ptr), ns1__UserInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__UserInfo*>(p->ptr), ns1__UserInfo);
		break;
	case SOAP_TYPE_ns1__fccCallsignDetails:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__fccCallsignDetails*>(p->ptr), ns1__fccCallsignDetails);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__fccCallsignDetails*>(p->ptr), ns1__fccCallsignDetails);
		break;
	case SOAP_TYPE_ns1__fccFrequency:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__fccFrequency*>(p->ptr), ns1__fccFrequency);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__fccFrequency*>(p->ptr), ns1__fccFrequency);
		break;
	case SOAP_TYPE_ns1__fccLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__fccLocation*>(p->ptr), ns1__fccLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__fccLocation*>(p->ptr), ns1__fccLocation);
		break;
	case SOAP_TYPE_ns1__proxCallsignResult:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__proxCallsignResult*>(p->ptr), ns1__proxCallsignResult);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__proxCallsignResult*>(p->ptr), ns1__proxCallsignResult);
		break;
	case SOAP_TYPE_ns1__fccRadioServiceCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ns1__fccRadioServiceCode*>(p->ptr), ns1__fccRadioServiceCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ns1__fccRadioServiceCode*>(p->ptr), ns1__fccRadioServiceCode);
		break;
	case SOAP_TYPE_userFeedBroadcasts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<userFeedBroadcasts*>(p->ptr), userFeedBroadcasts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<userFeedBroadcasts*>(p->ptr), userFeedBroadcasts);
		break;
	case SOAP_TYPE_stidList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<stidList*>(p->ptr), stidList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<stidList*>(p->ptr), stidList);
		break;
	case SOAP_TYPE_ctidList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ctidList*>(p->ptr), ctidList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ctidList*>(p->ptr), ctidList);
		break;
	case SOAP_TYPE_Talkgroups:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Talkgroups*>(p->ptr), Talkgroups);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Talkgroups*>(p->ptr), Talkgroups);
		break;
	case SOAP_TYPE_TalkgroupCats:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TalkgroupCats*>(p->ptr), TalkgroupCats);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TalkgroupCats*>(p->ptr), TalkgroupCats);
		break;
	case SOAP_TYPE_TrsSites:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsSites*>(p->ptr), TrsSites);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsSites*>(p->ptr), TrsSites);
		break;
	case SOAP_TYPE_TrsSiteFreqs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsSiteFreqs*>(p->ptr), TrsSiteFreqs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsSiteFreqs*>(p->ptr), TrsSiteFreqs);
		break;
	case SOAP_TYPE_TrsSiteLicenses:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsSiteLicenses*>(p->ptr), TrsSiteLicenses);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsSiteLicenses*>(p->ptr), TrsSiteLicenses);
		break;
	case SOAP_TYPE_TrsList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsList*>(p->ptr), TrsList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsList*>(p->ptr), TrsList);
		break;
	case SOAP_TYPE_TrsSysid:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsSysid*>(p->ptr), TrsSysid);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsSysid*>(p->ptr), TrsSysid);
		break;
	case SOAP_TYPE_TrsBandplan:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsBandplan*>(p->ptr), TrsBandplan);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsBandplan*>(p->ptr), TrsBandplan);
		break;
	case SOAP_TYPE_TrsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsType*>(p->ptr), TrsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsType*>(p->ptr), TrsType);
		break;
	case SOAP_TYPE_TrsFlavor:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsFlavor*>(p->ptr), TrsFlavor);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsFlavor*>(p->ptr), TrsFlavor);
		break;
	case SOAP_TYPE_TrsVoice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<TrsVoice*>(p->ptr), TrsVoice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<TrsVoice*>(p->ptr), TrsVoice);
		break;
	case SOAP_TYPE_searchFreqResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<searchFreqResults*>(p->ptr), searchFreqResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<searchFreqResults*>(p->ptr), searchFreqResults);
		break;
	case SOAP_TYPE_Freqs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Freqs*>(p->ptr), Freqs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Freqs*>(p->ptr), Freqs);
		break;
	case SOAP_TYPE_Cats:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Cats*>(p->ptr), Cats);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Cats*>(p->ptr), Cats);
		break;
	case SOAP_TYPE_SubCats:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<SubCats*>(p->ptr), SubCats);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<SubCats*>(p->ptr), SubCats);
		break;
	case SOAP_TYPE_Counties:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Counties*>(p->ptr), Counties);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Counties*>(p->ptr), Counties);
		break;
	case SOAP_TYPE_ctids:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<ctids*>(p->ptr), ctids);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<ctids*>(p->ptr), ctids);
		break;
	case SOAP_TYPE_States:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<States*>(p->ptr), States);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<States*>(p->ptr), States);
		break;
	case SOAP_TYPE_Metros:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Metros*>(p->ptr), Metros);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Metros*>(p->ptr), Metros);
		break;
	case SOAP_TYPE_Countries:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Countries*>(p->ptr), Countries);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Countries*>(p->ptr), Countries);
		break;
	case SOAP_TYPE_Agencies:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<Agencies*>(p->ptr), Agencies);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<Agencies*>(p->ptr), Agencies);
		break;
	case SOAP_TYPE_stids:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<stids*>(p->ptr), stids);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<stids*>(p->ptr), stids);
		break;
	case SOAP_TYPE_sids:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<sids*>(p->ptr), sids);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<sids*>(p->ptr), sids);
		break;
	case SOAP_TYPE_tags:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tags*>(p->ptr), tags);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tags*>(p->ptr), tags);
		break;
	case SOAP_TYPE_modes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<modes*>(p->ptr), modes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<modes*>(p->ptr), modes);
		break;
	case SOAP_TYPE_fccFrequencies:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<fccFrequencies*>(p->ptr), fccFrequencies);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<fccFrequencies*>(p->ptr), fccFrequencies);
		break;
	case SOAP_TYPE_fccLocations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<fccLocations*>(p->ptr), fccLocations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<fccLocations*>(p->ptr), fccLocations);
		break;
	case SOAP_TYPE_proxCallsignResults:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<proxCallsignResults*>(p->ptr), proxCallsignResults);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<proxCallsignResults*>(p->ptr), proxCallsignResults);
		break;
	case SOAP_TYPE_fccRadioServiceCodes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<fccRadioServiceCodes*>(p->ptr), fccRadioServiceCodes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<fccRadioServiceCodes*>(p->ptr), fccRadioServiceCodes);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsTalkgroupsResponse*>(p->ptr), struct ns1__getTrsTalkgroupsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsTalkgroupsResponse*>(p->ptr), struct ns1__getTrsTalkgroupsResponse);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroups:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsTalkgroups*>(p->ptr), struct ns1__getTrsTalkgroups);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsTalkgroups*>(p->ptr), struct ns1__getTrsTalkgroups);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsTalkgroupCatsResponse*>(p->ptr), struct ns1__getTrsTalkgroupCatsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsTalkgroupCatsResponse*>(p->ptr), struct ns1__getTrsTalkgroupCatsResponse);
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupCats:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsTalkgroupCats*>(p->ptr), struct ns1__getTrsTalkgroupCats);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsTalkgroupCats*>(p->ptr), struct ns1__getTrsTalkgroupCats);
		break;
	case SOAP_TYPE_ns1__getTrsDetailsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsDetailsResponse*>(p->ptr), struct ns1__getTrsDetailsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsDetailsResponse*>(p->ptr), struct ns1__getTrsDetailsResponse);
		break;
	case SOAP_TYPE_ns1__getTrsDetails:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsDetails*>(p->ptr), struct ns1__getTrsDetails);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsDetails*>(p->ptr), struct ns1__getTrsDetails);
		break;
	case SOAP_TYPE_ns1__getTrsBySysidResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsBySysidResponse*>(p->ptr), struct ns1__getTrsBySysidResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsBySysidResponse*>(p->ptr), struct ns1__getTrsBySysidResponse);
		break;
	case SOAP_TYPE_ns1__getTrsBySysid:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsBySysid*>(p->ptr), struct ns1__getTrsBySysid);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsBySysid*>(p->ptr), struct ns1__getTrsBySysid);
		break;
	case SOAP_TYPE_ns1__getTrsSitesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsSitesResponse*>(p->ptr), struct ns1__getTrsSitesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsSitesResponse*>(p->ptr), struct ns1__getTrsSitesResponse);
		break;
	case SOAP_TYPE_ns1__getTrsSites:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsSites*>(p->ptr), struct ns1__getTrsSites);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsSites*>(p->ptr), struct ns1__getTrsSites);
		break;
	case SOAP_TYPE_ns1__getStatesByListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getStatesByListResponse*>(p->ptr), struct ns1__getStatesByListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getStatesByListResponse*>(p->ptr), struct ns1__getStatesByListResponse);
		break;
	case SOAP_TYPE_ns1__getStatesByList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getStatesByList*>(p->ptr), struct ns1__getStatesByList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getStatesByList*>(p->ptr), struct ns1__getStatesByList);
		break;
	case SOAP_TYPE_ns1__getCountiesByListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountiesByListResponse*>(p->ptr), struct ns1__getCountiesByListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountiesByListResponse*>(p->ptr), struct ns1__getCountiesByListResponse);
		break;
	case SOAP_TYPE_ns1__getCountiesByList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountiesByList*>(p->ptr), struct ns1__getCountiesByList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountiesByList*>(p->ptr), struct ns1__getCountiesByList);
		break;
	case SOAP_TYPE_ns1__getTagResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTagResponse*>(p->ptr), struct ns1__getTagResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTagResponse*>(p->ptr), struct ns1__getTagResponse);
		break;
	case SOAP_TYPE_ns1__getTag:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTag*>(p->ptr), struct ns1__getTag);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTag*>(p->ptr), struct ns1__getTag);
		break;
	case SOAP_TYPE_ns1__getModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getModeResponse*>(p->ptr), struct ns1__getModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getModeResponse*>(p->ptr), struct ns1__getModeResponse);
		break;
	case SOAP_TYPE_ns1__getMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getMode*>(p->ptr), struct ns1__getMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getMode*>(p->ptr), struct ns1__getMode);
		break;
	case SOAP_TYPE_ns1__getTrsTypeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsTypeResponse*>(p->ptr), struct ns1__getTrsTypeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsTypeResponse*>(p->ptr), struct ns1__getTrsTypeResponse);
		break;
	case SOAP_TYPE_ns1__getTrsType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsType*>(p->ptr), struct ns1__getTrsType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsType*>(p->ptr), struct ns1__getTrsType);
		break;
	case SOAP_TYPE_ns1__getTrsFlavorResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsFlavorResponse*>(p->ptr), struct ns1__getTrsFlavorResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsFlavorResponse*>(p->ptr), struct ns1__getTrsFlavorResponse);
		break;
	case SOAP_TYPE_ns1__getTrsFlavor:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsFlavor*>(p->ptr), struct ns1__getTrsFlavor);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsFlavor*>(p->ptr), struct ns1__getTrsFlavor);
		break;
	case SOAP_TYPE_ns1__getTrsVoiceResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsVoiceResponse*>(p->ptr), struct ns1__getTrsVoiceResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsVoiceResponse*>(p->ptr), struct ns1__getTrsVoiceResponse);
		break;
	case SOAP_TYPE_ns1__getTrsVoice:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getTrsVoice*>(p->ptr), struct ns1__getTrsVoice);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getTrsVoice*>(p->ptr), struct ns1__getTrsVoice);
		break;
	case SOAP_TYPE_ns1__getCountryListResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountryListResponse*>(p->ptr), struct ns1__getCountryListResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountryListResponse*>(p->ptr), struct ns1__getCountryListResponse);
		break;
	case SOAP_TYPE_ns1__getCountryList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountryList*>(p->ptr), struct ns1__getCountryList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountryList*>(p->ptr), struct ns1__getCountryList);
		break;
	case SOAP_TYPE_ns1__getCountryInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountryInfoResponse*>(p->ptr), struct ns1__getCountryInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountryInfoResponse*>(p->ptr), struct ns1__getCountryInfoResponse);
		break;
	case SOAP_TYPE_ns1__getCountryInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountryInfo*>(p->ptr), struct ns1__getCountryInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountryInfo*>(p->ptr), struct ns1__getCountryInfo);
		break;
	case SOAP_TYPE_ns1__getStateInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getStateInfoResponse*>(p->ptr), struct ns1__getStateInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getStateInfoResponse*>(p->ptr), struct ns1__getStateInfoResponse);
		break;
	case SOAP_TYPE_ns1__getStateInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getStateInfo*>(p->ptr), struct ns1__getStateInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getStateInfo*>(p->ptr), struct ns1__getStateInfo);
		break;
	case SOAP_TYPE_ns1__getCountyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountyInfoResponse*>(p->ptr), struct ns1__getCountyInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountyInfoResponse*>(p->ptr), struct ns1__getCountyInfoResponse);
		break;
	case SOAP_TYPE_ns1__getCountyInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountyInfo*>(p->ptr), struct ns1__getCountyInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountyInfo*>(p->ptr), struct ns1__getCountyInfo);
		break;
	case SOAP_TYPE_ns1__getAgencyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getAgencyInfoResponse*>(p->ptr), struct ns1__getAgencyInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getAgencyInfoResponse*>(p->ptr), struct ns1__getAgencyInfoResponse);
		break;
	case SOAP_TYPE_ns1__getAgencyInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getAgencyInfo*>(p->ptr), struct ns1__getAgencyInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getAgencyInfo*>(p->ptr), struct ns1__getAgencyInfo);
		break;
	case SOAP_TYPE_ns1__getSubcatFreqsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getSubcatFreqsResponse*>(p->ptr), struct ns1__getSubcatFreqsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getSubcatFreqsResponse*>(p->ptr), struct ns1__getSubcatFreqsResponse);
		break;
	case SOAP_TYPE_ns1__getSubcatFreqs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getSubcatFreqs*>(p->ptr), struct ns1__getSubcatFreqs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getSubcatFreqs*>(p->ptr), struct ns1__getSubcatFreqs);
		break;
	case SOAP_TYPE_ns1__searchCountyFreqResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__searchCountyFreqResponse*>(p->ptr), struct ns1__searchCountyFreqResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__searchCountyFreqResponse*>(p->ptr), struct ns1__searchCountyFreqResponse);
		break;
	case SOAP_TYPE_ns1__searchCountyFreq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__searchCountyFreq*>(p->ptr), struct ns1__searchCountyFreq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__searchCountyFreq*>(p->ptr), struct ns1__searchCountyFreq);
		break;
	case SOAP_TYPE_ns1__searchStateFreqResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__searchStateFreqResponse*>(p->ptr), struct ns1__searchStateFreqResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__searchStateFreqResponse*>(p->ptr), struct ns1__searchStateFreqResponse);
		break;
	case SOAP_TYPE_ns1__searchStateFreq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__searchStateFreq*>(p->ptr), struct ns1__searchStateFreq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__searchStateFreq*>(p->ptr), struct ns1__searchStateFreq);
		break;
	case SOAP_TYPE_ns1__searchMetroFreqResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__searchMetroFreqResponse*>(p->ptr), struct ns1__searchMetroFreqResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__searchMetroFreqResponse*>(p->ptr), struct ns1__searchMetroFreqResponse);
		break;
	case SOAP_TYPE_ns1__searchMetroFreq:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__searchMetroFreq*>(p->ptr), struct ns1__searchMetroFreq);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__searchMetroFreq*>(p->ptr), struct ns1__searchMetroFreq);
		break;
	case SOAP_TYPE_ns1__getCountyFreqsByTagResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountyFreqsByTagResponse*>(p->ptr), struct ns1__getCountyFreqsByTagResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountyFreqsByTagResponse*>(p->ptr), struct ns1__getCountyFreqsByTagResponse);
		break;
	case SOAP_TYPE_ns1__getCountyFreqsByTag:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getCountyFreqsByTag*>(p->ptr), struct ns1__getCountyFreqsByTag);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getCountyFreqsByTag*>(p->ptr), struct ns1__getCountyFreqsByTag);
		break;
	case SOAP_TYPE_ns1__getAgencyFreqsByTagResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getAgencyFreqsByTagResponse*>(p->ptr), struct ns1__getAgencyFreqsByTagResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getAgencyFreqsByTagResponse*>(p->ptr), struct ns1__getAgencyFreqsByTagResponse);
		break;
	case SOAP_TYPE_ns1__getAgencyFreqsByTag:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getAgencyFreqsByTag*>(p->ptr), struct ns1__getAgencyFreqsByTag);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getAgencyFreqsByTag*>(p->ptr), struct ns1__getAgencyFreqsByTag);
		break;
	case SOAP_TYPE_ns1__getMetroAreaResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getMetroAreaResponse*>(p->ptr), struct ns1__getMetroAreaResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getMetroAreaResponse*>(p->ptr), struct ns1__getMetroAreaResponse);
		break;
	case SOAP_TYPE_ns1__getMetroArea:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getMetroArea*>(p->ptr), struct ns1__getMetroArea);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getMetroArea*>(p->ptr), struct ns1__getMetroArea);
		break;
	case SOAP_TYPE_ns1__getMetroAreaInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getMetroAreaInfoResponse*>(p->ptr), struct ns1__getMetroAreaInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getMetroAreaInfoResponse*>(p->ptr), struct ns1__getMetroAreaInfoResponse);
		break;
	case SOAP_TYPE_ns1__getMetroAreaInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getMetroAreaInfo*>(p->ptr), struct ns1__getMetroAreaInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getMetroAreaInfo*>(p->ptr), struct ns1__getMetroAreaInfo);
		break;
	case SOAP_TYPE_ns1__getZipcodeInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getZipcodeInfoResponse*>(p->ptr), struct ns1__getZipcodeInfoResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getZipcodeInfoResponse*>(p->ptr), struct ns1__getZipcodeInfoResponse);
		break;
	case SOAP_TYPE_ns1__getZipcodeInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getZipcodeInfo*>(p->ptr), struct ns1__getZipcodeInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getZipcodeInfo*>(p->ptr), struct ns1__getZipcodeInfo);
		break;
	case SOAP_TYPE_ns1__fccGetCallsignResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__fccGetCallsignResponse*>(p->ptr), struct ns1__fccGetCallsignResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__fccGetCallsignResponse*>(p->ptr), struct ns1__fccGetCallsignResponse);
		break;
	case SOAP_TYPE_ns1__fccGetCallsign:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__fccGetCallsign*>(p->ptr), struct ns1__fccGetCallsign);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__fccGetCallsign*>(p->ptr), struct ns1__fccGetCallsign);
		break;
	case SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__fccGetRadioServiceCodeResponse*>(p->ptr), struct ns1__fccGetRadioServiceCodeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__fccGetRadioServiceCodeResponse*>(p->ptr), struct ns1__fccGetRadioServiceCodeResponse);
		break;
	case SOAP_TYPE_ns1__fccGetRadioServiceCode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__fccGetRadioServiceCode*>(p->ptr), struct ns1__fccGetRadioServiceCode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__fccGetRadioServiceCode*>(p->ptr), struct ns1__fccGetRadioServiceCode);
		break;
	case SOAP_TYPE_ns1__fccGetProxCallsignsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__fccGetProxCallsignsResponse*>(p->ptr), struct ns1__fccGetProxCallsignsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__fccGetProxCallsignsResponse*>(p->ptr), struct ns1__fccGetProxCallsignsResponse);
		break;
	case SOAP_TYPE_ns1__fccGetProxCallsigns:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__fccGetProxCallsigns*>(p->ptr), struct ns1__fccGetProxCallsigns);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__fccGetProxCallsigns*>(p->ptr), struct ns1__fccGetProxCallsigns);
		break;
	case SOAP_TYPE_ns1__getUserDataResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getUserDataResponse*>(p->ptr), struct ns1__getUserDataResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getUserDataResponse*>(p->ptr), struct ns1__getUserDataResponse);
		break;
	case SOAP_TYPE_ns1__getUserData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getUserData*>(p->ptr), struct ns1__getUserData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getUserData*>(p->ptr), struct ns1__getUserData);
		break;
	case SOAP_TYPE_ns1__getUserFeedBroadcastsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getUserFeedBroadcastsResponse*>(p->ptr), struct ns1__getUserFeedBroadcastsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getUserFeedBroadcastsResponse*>(p->ptr), struct ns1__getUserFeedBroadcastsResponse);
		break;
	case SOAP_TYPE_ns1__getUserFeedBroadcasts:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct ns1__getUserFeedBroadcasts*>(p->ptr), struct ns1__getUserFeedBroadcasts);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct ns1__getUserFeedBroadcasts*>(p->ptr), struct ns1__getUserFeedBroadcasts);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 rrapi__fbase(int t, int b)
{
	(void)t; (void)b; /* appease -Wall -Werror */
	return 0;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 rrapi__finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_SOAP_ENC__Array:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy SOAP_ENC__Array type=%d location=%p object=%p\n", t, p, q));
		*(SOAP_ENC__Array*)p = *(SOAP_ENC__Array*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__authInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__authInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__authInfo*)p = *(ns1__authInfo*)q;
		break;
	case SOAP_TYPE_ns1__userFeedBroadcast:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__userFeedBroadcast type=%d location=%p object=%p\n", t, p, q));
		*(ns1__userFeedBroadcast*)p = *(ns1__userFeedBroadcast*)q;
		break;
	case SOAP_TYPE_ns1__Talkgroup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Talkgroup type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Talkgroup*)p = *(ns1__Talkgroup*)q;
		break;
	case SOAP_TYPE_ns1__TalkgroupCat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TalkgroupCat type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TalkgroupCat*)p = *(ns1__TalkgroupCat*)q;
		break;
	case SOAP_TYPE_ns1__TrsSite:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TrsSite type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TrsSite*)p = *(ns1__TrsSite*)q;
		break;
	case SOAP_TYPE_ns1__TrsSiteFreq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TrsSiteFreq type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TrsSiteFreq*)p = *(ns1__TrsSiteFreq*)q;
		break;
	case SOAP_TYPE_ns1__TrsSiteLicense:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TrsSiteLicense type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TrsSiteLicense*)p = *(ns1__TrsSiteLicense*)q;
		break;
	case SOAP_TYPE_ns1__Trs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Trs type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Trs*)p = *(ns1__Trs*)q;
		break;
	case SOAP_TYPE_ns1__TrsListDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TrsListDef type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TrsListDef*)p = *(ns1__TrsListDef*)q;
		break;
	case SOAP_TYPE_ns1__trsSysidDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__trsSysidDef type=%d location=%p object=%p\n", t, p, q));
		*(ns1__trsSysidDef*)p = *(ns1__trsSysidDef*)q;
		break;
	case SOAP_TYPE_ns1__trsBandplanDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__trsBandplanDef type=%d location=%p object=%p\n", t, p, q));
		*(ns1__trsBandplanDef*)p = *(ns1__trsBandplanDef*)q;
		break;
	case SOAP_TYPE_ns1__TrsFleetmap:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__TrsFleetmap type=%d location=%p object=%p\n", t, p, q));
		*(ns1__TrsFleetmap*)p = *(ns1__TrsFleetmap*)q;
		break;
	case SOAP_TYPE_ns1__trsTypeDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__trsTypeDef type=%d location=%p object=%p\n", t, p, q));
		*(ns1__trsTypeDef*)p = *(ns1__trsTypeDef*)q;
		break;
	case SOAP_TYPE_ns1__trsFlavorDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__trsFlavorDef type=%d location=%p object=%p\n", t, p, q));
		*(ns1__trsFlavorDef*)p = *(ns1__trsFlavorDef*)q;
		break;
	case SOAP_TYPE_ns1__trsVoiceDef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__trsVoiceDef type=%d location=%p object=%p\n", t, p, q));
		*(ns1__trsVoiceDef*)p = *(ns1__trsVoiceDef*)q;
		break;
	case SOAP_TYPE_ns1__freq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__freq type=%d location=%p object=%p\n", t, p, q));
		*(ns1__freq*)p = *(ns1__freq*)q;
		break;
	case SOAP_TYPE_ns1__searchFreqResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__searchFreqResult type=%d location=%p object=%p\n", t, p, q));
		*(ns1__searchFreqResult*)p = *(ns1__searchFreqResult*)q;
		break;
	case SOAP_TYPE_ns1__cat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__cat type=%d location=%p object=%p\n", t, p, q));
		*(ns1__cat*)p = *(ns1__cat*)q;
		break;
	case SOAP_TYPE_ns1__subcat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__subcat type=%d location=%p object=%p\n", t, p, q));
		*(ns1__subcat*)p = *(ns1__subcat*)q;
		break;
	case SOAP_TYPE_ns1__AgencyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__AgencyInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__AgencyInfo*)p = *(ns1__AgencyInfo*)q;
		break;
	case SOAP_TYPE_ns1__CountryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CountryInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CountryInfo*)p = *(ns1__CountryInfo*)q;
		break;
	case SOAP_TYPE_ns1__CountyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__CountyInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__CountyInfo*)p = *(ns1__CountyInfo*)q;
		break;
	case SOAP_TYPE_ns1__StateInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__StateInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__StateInfo*)p = *(ns1__StateInfo*)q;
		break;
	case SOAP_TYPE_ns1__County:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__County type=%d location=%p object=%p\n", t, p, q));
		*(ns1__County*)p = *(ns1__County*)q;
		break;
	case SOAP_TYPE_ns1__ctid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ctid type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ctid*)p = *(ns1__ctid*)q;
		break;
	case SOAP_TYPE_ns1__State:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__State type=%d location=%p object=%p\n", t, p, q));
		*(ns1__State*)p = *(ns1__State*)q;
		break;
	case SOAP_TYPE_ns1__Metro:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Metro type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Metro*)p = *(ns1__Metro*)q;
		break;
	case SOAP_TYPE_ns1__Country:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Country type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Country*)p = *(ns1__Country*)q;
		break;
	case SOAP_TYPE_ns1__Agency:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Agency type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Agency*)p = *(ns1__Agency*)q;
		break;
	case SOAP_TYPE_ns1__stid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__stid type=%d location=%p object=%p\n", t, p, q));
		*(ns1__stid*)p = *(ns1__stid*)q;
		break;
	case SOAP_TYPE_ns1__sid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__sid type=%d location=%p object=%p\n", t, p, q));
		*(ns1__sid*)p = *(ns1__sid*)q;
		break;
	case SOAP_TYPE_ns1__tag:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__tag type=%d location=%p object=%p\n", t, p, q));
		*(ns1__tag*)p = *(ns1__tag*)q;
		break;
	case SOAP_TYPE_ns1__mode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__mode type=%d location=%p object=%p\n", t, p, q));
		*(ns1__mode*)p = *(ns1__mode*)q;
		break;
	case SOAP_TYPE_ns1__ZipInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ZipInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ZipInfo*)p = *(ns1__ZipInfo*)q;
		break;
	case SOAP_TYPE_ns1__UserInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__UserInfo type=%d location=%p object=%p\n", t, p, q));
		*(ns1__UserInfo*)p = *(ns1__UserInfo*)q;
		break;
	case SOAP_TYPE_ns1__fccCallsignDetails:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__fccCallsignDetails type=%d location=%p object=%p\n", t, p, q));
		*(ns1__fccCallsignDetails*)p = *(ns1__fccCallsignDetails*)q;
		break;
	case SOAP_TYPE_ns1__fccFrequency:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__fccFrequency type=%d location=%p object=%p\n", t, p, q));
		*(ns1__fccFrequency*)p = *(ns1__fccFrequency*)q;
		break;
	case SOAP_TYPE_ns1__fccLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__fccLocation type=%d location=%p object=%p\n", t, p, q));
		*(ns1__fccLocation*)p = *(ns1__fccLocation*)q;
		break;
	case SOAP_TYPE_ns1__proxCallsignResult:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__proxCallsignResult type=%d location=%p object=%p\n", t, p, q));
		*(ns1__proxCallsignResult*)p = *(ns1__proxCallsignResult*)q;
		break;
	case SOAP_TYPE_ns1__fccRadioServiceCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__fccRadioServiceCode type=%d location=%p object=%p\n", t, p, q));
		*(ns1__fccRadioServiceCode*)p = *(ns1__fccRadioServiceCode*)q;
		break;
	case SOAP_TYPE_userFeedBroadcasts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy userFeedBroadcasts type=%d location=%p object=%p\n", t, p, q));
		*(userFeedBroadcasts*)p = *(userFeedBroadcasts*)q;
		break;
	case SOAP_TYPE_stidList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy stidList type=%d location=%p object=%p\n", t, p, q));
		*(stidList*)p = *(stidList*)q;
		break;
	case SOAP_TYPE_ctidList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ctidList type=%d location=%p object=%p\n", t, p, q));
		*(ctidList*)p = *(ctidList*)q;
		break;
	case SOAP_TYPE_Talkgroups:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Talkgroups type=%d location=%p object=%p\n", t, p, q));
		*(Talkgroups*)p = *(Talkgroups*)q;
		break;
	case SOAP_TYPE_TalkgroupCats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TalkgroupCats type=%d location=%p object=%p\n", t, p, q));
		*(TalkgroupCats*)p = *(TalkgroupCats*)q;
		break;
	case SOAP_TYPE_TrsSites:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsSites type=%d location=%p object=%p\n", t, p, q));
		*(TrsSites*)p = *(TrsSites*)q;
		break;
	case SOAP_TYPE_TrsSiteFreqs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsSiteFreqs type=%d location=%p object=%p\n", t, p, q));
		*(TrsSiteFreqs*)p = *(TrsSiteFreqs*)q;
		break;
	case SOAP_TYPE_TrsSiteLicenses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsSiteLicenses type=%d location=%p object=%p\n", t, p, q));
		*(TrsSiteLicenses*)p = *(TrsSiteLicenses*)q;
		break;
	case SOAP_TYPE_TrsList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsList type=%d location=%p object=%p\n", t, p, q));
		*(TrsList*)p = *(TrsList*)q;
		break;
	case SOAP_TYPE_TrsSysid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsSysid type=%d location=%p object=%p\n", t, p, q));
		*(TrsSysid*)p = *(TrsSysid*)q;
		break;
	case SOAP_TYPE_TrsBandplan:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsBandplan type=%d location=%p object=%p\n", t, p, q));
		*(TrsBandplan*)p = *(TrsBandplan*)q;
		break;
	case SOAP_TYPE_TrsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsType type=%d location=%p object=%p\n", t, p, q));
		*(TrsType*)p = *(TrsType*)q;
		break;
	case SOAP_TYPE_TrsFlavor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsFlavor type=%d location=%p object=%p\n", t, p, q));
		*(TrsFlavor*)p = *(TrsFlavor*)q;
		break;
	case SOAP_TYPE_TrsVoice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy TrsVoice type=%d location=%p object=%p\n", t, p, q));
		*(TrsVoice*)p = *(TrsVoice*)q;
		break;
	case SOAP_TYPE_searchFreqResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy searchFreqResults type=%d location=%p object=%p\n", t, p, q));
		*(searchFreqResults*)p = *(searchFreqResults*)q;
		break;
	case SOAP_TYPE_Freqs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Freqs type=%d location=%p object=%p\n", t, p, q));
		*(Freqs*)p = *(Freqs*)q;
		break;
	case SOAP_TYPE_Cats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Cats type=%d location=%p object=%p\n", t, p, q));
		*(Cats*)p = *(Cats*)q;
		break;
	case SOAP_TYPE_SubCats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy SubCats type=%d location=%p object=%p\n", t, p, q));
		*(SubCats*)p = *(SubCats*)q;
		break;
	case SOAP_TYPE_Counties:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Counties type=%d location=%p object=%p\n", t, p, q));
		*(Counties*)p = *(Counties*)q;
		break;
	case SOAP_TYPE_ctids:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ctids type=%d location=%p object=%p\n", t, p, q));
		*(ctids*)p = *(ctids*)q;
		break;
	case SOAP_TYPE_States:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy States type=%d location=%p object=%p\n", t, p, q));
		*(States*)p = *(States*)q;
		break;
	case SOAP_TYPE_Metros:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Metros type=%d location=%p object=%p\n", t, p, q));
		*(Metros*)p = *(Metros*)q;
		break;
	case SOAP_TYPE_Countries:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Countries type=%d location=%p object=%p\n", t, p, q));
		*(Countries*)p = *(Countries*)q;
		break;
	case SOAP_TYPE_Agencies:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy Agencies type=%d location=%p object=%p\n", t, p, q));
		*(Agencies*)p = *(Agencies*)q;
		break;
	case SOAP_TYPE_stids:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy stids type=%d location=%p object=%p\n", t, p, q));
		*(stids*)p = *(stids*)q;
		break;
	case SOAP_TYPE_sids:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy sids type=%d location=%p object=%p\n", t, p, q));
		*(sids*)p = *(sids*)q;
		break;
	case SOAP_TYPE_tags:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tags type=%d location=%p object=%p\n", t, p, q));
		*(tags*)p = *(tags*)q;
		break;
	case SOAP_TYPE_modes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy modes type=%d location=%p object=%p\n", t, p, q));
		*(modes*)p = *(modes*)q;
		break;
	case SOAP_TYPE_fccFrequencies:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy fccFrequencies type=%d location=%p object=%p\n", t, p, q));
		*(fccFrequencies*)p = *(fccFrequencies*)q;
		break;
	case SOAP_TYPE_fccLocations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy fccLocations type=%d location=%p object=%p\n", t, p, q));
		*(fccLocations*)p = *(fccLocations*)q;
		break;
	case SOAP_TYPE_proxCallsignResults:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy proxCallsignResults type=%d location=%p object=%p\n", t, p, q));
		*(proxCallsignResults*)p = *(proxCallsignResults*)q;
		break;
	case SOAP_TYPE_fccRadioServiceCodes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy fccRadioServiceCodes type=%d location=%p object=%p\n", t, p, q));
		*(fccRadioServiceCodes*)p = *(fccRadioServiceCodes*)q;
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsTalkgroupsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsTalkgroupsResponse*)p = *(struct ns1__getTrsTalkgroupsResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroups:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsTalkgroups type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsTalkgroups*)p = *(struct ns1__getTrsTalkgroups*)q;
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsTalkgroupCatsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsTalkgroupCatsResponse*)p = *(struct ns1__getTrsTalkgroupCatsResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsTalkgroupCats:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsTalkgroupCats type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsTalkgroupCats*)p = *(struct ns1__getTrsTalkgroupCats*)q;
		break;
	case SOAP_TYPE_ns1__getTrsDetailsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsDetailsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsDetailsResponse*)p = *(struct ns1__getTrsDetailsResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsDetails:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsDetails type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsDetails*)p = *(struct ns1__getTrsDetails*)q;
		break;
	case SOAP_TYPE_ns1__getTrsBySysidResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsBySysidResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsBySysidResponse*)p = *(struct ns1__getTrsBySysidResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsBySysid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsBySysid type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsBySysid*)p = *(struct ns1__getTrsBySysid*)q;
		break;
	case SOAP_TYPE_ns1__getTrsSitesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsSitesResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsSitesResponse*)p = *(struct ns1__getTrsSitesResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsSites:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsSites type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsSites*)p = *(struct ns1__getTrsSites*)q;
		break;
	case SOAP_TYPE_ns1__getStatesByListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getStatesByListResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getStatesByListResponse*)p = *(struct ns1__getStatesByListResponse*)q;
		break;
	case SOAP_TYPE_ns1__getStatesByList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getStatesByList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getStatesByList*)p = *(struct ns1__getStatesByList*)q;
		break;
	case SOAP_TYPE_ns1__getCountiesByListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountiesByListResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountiesByListResponse*)p = *(struct ns1__getCountiesByListResponse*)q;
		break;
	case SOAP_TYPE_ns1__getCountiesByList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountiesByList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountiesByList*)p = *(struct ns1__getCountiesByList*)q;
		break;
	case SOAP_TYPE_ns1__getTagResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTagResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTagResponse*)p = *(struct ns1__getTagResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTag:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTag type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTag*)p = *(struct ns1__getTag*)q;
		break;
	case SOAP_TYPE_ns1__getModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getModeResponse*)p = *(struct ns1__getModeResponse*)q;
		break;
	case SOAP_TYPE_ns1__getMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getMode type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getMode*)p = *(struct ns1__getMode*)q;
		break;
	case SOAP_TYPE_ns1__getTrsTypeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsTypeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsTypeResponse*)p = *(struct ns1__getTrsTypeResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsType type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsType*)p = *(struct ns1__getTrsType*)q;
		break;
	case SOAP_TYPE_ns1__getTrsFlavorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsFlavorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsFlavorResponse*)p = *(struct ns1__getTrsFlavorResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsFlavor:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsFlavor type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsFlavor*)p = *(struct ns1__getTrsFlavor*)q;
		break;
	case SOAP_TYPE_ns1__getTrsVoiceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsVoiceResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsVoiceResponse*)p = *(struct ns1__getTrsVoiceResponse*)q;
		break;
	case SOAP_TYPE_ns1__getTrsVoice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getTrsVoice type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getTrsVoice*)p = *(struct ns1__getTrsVoice*)q;
		break;
	case SOAP_TYPE_ns1__getCountryListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountryListResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountryListResponse*)p = *(struct ns1__getCountryListResponse*)q;
		break;
	case SOAP_TYPE_ns1__getCountryList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountryList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountryList*)p = *(struct ns1__getCountryList*)q;
		break;
	case SOAP_TYPE_ns1__getCountryInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountryInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountryInfoResponse*)p = *(struct ns1__getCountryInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getCountryInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountryInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountryInfo*)p = *(struct ns1__getCountryInfo*)q;
		break;
	case SOAP_TYPE_ns1__getStateInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getStateInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getStateInfoResponse*)p = *(struct ns1__getStateInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getStateInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getStateInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getStateInfo*)p = *(struct ns1__getStateInfo*)q;
		break;
	case SOAP_TYPE_ns1__getCountyInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountyInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountyInfoResponse*)p = *(struct ns1__getCountyInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getCountyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountyInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountyInfo*)p = *(struct ns1__getCountyInfo*)q;
		break;
	case SOAP_TYPE_ns1__getAgencyInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getAgencyInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getAgencyInfoResponse*)p = *(struct ns1__getAgencyInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getAgencyInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getAgencyInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getAgencyInfo*)p = *(struct ns1__getAgencyInfo*)q;
		break;
	case SOAP_TYPE_ns1__getSubcatFreqsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getSubcatFreqsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getSubcatFreqsResponse*)p = *(struct ns1__getSubcatFreqsResponse*)q;
		break;
	case SOAP_TYPE_ns1__getSubcatFreqs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getSubcatFreqs type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getSubcatFreqs*)p = *(struct ns1__getSubcatFreqs*)q;
		break;
	case SOAP_TYPE_ns1__searchCountyFreqResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__searchCountyFreqResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__searchCountyFreqResponse*)p = *(struct ns1__searchCountyFreqResponse*)q;
		break;
	case SOAP_TYPE_ns1__searchCountyFreq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__searchCountyFreq type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__searchCountyFreq*)p = *(struct ns1__searchCountyFreq*)q;
		break;
	case SOAP_TYPE_ns1__searchStateFreqResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__searchStateFreqResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__searchStateFreqResponse*)p = *(struct ns1__searchStateFreqResponse*)q;
		break;
	case SOAP_TYPE_ns1__searchStateFreq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__searchStateFreq type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__searchStateFreq*)p = *(struct ns1__searchStateFreq*)q;
		break;
	case SOAP_TYPE_ns1__searchMetroFreqResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__searchMetroFreqResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__searchMetroFreqResponse*)p = *(struct ns1__searchMetroFreqResponse*)q;
		break;
	case SOAP_TYPE_ns1__searchMetroFreq:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__searchMetroFreq type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__searchMetroFreq*)p = *(struct ns1__searchMetroFreq*)q;
		break;
	case SOAP_TYPE_ns1__getCountyFreqsByTagResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountyFreqsByTagResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountyFreqsByTagResponse*)p = *(struct ns1__getCountyFreqsByTagResponse*)q;
		break;
	case SOAP_TYPE_ns1__getCountyFreqsByTag:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getCountyFreqsByTag type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getCountyFreqsByTag*)p = *(struct ns1__getCountyFreqsByTag*)q;
		break;
	case SOAP_TYPE_ns1__getAgencyFreqsByTagResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getAgencyFreqsByTagResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getAgencyFreqsByTagResponse*)p = *(struct ns1__getAgencyFreqsByTagResponse*)q;
		break;
	case SOAP_TYPE_ns1__getAgencyFreqsByTag:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getAgencyFreqsByTag type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getAgencyFreqsByTag*)p = *(struct ns1__getAgencyFreqsByTag*)q;
		break;
	case SOAP_TYPE_ns1__getMetroAreaResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getMetroAreaResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getMetroAreaResponse*)p = *(struct ns1__getMetroAreaResponse*)q;
		break;
	case SOAP_TYPE_ns1__getMetroArea:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getMetroArea type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getMetroArea*)p = *(struct ns1__getMetroArea*)q;
		break;
	case SOAP_TYPE_ns1__getMetroAreaInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getMetroAreaInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getMetroAreaInfoResponse*)p = *(struct ns1__getMetroAreaInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getMetroAreaInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getMetroAreaInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getMetroAreaInfo*)p = *(struct ns1__getMetroAreaInfo*)q;
		break;
	case SOAP_TYPE_ns1__getZipcodeInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getZipcodeInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getZipcodeInfoResponse*)p = *(struct ns1__getZipcodeInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getZipcodeInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getZipcodeInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getZipcodeInfo*)p = *(struct ns1__getZipcodeInfo*)q;
		break;
	case SOAP_TYPE_ns1__fccGetCallsignResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fccGetCallsignResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fccGetCallsignResponse*)p = *(struct ns1__fccGetCallsignResponse*)q;
		break;
	case SOAP_TYPE_ns1__fccGetCallsign:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fccGetCallsign type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fccGetCallsign*)p = *(struct ns1__fccGetCallsign*)q;
		break;
	case SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fccGetRadioServiceCodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fccGetRadioServiceCodeResponse*)p = *(struct ns1__fccGetRadioServiceCodeResponse*)q;
		break;
	case SOAP_TYPE_ns1__fccGetRadioServiceCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fccGetRadioServiceCode type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fccGetRadioServiceCode*)p = *(struct ns1__fccGetRadioServiceCode*)q;
		break;
	case SOAP_TYPE_ns1__fccGetProxCallsignsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fccGetProxCallsignsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fccGetProxCallsignsResponse*)p = *(struct ns1__fccGetProxCallsignsResponse*)q;
		break;
	case SOAP_TYPE_ns1__fccGetProxCallsigns:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fccGetProxCallsigns type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fccGetProxCallsigns*)p = *(struct ns1__fccGetProxCallsigns*)q;
		break;
	case SOAP_TYPE_ns1__getUserDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getUserDataResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getUserDataResponse*)p = *(struct ns1__getUserDataResponse*)q;
		break;
	case SOAP_TYPE_ns1__getUserData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getUserData type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getUserData*)p = *(struct ns1__getUserData*)q;
		break;
	case SOAP_TYPE_ns1__getUserFeedBroadcastsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getUserFeedBroadcastsResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getUserFeedBroadcastsResponse*)p = *(struct ns1__getUserFeedBroadcastsResponse*)q;
		break;
	case SOAP_TYPE_ns1__getUserFeedBroadcasts:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getUserFeedBroadcasts type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getUserFeedBroadcasts*)p = *(struct ns1__getUserFeedBroadcasts*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void fccRadioServiceCodes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void fccRadioServiceCodes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_fccRadioServiceCodes))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__fccRadioServiceCode(soap, this->__ptr + i);
		}
	}
#endif
}

int fccRadioServiceCodes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fccRadioServiceCodes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fccRadioServiceCodes(struct soap *soap, const char *tag, int id, const fccRadioServiceCodes *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:fccRadioServiceCode", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_fccRadioServiceCodes, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__fccRadioServiceCode(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *fccRadioServiceCodes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_fccRadioServiceCodes(soap, tag, this, type);
}

SOAP_FMAC3 fccRadioServiceCodes * SOAP_FMAC4 soap_in_fccRadioServiceCodes(struct soap *soap, const char *tag, fccRadioServiceCodes *a, const char *type)
{
	int i, j;
	ns1__fccRadioServiceCode **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (fccRadioServiceCodes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fccRadioServiceCodes, sizeof(fccRadioServiceCodes), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__fccRadioServiceCode **)soap_malloc(soap, sizeof(ns1__fccRadioServiceCode *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__fccRadioServiceCode(soap, NULL, a->__ptr + i, "ns1:fccRadioServiceCode"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__fccRadioServiceCode **)soap_push_block(soap, NULL, sizeof(ns1__fccRadioServiceCode *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__fccRadioServiceCode(soap, NULL, p, "ns1:fccRadioServiceCode"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__fccRadioServiceCode **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fccRadioServiceCodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fccRadioServiceCodes, SOAP_TYPE_fccRadioServiceCodes, sizeof(fccRadioServiceCodes), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 fccRadioServiceCodes * SOAP_FMAC2 rrapi__instantiate_fccRadioServiceCodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_fccRadioServiceCodes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	fccRadioServiceCodes *p;
	size_t k = sizeof(fccRadioServiceCodes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_fccRadioServiceCodes, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, fccRadioServiceCodes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, fccRadioServiceCodes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated fccRadioServiceCodes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int fccRadioServiceCodes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_fccRadioServiceCodes(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fccRadioServiceCodes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fccRadioServiceCodes(soap, this, tag, type);
}

SOAP_FMAC3 fccRadioServiceCodes * SOAP_FMAC4 soap_get_fccRadioServiceCodes(struct soap *soap, fccRadioServiceCodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_fccRadioServiceCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__fccRadioServiceCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__fccRadioServiceCode::code);
	soap_default_std__string(soap, &this->ns1__fccRadioServiceCode::description);
}

void ns1__fccRadioServiceCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__fccRadioServiceCode::code);
	soap_serialize_std__string(soap, &this->ns1__fccRadioServiceCode::description);
#endif
}

int ns1__fccRadioServiceCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fccRadioServiceCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccRadioServiceCode(struct soap *soap, const char *tag, int id, const ns1__fccRadioServiceCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccRadioServiceCode), type))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->ns1__fccRadioServiceCode::code, ""))
		return soap->error;
	if (soap_out_std__string(soap, "description", -1, &a->ns1__fccRadioServiceCode::description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__fccRadioServiceCode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__fccRadioServiceCode(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fccRadioServiceCode * SOAP_FMAC4 soap_in_ns1__fccRadioServiceCode(struct soap *soap, const char *tag, ns1__fccRadioServiceCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fccRadioServiceCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccRadioServiceCode, sizeof(ns1__fccRadioServiceCode), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__fccRadioServiceCode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__fccRadioServiceCode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_code1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "code", &a->ns1__fccRadioServiceCode::code, "xsd:string"))
				{	soap_flag_code1--;
					continue;
				}
			}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "description", &a->ns1__fccRadioServiceCode::description, "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code1 > 0 || soap_flag_description1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__fccRadioServiceCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccRadioServiceCode, SOAP_TYPE_ns1__fccRadioServiceCode, sizeof(ns1__fccRadioServiceCode), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__fccRadioServiceCode * SOAP_FMAC2 rrapi__instantiate_ns1__fccRadioServiceCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccRadioServiceCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__fccRadioServiceCode *p;
	size_t k = sizeof(ns1__fccRadioServiceCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccRadioServiceCode, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__fccRadioServiceCode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__fccRadioServiceCode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__fccRadioServiceCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__fccRadioServiceCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__fccRadioServiceCode(soap, tag ? tag : "ns1:fccRadioServiceCode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fccRadioServiceCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fccRadioServiceCode(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fccRadioServiceCode * SOAP_FMAC4 soap_get_ns1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccRadioServiceCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void proxCallsignResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void proxCallsignResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_proxCallsignResults))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__proxCallsignResult(soap, this->__ptr + i);
		}
	}
#endif
}

int proxCallsignResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_proxCallsignResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_proxCallsignResults(struct soap *soap, const char *tag, int id, const proxCallsignResults *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:proxCallsignResult", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_proxCallsignResults, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__proxCallsignResult(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *proxCallsignResults::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_proxCallsignResults(soap, tag, this, type);
}

SOAP_FMAC3 proxCallsignResults * SOAP_FMAC4 soap_in_proxCallsignResults(struct soap *soap, const char *tag, proxCallsignResults *a, const char *type)
{
	int i, j;
	ns1__proxCallsignResult **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (proxCallsignResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_proxCallsignResults, sizeof(proxCallsignResults), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__proxCallsignResult **)soap_malloc(soap, sizeof(ns1__proxCallsignResult *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__proxCallsignResult(soap, NULL, a->__ptr + i, "ns1:proxCallsignResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__proxCallsignResult **)soap_push_block(soap, NULL, sizeof(ns1__proxCallsignResult *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__proxCallsignResult(soap, NULL, p, "ns1:proxCallsignResult"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__proxCallsignResult **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (proxCallsignResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_proxCallsignResults, SOAP_TYPE_proxCallsignResults, sizeof(proxCallsignResults), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 proxCallsignResults * SOAP_FMAC2 rrapi__instantiate_proxCallsignResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_proxCallsignResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	proxCallsignResults *p;
	size_t k = sizeof(proxCallsignResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_proxCallsignResults, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, proxCallsignResults);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, proxCallsignResults, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated proxCallsignResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int proxCallsignResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_proxCallsignResults(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *proxCallsignResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_proxCallsignResults(soap, this, tag, type);
}

SOAP_FMAC3 proxCallsignResults * SOAP_FMAC4 soap_get_proxCallsignResults(struct soap *soap, proxCallsignResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_proxCallsignResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__proxCallsignResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__proxCallsignResult::callsign);
	soap_default_std__string(soap, &this->ns1__proxCallsignResult::licensee);
	soap_default_xsd__decimal(soap, &this->ns1__proxCallsignResult::lat);
	soap_default_xsd__decimal(soap, &this->ns1__proxCallsignResult::lon);
	soap_default_xsd__decimal(soap, &this->ns1__proxCallsignResult::distance);
}

void ns1__proxCallsignResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__proxCallsignResult::callsign);
	soap_serialize_std__string(soap, &this->ns1__proxCallsignResult::licensee);
	soap_serialize_xsd__decimal(soap, &this->ns1__proxCallsignResult::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__proxCallsignResult::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__proxCallsignResult::distance);
#endif
}

int ns1__proxCallsignResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__proxCallsignResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__proxCallsignResult(struct soap *soap, const char *tag, int id, const ns1__proxCallsignResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__proxCallsignResult), type))
		return soap->error;
	if (soap_out_std__string(soap, "callsign", -1, &a->ns1__proxCallsignResult::callsign, ""))
		return soap->error;
	if (soap_out_std__string(soap, "licensee", -1, &a->ns1__proxCallsignResult::licensee, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__proxCallsignResult::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__proxCallsignResult::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "distance", -1, &a->ns1__proxCallsignResult::distance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__proxCallsignResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__proxCallsignResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__proxCallsignResult * SOAP_FMAC4 soap_in_ns1__proxCallsignResult(struct soap *soap, const char *tag, ns1__proxCallsignResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__proxCallsignResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__proxCallsignResult, sizeof(ns1__proxCallsignResult), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__proxCallsignResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__proxCallsignResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_callsign1 = 1;
	size_t soap_flag_licensee1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_distance1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callsign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "callsign", &a->ns1__proxCallsignResult::callsign, "xsd:string"))
				{	soap_flag_callsign1--;
					continue;
				}
			}
			if (soap_flag_licensee1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "licensee", &a->ns1__proxCallsignResult::licensee, "xsd:string"))
				{	soap_flag_licensee1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__proxCallsignResult::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__proxCallsignResult::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_distance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "distance", &a->ns1__proxCallsignResult::distance, "xsd:decimal"))
				{	soap_flag_distance1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_callsign1 > 0 || soap_flag_licensee1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_distance1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__proxCallsignResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__proxCallsignResult, SOAP_TYPE_ns1__proxCallsignResult, sizeof(ns1__proxCallsignResult), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__proxCallsignResult * SOAP_FMAC2 rrapi__instantiate_ns1__proxCallsignResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__proxCallsignResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__proxCallsignResult *p;
	size_t k = sizeof(ns1__proxCallsignResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__proxCallsignResult, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__proxCallsignResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__proxCallsignResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__proxCallsignResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__proxCallsignResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__proxCallsignResult(soap, tag ? tag : "ns1:proxCallsignResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__proxCallsignResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__proxCallsignResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__proxCallsignResult * SOAP_FMAC4 soap_get_ns1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__proxCallsignResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void fccLocations::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void fccLocations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_fccLocations))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__fccLocation(soap, this->__ptr + i);
		}
	}
#endif
}

int fccLocations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fccLocations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fccLocations(struct soap *soap, const char *tag, int id, const fccLocations *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:fccLocation", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_fccLocations, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__fccLocation(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *fccLocations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_fccLocations(soap, tag, this, type);
}

SOAP_FMAC3 fccLocations * SOAP_FMAC4 soap_in_fccLocations(struct soap *soap, const char *tag, fccLocations *a, const char *type)
{
	int i, j;
	ns1__fccLocation **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (fccLocations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fccLocations, sizeof(fccLocations), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__fccLocation **)soap_malloc(soap, sizeof(ns1__fccLocation *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__fccLocation(soap, NULL, a->__ptr + i, "ns1:fccLocation"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__fccLocation **)soap_push_block(soap, NULL, sizeof(ns1__fccLocation *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__fccLocation(soap, NULL, p, "ns1:fccLocation"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__fccLocation **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fccLocations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fccLocations, SOAP_TYPE_fccLocations, sizeof(fccLocations), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 fccLocations * SOAP_FMAC2 rrapi__instantiate_fccLocations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_fccLocations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	fccLocations *p;
	size_t k = sizeof(fccLocations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_fccLocations, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, fccLocations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, fccLocations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated fccLocations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int fccLocations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_fccLocations(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fccLocations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fccLocations(soap, this, tag, type);
}

SOAP_FMAC3 fccLocations * SOAP_FMAC4 soap_get_fccLocations(struct soap *soap, fccLocations *p, const char *tag, const char *type)
{
	if ((p = soap_in_fccLocations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__fccLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__fccLocation::locationNumber);
	soap_default_std__string(soap, &this->ns1__fccLocation::towerId);
	soap_default_std__string(soap, &this->ns1__fccLocation::type);
	soap_default_xsd__decimal(soap, &this->ns1__fccLocation::antennaHeight);
	soap_default_xsd__decimal(soap, &this->ns1__fccLocation::structureHeight);
	soap_default_xsd__decimal(soap, &this->ns1__fccLocation::elevation);
	soap_default_std__string(soap, &this->ns1__fccLocation::address);
	soap_default_xsd__decimal(soap, &this->ns1__fccLocation::lat);
	soap_default_xsd__decimal(soap, &this->ns1__fccLocation::lon);
	soap_default_std__string(soap, &this->ns1__fccLocation::city);
	soap_default_std__string(soap, &this->ns1__fccLocation::county);
	soap_default_std__string(soap, &this->ns1__fccLocation::state);
}

void ns1__fccLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__fccLocation::towerId);
	soap_serialize_std__string(soap, &this->ns1__fccLocation::type);
	soap_serialize_xsd__decimal(soap, &this->ns1__fccLocation::antennaHeight);
	soap_serialize_xsd__decimal(soap, &this->ns1__fccLocation::structureHeight);
	soap_serialize_xsd__decimal(soap, &this->ns1__fccLocation::elevation);
	soap_serialize_std__string(soap, &this->ns1__fccLocation::address);
	soap_serialize_xsd__decimal(soap, &this->ns1__fccLocation::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__fccLocation::lon);
	soap_serialize_std__string(soap, &this->ns1__fccLocation::city);
	soap_serialize_std__string(soap, &this->ns1__fccLocation::county);
	soap_serialize_std__string(soap, &this->ns1__fccLocation::state);
#endif
}

int ns1__fccLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fccLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccLocation(struct soap *soap, const char *tag, int id, const ns1__fccLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccLocation), type))
		return soap->error;
	if (soap_out_int(soap, "locationNumber", -1, &a->ns1__fccLocation::locationNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "towerId", -1, &a->ns1__fccLocation::towerId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "type", -1, &a->ns1__fccLocation::type, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "antennaHeight", -1, &a->ns1__fccLocation::antennaHeight, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "structureHeight", -1, &a->ns1__fccLocation::structureHeight, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "elevation", -1, &a->ns1__fccLocation::elevation, ""))
		return soap->error;
	if (soap_out_std__string(soap, "address", -1, &a->ns1__fccLocation::address, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__fccLocation::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__fccLocation::lon, ""))
		return soap->error;
	if (soap_out_std__string(soap, "city", -1, &a->ns1__fccLocation::city, ""))
		return soap->error;
	if (soap_out_std__string(soap, "county", -1, &a->ns1__fccLocation::county, ""))
		return soap->error;
	if (soap_out_std__string(soap, "state", -1, &a->ns1__fccLocation::state, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__fccLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__fccLocation(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fccLocation * SOAP_FMAC4 soap_in_ns1__fccLocation(struct soap *soap, const char *tag, ns1__fccLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fccLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccLocation, sizeof(ns1__fccLocation), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__fccLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__fccLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_locationNumber1 = 1;
	size_t soap_flag_towerId1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_antennaHeight1 = 1;
	size_t soap_flag_structureHeight1 = 1;
	size_t soap_flag_elevation1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_county1 = 1;
	size_t soap_flag_state1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locationNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "locationNumber", &a->ns1__fccLocation::locationNumber, "xsd:int"))
				{	soap_flag_locationNumber1--;
					continue;
				}
			}
			if (soap_flag_towerId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "towerId", &a->ns1__fccLocation::towerId, "xsd:string"))
				{	soap_flag_towerId1--;
					continue;
				}
			}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "type", &a->ns1__fccLocation::type, "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			}
			if (soap_flag_antennaHeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "antennaHeight", &a->ns1__fccLocation::antennaHeight, "xsd:decimal"))
				{	soap_flag_antennaHeight1--;
					continue;
				}
			}
			if (soap_flag_structureHeight1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "structureHeight", &a->ns1__fccLocation::structureHeight, "xsd:decimal"))
				{	soap_flag_structureHeight1--;
					continue;
				}
			}
			if (soap_flag_elevation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "elevation", &a->ns1__fccLocation::elevation, "xsd:decimal"))
				{	soap_flag_elevation1--;
					continue;
				}
			}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "address", &a->ns1__fccLocation::address, "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__fccLocation::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__fccLocation::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "city", &a->ns1__fccLocation::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			}
			if (soap_flag_county1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "county", &a->ns1__fccLocation::county, "xsd:string"))
				{	soap_flag_county1--;
					continue;
				}
			}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "state", &a->ns1__fccLocation::state, "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locationNumber1 > 0 || soap_flag_towerId1 > 0 || soap_flag_type1 > 0 || soap_flag_antennaHeight1 > 0 || soap_flag_structureHeight1 > 0 || soap_flag_elevation1 > 0 || soap_flag_address1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_city1 > 0 || soap_flag_county1 > 0 || soap_flag_state1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__fccLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccLocation, SOAP_TYPE_ns1__fccLocation, sizeof(ns1__fccLocation), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__fccLocation * SOAP_FMAC2 rrapi__instantiate_ns1__fccLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__fccLocation *p;
	size_t k = sizeof(ns1__fccLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccLocation, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__fccLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__fccLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__fccLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__fccLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__fccLocation(soap, tag ? tag : "ns1:fccLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fccLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fccLocation(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fccLocation * SOAP_FMAC4 soap_get_ns1__fccLocation(struct soap *soap, ns1__fccLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void fccFrequencies::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void fccFrequencies::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_fccFrequencies))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__fccFrequency(soap, this->__ptr + i);
		}
	}
#endif
}

int fccFrequencies::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fccFrequencies(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fccFrequencies(struct soap *soap, const char *tag, int id, const fccFrequencies *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:fccFrequency", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_fccFrequencies, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__fccFrequency(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *fccFrequencies::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_fccFrequencies(soap, tag, this, type);
}

SOAP_FMAC3 fccFrequencies * SOAP_FMAC4 soap_in_fccFrequencies(struct soap *soap, const char *tag, fccFrequencies *a, const char *type)
{
	int i, j;
	ns1__fccFrequency **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (fccFrequencies*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fccFrequencies, sizeof(fccFrequencies), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__fccFrequency **)soap_malloc(soap, sizeof(ns1__fccFrequency *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__fccFrequency(soap, NULL, a->__ptr + i, "ns1:fccFrequency"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__fccFrequency **)soap_push_block(soap, NULL, sizeof(ns1__fccFrequency *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__fccFrequency(soap, NULL, p, "ns1:fccFrequency"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__fccFrequency **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (fccFrequencies *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_fccFrequencies, SOAP_TYPE_fccFrequencies, sizeof(fccFrequencies), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 fccFrequencies * SOAP_FMAC2 rrapi__instantiate_fccFrequencies(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_fccFrequencies(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	fccFrequencies *p;
	size_t k = sizeof(fccFrequencies);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_fccFrequencies, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, fccFrequencies);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, fccFrequencies, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated fccFrequencies location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int fccFrequencies::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_fccFrequencies(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *fccFrequencies::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fccFrequencies(soap, this, tag, type);
}

SOAP_FMAC3 fccFrequencies * SOAP_FMAC4 soap_get_fccFrequencies(struct soap *soap, fccFrequencies *p, const char *tag, const char *type)
{
	if ((p = soap_in_fccFrequencies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__fccFrequency::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__fccFrequency::locationNumber);
	soap_default_xsd__decimal(soap, &this->ns1__fccFrequency::frequency);
	soap_default_std__string(soap, &this->ns1__fccFrequency::emission);
	soap_default_std__string(soap, &this->ns1__fccFrequency::class_);
	soap_default_xsd__decimal(soap, &this->ns1__fccFrequency::power);
	soap_default_int(soap, &this->ns1__fccFrequency::mobiles);
	soap_default_int(soap, &this->ns1__fccFrequency::pagers);
}

void ns1__fccFrequency::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &this->ns1__fccFrequency::frequency);
	soap_serialize_std__string(soap, &this->ns1__fccFrequency::emission);
	soap_serialize_std__string(soap, &this->ns1__fccFrequency::class_);
	soap_serialize_xsd__decimal(soap, &this->ns1__fccFrequency::power);
#endif
}

int ns1__fccFrequency::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fccFrequency(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccFrequency(struct soap *soap, const char *tag, int id, const ns1__fccFrequency *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccFrequency), type))
		return soap->error;
	if (soap_out_int(soap, "locationNumber", -1, &a->ns1__fccFrequency::locationNumber, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "frequency", -1, &a->ns1__fccFrequency::frequency, ""))
		return soap->error;
	if (soap_out_std__string(soap, "emission", -1, &a->ns1__fccFrequency::emission, ""))
		return soap->error;
	if (soap_out_std__string(soap, "class", -1, &a->ns1__fccFrequency::class_, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "power", -1, &a->ns1__fccFrequency::power, ""))
		return soap->error;
	if (soap_out_int(soap, "mobiles", -1, &a->ns1__fccFrequency::mobiles, ""))
		return soap->error;
	if (soap_out_int(soap, "pagers", -1, &a->ns1__fccFrequency::pagers, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__fccFrequency::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__fccFrequency(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fccFrequency * SOAP_FMAC4 soap_in_ns1__fccFrequency(struct soap *soap, const char *tag, ns1__fccFrequency *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fccFrequency*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccFrequency, sizeof(ns1__fccFrequency), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__fccFrequency)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__fccFrequency *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_locationNumber1 = 1;
	size_t soap_flag_frequency1 = 1;
	size_t soap_flag_emission1 = 1;
	size_t soap_flag_class_1 = 1;
	size_t soap_flag_power1 = 1;
	size_t soap_flag_mobiles1 = 1;
	size_t soap_flag_pagers1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locationNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "locationNumber", &a->ns1__fccFrequency::locationNumber, "xsd:int"))
				{	soap_flag_locationNumber1--;
					continue;
				}
			}
			if (soap_flag_frequency1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "frequency", &a->ns1__fccFrequency::frequency, "xsd:decimal"))
				{	soap_flag_frequency1--;
					continue;
				}
			}
			if (soap_flag_emission1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "emission", &a->ns1__fccFrequency::emission, "xsd:string"))
				{	soap_flag_emission1--;
					continue;
				}
			}
			if (soap_flag_class_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "class", &a->ns1__fccFrequency::class_, "xsd:string"))
				{	soap_flag_class_1--;
					continue;
				}
			}
			if (soap_flag_power1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "power", &a->ns1__fccFrequency::power, "xsd:decimal"))
				{	soap_flag_power1--;
					continue;
				}
			}
			if (soap_flag_mobiles1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mobiles", &a->ns1__fccFrequency::mobiles, "xsd:int"))
				{	soap_flag_mobiles1--;
					continue;
				}
			}
			if (soap_flag_pagers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "pagers", &a->ns1__fccFrequency::pagers, "xsd:int"))
				{	soap_flag_pagers1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locationNumber1 > 0 || soap_flag_frequency1 > 0 || soap_flag_emission1 > 0 || soap_flag_class_1 > 0 || soap_flag_power1 > 0 || soap_flag_mobiles1 > 0 || soap_flag_pagers1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__fccFrequency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccFrequency, SOAP_TYPE_ns1__fccFrequency, sizeof(ns1__fccFrequency), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__fccFrequency * SOAP_FMAC2 rrapi__instantiate_ns1__fccFrequency(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccFrequency(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__fccFrequency *p;
	size_t k = sizeof(ns1__fccFrequency);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccFrequency, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__fccFrequency);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__fccFrequency, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__fccFrequency location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__fccFrequency::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__fccFrequency(soap, tag ? tag : "ns1:fccFrequency", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fccFrequency::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fccFrequency(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fccFrequency * SOAP_FMAC4 soap_get_ns1__fccFrequency(struct soap *soap, ns1__fccFrequency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccFrequency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__fccCallsignDetails::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__fccCallsignDetails::licensee);
	soap_default_std__string(soap, &this->ns1__fccCallsignDetails::callsign);
	soap_default_std__string(soap, &this->ns1__fccCallsignDetails::status);
	soap_default_std__string(soap, &this->ns1__fccCallsignDetails::grantDate);
	soap_default_std__string(soap, &this->ns1__fccCallsignDetails::radioService);
	soap_default_std__string(soap, &this->ns1__fccCallsignDetails::notes);
	this->ns1__fccCallsignDetails::locations = NULL;
	this->ns1__fccCallsignDetails::frequencies = NULL;
}

void ns1__fccCallsignDetails::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__fccCallsignDetails::licensee);
	soap_serialize_std__string(soap, &this->ns1__fccCallsignDetails::callsign);
	soap_serialize_std__string(soap, &this->ns1__fccCallsignDetails::status);
	soap_serialize_std__string(soap, &this->ns1__fccCallsignDetails::grantDate);
	soap_serialize_std__string(soap, &this->ns1__fccCallsignDetails::radioService);
	soap_serialize_std__string(soap, &this->ns1__fccCallsignDetails::notes);
	soap_serialize_PointerTofccLocations(soap, &this->ns1__fccCallsignDetails::locations);
	soap_serialize_PointerTofccFrequencies(soap, &this->ns1__fccCallsignDetails::frequencies);
#endif
}

int ns1__fccCallsignDetails::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fccCallsignDetails(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccCallsignDetails(struct soap *soap, const char *tag, int id, const ns1__fccCallsignDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccCallsignDetails), type))
		return soap->error;
	if (soap_out_std__string(soap, "licensee", -1, &a->ns1__fccCallsignDetails::licensee, ""))
		return soap->error;
	if (soap_out_std__string(soap, "callsign", -1, &a->ns1__fccCallsignDetails::callsign, ""))
		return soap->error;
	if (soap_out_std__string(soap, "status", -1, &a->ns1__fccCallsignDetails::status, ""))
		return soap->error;
	if (soap_out_std__string(soap, "grantDate", -1, &a->ns1__fccCallsignDetails::grantDate, ""))
		return soap->error;
	if (soap_out_std__string(soap, "radioService", -1, &a->ns1__fccCallsignDetails::radioService, ""))
		return soap->error;
	if (soap_out_std__string(soap, "notes", -1, &a->ns1__fccCallsignDetails::notes, ""))
		return soap->error;
	if (!a->ns1__fccCallsignDetails::locations)
	{	if (soap_element_empty(soap, "locations", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTofccLocations(soap, "locations", -1, &a->ns1__fccCallsignDetails::locations, ""))
		return soap->error;
	if (!a->ns1__fccCallsignDetails::frequencies)
	{	if (soap_element_empty(soap, "frequencies", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTofccFrequencies(soap, "frequencies", -1, &a->ns1__fccCallsignDetails::frequencies, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__fccCallsignDetails::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__fccCallsignDetails(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fccCallsignDetails * SOAP_FMAC4 soap_in_ns1__fccCallsignDetails(struct soap *soap, const char *tag, ns1__fccCallsignDetails *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fccCallsignDetails*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccCallsignDetails, sizeof(ns1__fccCallsignDetails), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__fccCallsignDetails)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__fccCallsignDetails *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_licensee1 = 1;
	size_t soap_flag_callsign1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_grantDate1 = 1;
	size_t soap_flag_radioService1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_locations1 = 1;
	size_t soap_flag_frequencies1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_licensee1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "licensee", &a->ns1__fccCallsignDetails::licensee, "xsd:string"))
				{	soap_flag_licensee1--;
					continue;
				}
			}
			if (soap_flag_callsign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "callsign", &a->ns1__fccCallsignDetails::callsign, "xsd:string"))
				{	soap_flag_callsign1--;
					continue;
				}
			}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "status", &a->ns1__fccCallsignDetails::status, "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			}
			if (soap_flag_grantDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "grantDate", &a->ns1__fccCallsignDetails::grantDate, "xsd:string"))
				{	soap_flag_grantDate1--;
					continue;
				}
			}
			if (soap_flag_radioService1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "radioService", &a->ns1__fccCallsignDetails::radioService, "xsd:string"))
				{	soap_flag_radioService1--;
					continue;
				}
			}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "notes", &a->ns1__fccCallsignDetails::notes, "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			}
			if (soap_flag_locations1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofccLocations(soap, "locations", &a->ns1__fccCallsignDetails::locations, "ns1:fccLocation"))
				{	soap_flag_locations1--;
					continue;
				}
			}
			if (soap_flag_frequencies1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofccFrequencies(soap, "frequencies", &a->ns1__fccCallsignDetails::frequencies, "ns1:fccFrequency"))
				{	soap_flag_frequencies1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_licensee1 > 0 || soap_flag_callsign1 > 0 || soap_flag_status1 > 0 || soap_flag_grantDate1 > 0 || soap_flag_radioService1 > 0 || soap_flag_notes1 > 0 || !a->ns1__fccCallsignDetails::locations || !a->ns1__fccCallsignDetails::frequencies))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__fccCallsignDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccCallsignDetails, SOAP_TYPE_ns1__fccCallsignDetails, sizeof(ns1__fccCallsignDetails), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__fccCallsignDetails * SOAP_FMAC2 rrapi__instantiate_ns1__fccCallsignDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccCallsignDetails(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__fccCallsignDetails *p;
	size_t k = sizeof(ns1__fccCallsignDetails);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccCallsignDetails, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__fccCallsignDetails);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__fccCallsignDetails, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__fccCallsignDetails location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__fccCallsignDetails::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__fccCallsignDetails(soap, tag ? tag : "ns1:fccCallsignDetails", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fccCallsignDetails::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fccCallsignDetails(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fccCallsignDetails * SOAP_FMAC4 soap_get_ns1__fccCallsignDetails(struct soap *soap, ns1__fccCallsignDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccCallsignDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__UserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__UserInfo::username);
	soap_default_std__string(soap, &this->ns1__UserInfo::subExpireDate);
}

void ns1__UserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__UserInfo::username);
	soap_serialize_std__string(soap, &this->ns1__UserInfo::subExpireDate);
#endif
}

int ns1__UserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserInfo(struct soap *soap, const char *tag, int id, const ns1__UserInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &a->ns1__UserInfo::username, ""))
		return soap->error;
	if (soap_out_std__string(soap, "subExpireDate", -1, &a->ns1__UserInfo::subExpireDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__UserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__UserInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserInfo * SOAP_FMAC4 soap_in_ns1__UserInfo(struct soap *soap, const char *tag, ns1__UserInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__UserInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__UserInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_username1 = 1;
	size_t soap_flag_subExpireDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "username", &a->ns1__UserInfo::username, "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			}
			if (soap_flag_subExpireDate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "subExpireDate", &a->ns1__UserInfo::subExpireDate, "xsd:string"))
				{	soap_flag_subExpireDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1 > 0 || soap_flag_subExpireDate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__UserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserInfo, SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__UserInfo * SOAP_FMAC2 rrapi__instantiate_ns1__UserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__UserInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__UserInfo *p;
	size_t k = sizeof(ns1__UserInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__UserInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__UserInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__UserInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__UserInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__UserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__UserInfo(soap, tag ? tag : "ns1:UserInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__UserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserInfo * SOAP_FMAC4 soap_get_ns1__UserInfo(struct soap *soap, ns1__UserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ZipInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ZipInfo::zipCode);
	soap_default_std__string(soap, &this->ns1__ZipInfo::lat);
	soap_default_std__string(soap, &this->ns1__ZipInfo::lon);
	soap_default_std__string(soap, &this->ns1__ZipInfo::city);
	soap_default_int(soap, &this->ns1__ZipInfo::stid);
	soap_default_int(soap, &this->ns1__ZipInfo::ctid);
}

void ns1__ZipInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__ZipInfo::lat);
	soap_serialize_std__string(soap, &this->ns1__ZipInfo::lon);
	soap_serialize_std__string(soap, &this->ns1__ZipInfo::city);
#endif
}

int ns1__ZipInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ZipInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ZipInfo(struct soap *soap, const char *tag, int id, const ns1__ZipInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ZipInfo), type))
		return soap->error;
	if (soap_out_int(soap, "zipCode", -1, &a->ns1__ZipInfo::zipCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lat", -1, &a->ns1__ZipInfo::lat, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lon", -1, &a->ns1__ZipInfo::lon, ""))
		return soap->error;
	if (soap_out_std__string(soap, "city", -1, &a->ns1__ZipInfo::city, ""))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->ns1__ZipInfo::stid, ""))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ns1__ZipInfo::ctid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ZipInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ZipInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ZipInfo * SOAP_FMAC4 soap_in_ns1__ZipInfo(struct soap *soap, const char *tag, ns1__ZipInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ZipInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ZipInfo, sizeof(ns1__ZipInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ZipInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ZipInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_zipCode1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_stid1 = 1;
	size_t soap_flag_ctid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zipCode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "zipCode", &a->ns1__ZipInfo::zipCode, "xsd:int"))
				{	soap_flag_zipCode1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lat", &a->ns1__ZipInfo::lat, "xsd:string"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "lon", &a->ns1__ZipInfo::lon, "xsd:string"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "city", &a->ns1__ZipInfo::city, "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			}
			if (soap_flag_stid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->ns1__ZipInfo::stid, "xsd:int"))
				{	soap_flag_stid1--;
					continue;
				}
			}
			if (soap_flag_ctid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ns1__ZipInfo::ctid, "xsd:int"))
				{	soap_flag_ctid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zipCode1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_city1 > 0 || soap_flag_stid1 > 0 || soap_flag_ctid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ZipInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ZipInfo, SOAP_TYPE_ns1__ZipInfo, sizeof(ns1__ZipInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ZipInfo * SOAP_FMAC2 rrapi__instantiate_ns1__ZipInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__ZipInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ZipInfo *p;
	size_t k = sizeof(ns1__ZipInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ZipInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ZipInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ZipInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ZipInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ZipInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ZipInfo(soap, tag ? tag : "ns1:ZipInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ZipInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ZipInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ZipInfo * SOAP_FMAC4 soap_get_ns1__ZipInfo(struct soap *soap, ns1__ZipInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ZipInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__mode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__mode::mode);
	soap_default_std__string(soap, &this->ns1__mode::modeName);
}

void ns1__mode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__mode::modeName);
#endif
}

int ns1__mode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__mode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__mode(struct soap *soap, const char *tag, int id, const ns1__mode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__mode), type))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->ns1__mode::mode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "modeName", -1, &a->ns1__mode::modeName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__mode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__mode(soap, tag, this, type);
}

SOAP_FMAC3 ns1__mode * SOAP_FMAC4 soap_in_ns1__mode(struct soap *soap, const char *tag, ns1__mode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__mode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__mode, sizeof(ns1__mode), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__mode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__mode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_modeName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mode", &a->ns1__mode::mode, "xsd:int"))
				{	soap_flag_mode1--;
					continue;
				}
			}
			if (soap_flag_modeName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "modeName", &a->ns1__mode::modeName, "xsd:string"))
				{	soap_flag_modeName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mode1 > 0 || soap_flag_modeName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__mode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__mode, SOAP_TYPE_ns1__mode, sizeof(ns1__mode), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__mode * SOAP_FMAC2 rrapi__instantiate_ns1__mode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__mode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__mode *p;
	size_t k = sizeof(ns1__mode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__mode, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__mode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__mode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__mode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__mode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__mode(soap, tag ? tag : "ns1:mode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__mode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__mode(soap, this, tag, type);
}

SOAP_FMAC3 ns1__mode * SOAP_FMAC4 soap_get_ns1__mode(struct soap *soap, ns1__mode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__mode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void modes::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void modes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_modes))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__mode(soap, this->__ptr + i);
		}
	}
#endif
}

int modes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_modes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_modes(struct soap *soap, const char *tag, int id, const modes *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:mode", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_modes, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__mode(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *modes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_modes(soap, tag, this, type);
}

SOAP_FMAC3 modes * SOAP_FMAC4 soap_in_modes(struct soap *soap, const char *tag, modes *a, const char *type)
{
	int i, j;
	ns1__mode **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (modes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_modes, sizeof(modes), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__mode **)soap_malloc(soap, sizeof(ns1__mode *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__mode(soap, NULL, a->__ptr + i, "ns1:mode"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__mode **)soap_push_block(soap, NULL, sizeof(ns1__mode *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__mode(soap, NULL, p, "ns1:mode"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__mode **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (modes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_modes, SOAP_TYPE_modes, sizeof(modes), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 modes * SOAP_FMAC2 rrapi__instantiate_modes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_modes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	modes *p;
	size_t k = sizeof(modes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_modes, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, modes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, modes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated modes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int modes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_modes(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *modes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_modes(soap, this, tag, type);
}

SOAP_FMAC3 modes * SOAP_FMAC4 soap_get_modes(struct soap *soap, modes *p, const char *tag, const char *type)
{
	if ((p = soap_in_modes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__tag::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__tag::tagId);
	soap_default_std__string(soap, &this->ns1__tag::tagDescr);
}

void ns1__tag::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__tag::tagDescr);
#endif
}

int ns1__tag::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__tag(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__tag(struct soap *soap, const char *tag, int id, const ns1__tag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__tag), type))
		return soap->error;
	if (soap_out_int(soap, "tagId", -1, &a->ns1__tag::tagId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tagDescr", -1, &a->ns1__tag::tagDescr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__tag::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__tag(soap, tag, this, type);
}

SOAP_FMAC3 ns1__tag * SOAP_FMAC4 soap_in_ns1__tag(struct soap *soap, const char *tag, ns1__tag *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__tag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__tag, sizeof(ns1__tag), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__tag)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__tag *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tagId1 = 1;
	size_t soap_flag_tagDescr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tagId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tagId", &a->ns1__tag::tagId, "xsd:int"))
				{	soap_flag_tagId1--;
					continue;
				}
			}
			if (soap_flag_tagDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tagDescr", &a->ns1__tag::tagDescr, "xsd:string"))
				{	soap_flag_tagDescr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tagId1 > 0 || soap_flag_tagDescr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__tag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__tag, SOAP_TYPE_ns1__tag, sizeof(ns1__tag), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__tag * SOAP_FMAC2 rrapi__instantiate_ns1__tag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__tag(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__tag *p;
	size_t k = sizeof(ns1__tag);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__tag, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__tag);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__tag, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__tag location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__tag::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__tag(soap, tag ? tag : "ns1:tag", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__tag::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__tag(soap, this, tag, type);
}

SOAP_FMAC3 ns1__tag * SOAP_FMAC4 soap_get_ns1__tag(struct soap *soap, ns1__tag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__tag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tags::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void tags::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_tags))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__tag(soap, this->__ptr + i);
		}
	}
#endif
}

int tags::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tags(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tags(struct soap *soap, const char *tag, int id, const tags *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:tag", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tags, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__tag(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *tags::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tags(soap, tag, this, type);
}

SOAP_FMAC3 tags * SOAP_FMAC4 soap_in_tags(struct soap *soap, const char *tag, tags *a, const char *type)
{
	int i, j;
	ns1__tag **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (tags*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tags, sizeof(tags), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__tag **)soap_malloc(soap, sizeof(ns1__tag *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__tag(soap, NULL, a->__ptr + i, "ns1:tag"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__tag **)soap_push_block(soap, NULL, sizeof(ns1__tag *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__tag(soap, NULL, p, "ns1:tag"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__tag **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tags *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tags, SOAP_TYPE_tags, sizeof(tags), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tags * SOAP_FMAC2 rrapi__instantiate_tags(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_tags(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tags *p;
	size_t k = sizeof(tags);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tags, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tags);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tags, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tags location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tags::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tags(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tags::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tags(soap, this, tag, type);
}

SOAP_FMAC3 tags * SOAP_FMAC4 soap_get_tags(struct soap *soap, tags *p, const char *tag, const char *type)
{
	if ((p = soap_in_tags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__sid::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__sid::sid);
}

void ns1__sid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__sid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sid(struct soap *soap, const char *tag, int id, const ns1__sid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sid), type))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->ns1__sid::sid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__sid::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__sid(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sid * SOAP_FMAC4 soap_in_ns1__sid(struct soap *soap, const char *tag, ns1__sid *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sid*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sid, sizeof(ns1__sid), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__sid)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__sid *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->ns1__sid::sid, "xsd:int"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__sid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sid, SOAP_TYPE_ns1__sid, sizeof(ns1__sid), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__sid * SOAP_FMAC2 rrapi__instantiate_ns1__sid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__sid(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__sid *p;
	size_t k = sizeof(ns1__sid);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__sid, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__sid);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__sid, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__sid location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__sid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__sid(soap, tag ? tag : "ns1:sid", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sid(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sid * SOAP_FMAC4 soap_get_ns1__sid(struct soap *soap, ns1__sid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void sids::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void sids::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_sids))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__sid(soap, this->__ptr + i);
		}
	}
#endif
}

int sids::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_sids(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_sids(struct soap *soap, const char *tag, int id, const sids *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:sid", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_sids, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__sid(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *sids::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_sids(soap, tag, this, type);
}

SOAP_FMAC3 sids * SOAP_FMAC4 soap_in_sids(struct soap *soap, const char *tag, sids *a, const char *type)
{
	int i, j;
	ns1__sid **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (sids*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_sids, sizeof(sids), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__sid **)soap_malloc(soap, sizeof(ns1__sid *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__sid(soap, NULL, a->__ptr + i, "ns1:sid"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__sid **)soap_push_block(soap, NULL, sizeof(ns1__sid *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__sid(soap, NULL, p, "ns1:sid"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__sid **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (sids *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_sids, SOAP_TYPE_sids, sizeof(sids), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 sids * SOAP_FMAC2 rrapi__instantiate_sids(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_sids(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	sids *p;
	size_t k = sizeof(sids);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_sids, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, sids);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, sids, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated sids location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int sids::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_sids(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *sids::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_sids(soap, this, tag, type);
}

SOAP_FMAC3 sids * SOAP_FMAC4 soap_get_sids(struct soap *soap, sids *p, const char *tag, const char *type)
{
	if ((p = soap_in_sids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__stid::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__stid::stid);
}

void ns1__stid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__stid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__stid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__stid(struct soap *soap, const char *tag, int id, const ns1__stid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__stid), type))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->ns1__stid::stid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__stid::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__stid(soap, tag, this, type);
}

SOAP_FMAC3 ns1__stid * SOAP_FMAC4 soap_in_ns1__stid(struct soap *soap, const char *tag, ns1__stid *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__stid*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__stid, sizeof(ns1__stid), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__stid)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__stid *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_stid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->ns1__stid::stid, "xsd:int"))
				{	soap_flag_stid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__stid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__stid, SOAP_TYPE_ns1__stid, sizeof(ns1__stid), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__stid * SOAP_FMAC2 rrapi__instantiate_ns1__stid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__stid(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__stid *p;
	size_t k = sizeof(ns1__stid);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__stid, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__stid);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__stid, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__stid location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__stid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__stid(soap, tag ? tag : "ns1:stid", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__stid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__stid(soap, this, tag, type);
}

SOAP_FMAC3 ns1__stid * SOAP_FMAC4 soap_get_ns1__stid(struct soap *soap, ns1__stid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__stid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void stids::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void stids::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_stids))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__stid(soap, this->__ptr + i);
		}
	}
#endif
}

int stids::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_stids(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_stids(struct soap *soap, const char *tag, int id, const stids *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:stid", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_stids, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__stid(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *stids::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_stids(soap, tag, this, type);
}

SOAP_FMAC3 stids * SOAP_FMAC4 soap_in_stids(struct soap *soap, const char *tag, stids *a, const char *type)
{
	int i, j;
	ns1__stid **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (stids*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_stids, sizeof(stids), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__stid **)soap_malloc(soap, sizeof(ns1__stid *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__stid(soap, NULL, a->__ptr + i, "ns1:stid"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__stid **)soap_push_block(soap, NULL, sizeof(ns1__stid *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__stid(soap, NULL, p, "ns1:stid"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__stid **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (stids *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_stids, SOAP_TYPE_stids, sizeof(stids), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 stids * SOAP_FMAC2 rrapi__instantiate_stids(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_stids(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	stids *p;
	size_t k = sizeof(stids);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_stids, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, stids);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, stids, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated stids location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int stids::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_stids(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *stids::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_stids(soap, this, tag, type);
}

SOAP_FMAC3 stids * SOAP_FMAC4 soap_get_stids(struct soap *soap, stids *p, const char *tag, const char *type)
{
	if ((p = soap_in_stids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Agency::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Agency::aid);
	soap_default_std__string(soap, &this->ns1__Agency::aName);
	soap_default_int(soap, &this->ns1__Agency::aType);
}

void ns1__Agency::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__Agency::aName);
#endif
}

int ns1__Agency::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Agency(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Agency(struct soap *soap, const char *tag, int id, const ns1__Agency *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Agency), type))
		return soap->error;
	if (soap_out_int(soap, "aid", -1, &a->ns1__Agency::aid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "aName", -1, &a->ns1__Agency::aName, ""))
		return soap->error;
	if (soap_out_int(soap, "aType", -1, &a->ns1__Agency::aType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Agency::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Agency(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Agency * SOAP_FMAC4 soap_in_ns1__Agency(struct soap *soap, const char *tag, ns1__Agency *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Agency*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Agency, sizeof(ns1__Agency), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Agency)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Agency *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_aid1 = 1;
	size_t soap_flag_aName1 = 1;
	size_t soap_flag_aType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_aid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "aid", &a->ns1__Agency::aid, "xsd:int"))
				{	soap_flag_aid1--;
					continue;
				}
			}
			if (soap_flag_aName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "aName", &a->ns1__Agency::aName, "xsd:string"))
				{	soap_flag_aName1--;
					continue;
				}
			}
			if (soap_flag_aType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "aType", &a->ns1__Agency::aType, "xsd:int"))
				{	soap_flag_aType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_aid1 > 0 || soap_flag_aName1 > 0 || soap_flag_aType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Agency *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Agency, SOAP_TYPE_ns1__Agency, sizeof(ns1__Agency), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Agency * SOAP_FMAC2 rrapi__instantiate_ns1__Agency(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__Agency(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Agency *p;
	size_t k = sizeof(ns1__Agency);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Agency, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Agency);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Agency, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Agency location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Agency::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Agency(soap, tag ? tag : "ns1:Agency", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Agency::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Agency(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Agency * SOAP_FMAC4 soap_get_ns1__Agency(struct soap *soap, ns1__Agency *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Agency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Agencies::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Agencies::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Agencies))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__Agency(soap, this->__ptr + i);
		}
	}
#endif
}

int Agencies::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Agencies(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Agencies(struct soap *soap, const char *tag, int id, const Agencies *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:Agency", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Agencies, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__Agency(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Agencies::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Agencies(soap, tag, this, type);
}

SOAP_FMAC3 Agencies * SOAP_FMAC4 soap_in_Agencies(struct soap *soap, const char *tag, Agencies *a, const char *type)
{
	int i, j;
	ns1__Agency **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Agencies*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Agencies, sizeof(Agencies), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__Agency **)soap_malloc(soap, sizeof(ns1__Agency *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Agency(soap, NULL, a->__ptr + i, "ns1:Agency"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Agency **)soap_push_block(soap, NULL, sizeof(ns1__Agency *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__Agency(soap, NULL, p, "ns1:Agency"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__Agency **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Agencies *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Agencies, SOAP_TYPE_Agencies, sizeof(Agencies), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Agencies * SOAP_FMAC2 rrapi__instantiate_Agencies(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Agencies(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Agencies *p;
	size_t k = sizeof(Agencies);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Agencies, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Agencies);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Agencies, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Agencies location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Agencies::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Agencies(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Agencies::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Agencies(soap, this, tag, type);
}

SOAP_FMAC3 Agencies * SOAP_FMAC4 soap_get_Agencies(struct soap *soap, Agencies *p, const char *tag, const char *type)
{
	if ((p = soap_in_Agencies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Country::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Country::coid);
	soap_default_std__string(soap, &this->ns1__Country::countryName);
	soap_default_std__string(soap, &this->ns1__Country::countryCode);
}

void ns1__Country::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__Country::countryName);
	soap_serialize_std__string(soap, &this->ns1__Country::countryCode);
#endif
}

int ns1__Country::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Country(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Country(struct soap *soap, const char *tag, int id, const ns1__Country *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Country), type))
		return soap->error;
	if (soap_out_int(soap, "coid", -1, &a->ns1__Country::coid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countryName", -1, &a->ns1__Country::countryName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countryCode", -1, &a->ns1__Country::countryCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Country::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Country(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Country * SOAP_FMAC4 soap_in_ns1__Country(struct soap *soap, const char *tag, ns1__Country *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Country*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Country, sizeof(ns1__Country), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Country)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Country *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_coid1 = 1;
	size_t soap_flag_countryName1 = 1;
	size_t soap_flag_countryCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_coid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "coid", &a->ns1__Country::coid, "xsd:int"))
				{	soap_flag_coid1--;
					continue;
				}
			}
			if (soap_flag_countryName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countryName", &a->ns1__Country::countryName, "xsd:string"))
				{	soap_flag_countryName1--;
					continue;
				}
			}
			if (soap_flag_countryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countryCode", &a->ns1__Country::countryCode, "xsd:string"))
				{	soap_flag_countryCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coid1 > 0 || soap_flag_countryName1 > 0 || soap_flag_countryCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Country *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Country, SOAP_TYPE_ns1__Country, sizeof(ns1__Country), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Country * SOAP_FMAC2 rrapi__instantiate_ns1__Country(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__Country(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Country *p;
	size_t k = sizeof(ns1__Country);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Country, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Country);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Country, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Country location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Country::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Country(soap, tag ? tag : "ns1:Country", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Country::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Country(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Country * SOAP_FMAC4 soap_get_ns1__Country(struct soap *soap, ns1__Country *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Countries::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Countries::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Countries))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__Country(soap, this->__ptr + i);
		}
	}
#endif
}

int Countries::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Countries(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Countries(struct soap *soap, const char *tag, int id, const Countries *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:Country", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Countries, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__Country(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Countries::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Countries(soap, tag, this, type);
}

SOAP_FMAC3 Countries * SOAP_FMAC4 soap_in_Countries(struct soap *soap, const char *tag, Countries *a, const char *type)
{
	int i, j;
	ns1__Country **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Countries*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Countries, sizeof(Countries), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__Country **)soap_malloc(soap, sizeof(ns1__Country *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Country(soap, NULL, a->__ptr + i, "ns1:Country"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Country **)soap_push_block(soap, NULL, sizeof(ns1__Country *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__Country(soap, NULL, p, "ns1:Country"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__Country **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Countries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Countries, SOAP_TYPE_Countries, sizeof(Countries), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Countries * SOAP_FMAC2 rrapi__instantiate_Countries(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Countries(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Countries *p;
	size_t k = sizeof(Countries);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Countries, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Countries);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Countries, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Countries location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Countries::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Countries(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Countries::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Countries(soap, this, tag, type);
}

SOAP_FMAC3 Countries * SOAP_FMAC4 soap_get_Countries(struct soap *soap, Countries *p, const char *tag, const char *type)
{
	if ((p = soap_in_Countries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Metro::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Metro::mid);
	soap_default_std__string(soap, &this->ns1__Metro::metroName);
}

void ns1__Metro::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__Metro::metroName);
#endif
}

int ns1__Metro::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Metro(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Metro(struct soap *soap, const char *tag, int id, const ns1__Metro *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Metro), type))
		return soap->error;
	if (soap_out_int(soap, "mid", -1, &a->ns1__Metro::mid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "metroName", -1, &a->ns1__Metro::metroName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Metro::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Metro(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Metro * SOAP_FMAC4 soap_in_ns1__Metro(struct soap *soap, const char *tag, ns1__Metro *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Metro*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Metro, sizeof(ns1__Metro), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Metro)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Metro *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_mid1 = 1;
	size_t soap_flag_metroName1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mid", &a->ns1__Metro::mid, "xsd:int"))
				{	soap_flag_mid1--;
					continue;
				}
			}
			if (soap_flag_metroName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "metroName", &a->ns1__Metro::metroName, "xsd:string"))
				{	soap_flag_metroName1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mid1 > 0 || soap_flag_metroName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Metro *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Metro, SOAP_TYPE_ns1__Metro, sizeof(ns1__Metro), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Metro * SOAP_FMAC2 rrapi__instantiate_ns1__Metro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__Metro(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Metro *p;
	size_t k = sizeof(ns1__Metro);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Metro, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Metro);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Metro, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Metro location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Metro::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Metro(soap, tag ? tag : "ns1:Metro", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Metro::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Metro(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Metro * SOAP_FMAC4 soap_get_ns1__Metro(struct soap *soap, ns1__Metro *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Metro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Metros::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Metros::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Metros))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__Metro(soap, this->__ptr + i);
		}
	}
#endif
}

int Metros::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Metros(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Metros(struct soap *soap, const char *tag, int id, const Metros *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:Metro", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Metros, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__Metro(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Metros::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Metros(soap, tag, this, type);
}

SOAP_FMAC3 Metros * SOAP_FMAC4 soap_in_Metros(struct soap *soap, const char *tag, Metros *a, const char *type)
{
	int i, j;
	ns1__Metro **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Metros*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Metros, sizeof(Metros), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__Metro **)soap_malloc(soap, sizeof(ns1__Metro *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Metro(soap, NULL, a->__ptr + i, "ns1:Metro"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Metro **)soap_push_block(soap, NULL, sizeof(ns1__Metro *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__Metro(soap, NULL, p, "ns1:Metro"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__Metro **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Metros *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Metros, SOAP_TYPE_Metros, sizeof(Metros), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Metros * SOAP_FMAC2 rrapi__instantiate_Metros(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Metros(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Metros *p;
	size_t k = sizeof(Metros);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Metros, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Metros);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Metros, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Metros location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Metros::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Metros(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Metros::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Metros(soap, this, tag, type);
}

SOAP_FMAC3 Metros * SOAP_FMAC4 soap_get_Metros(struct soap *soap, Metros *p, const char *tag, const char *type)
{
	if ((p = soap_in_Metros(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__State::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__State::stid);
	soap_default_std__string(soap, &this->ns1__State::stateName);
	soap_default_std__string(soap, &this->ns1__State::stateCode);
}

void ns1__State::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__State::stateName);
	soap_serialize_std__string(soap, &this->ns1__State::stateCode);
#endif
}

int ns1__State::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__State(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__State(struct soap *soap, const char *tag, int id, const ns1__State *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__State), type))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->ns1__State::stid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "stateName", -1, &a->ns1__State::stateName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "stateCode", -1, &a->ns1__State::stateCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__State::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__State(soap, tag, this, type);
}

SOAP_FMAC3 ns1__State * SOAP_FMAC4 soap_in_ns1__State(struct soap *soap, const char *tag, ns1__State *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__State*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__State, sizeof(ns1__State), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__State)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__State *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_stid1 = 1;
	size_t soap_flag_stateName1 = 1;
	size_t soap_flag_stateCode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->ns1__State::stid, "xsd:int"))
				{	soap_flag_stid1--;
					continue;
				}
			}
			if (soap_flag_stateName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "stateName", &a->ns1__State::stateName, "xsd:string"))
				{	soap_flag_stateName1--;
					continue;
				}
			}
			if (soap_flag_stateCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "stateCode", &a->ns1__State::stateCode, "xsd:string"))
				{	soap_flag_stateCode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stid1 > 0 || soap_flag_stateName1 > 0 || soap_flag_stateCode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__State *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__State, SOAP_TYPE_ns1__State, sizeof(ns1__State), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__State * SOAP_FMAC2 rrapi__instantiate_ns1__State(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__State(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__State *p;
	size_t k = sizeof(ns1__State);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__State, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__State);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__State, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__State location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__State::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__State(soap, tag ? tag : "ns1:State", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__State::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__State(soap, this, tag, type);
}

SOAP_FMAC3 ns1__State * SOAP_FMAC4 soap_get_ns1__State(struct soap *soap, ns1__State *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void States::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void States::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_States))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__State(soap, this->__ptr + i);
		}
	}
#endif
}

int States::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_States(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_States(struct soap *soap, const char *tag, int id, const States *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:State", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_States, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__State(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *States::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_States(soap, tag, this, type);
}

SOAP_FMAC3 States * SOAP_FMAC4 soap_in_States(struct soap *soap, const char *tag, States *a, const char *type)
{
	int i, j;
	ns1__State **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (States*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_States, sizeof(States), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__State **)soap_malloc(soap, sizeof(ns1__State *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__State(soap, NULL, a->__ptr + i, "ns1:State"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__State **)soap_push_block(soap, NULL, sizeof(ns1__State *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__State(soap, NULL, p, "ns1:State"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__State **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (States *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_States, SOAP_TYPE_States, sizeof(States), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 States * SOAP_FMAC2 rrapi__instantiate_States(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_States(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	States *p;
	size_t k = sizeof(States);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_States, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, States);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, States, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated States location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int States::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_States(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *States::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_States(soap, this, tag, type);
}

SOAP_FMAC3 States * SOAP_FMAC4 soap_get_States(struct soap *soap, States *p, const char *tag, const char *type)
{
	if ((p = soap_in_States(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ctid::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ctid::ctid);
}

void ns1__ctid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int ns1__ctid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ctid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ctid(struct soap *soap, const char *tag, int id, const ns1__ctid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ctid), type))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ns1__ctid::ctid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ctid::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__ctid(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ctid * SOAP_FMAC4 soap_in_ns1__ctid(struct soap *soap, const char *tag, ns1__ctid *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ctid*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ctid, sizeof(ns1__ctid), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ctid)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ctid *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ctid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ctid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ns1__ctid::ctid, "xsd:int"))
				{	soap_flag_ctid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ctid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__ctid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ctid, SOAP_TYPE_ns1__ctid, sizeof(ns1__ctid), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ctid * SOAP_FMAC2 rrapi__instantiate_ns1__ctid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__ctid(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ctid *p;
	size_t k = sizeof(ns1__ctid);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__ctid, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__ctid);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__ctid, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ctid location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__ctid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ctid(soap, tag ? tag : "ns1:ctid", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ctid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ctid(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ctid * SOAP_FMAC4 soap_get_ns1__ctid(struct soap *soap, ns1__ctid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ctid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ctids::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void ctids::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_ctids))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__ctid(soap, this->__ptr + i);
		}
	}
#endif
}

int ctids::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ctids(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ctids(struct soap *soap, const char *tag, int id, const ctids *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:ctid", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_ctids, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__ctid(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ctids::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ctids(soap, tag, this, type);
}

SOAP_FMAC3 ctids * SOAP_FMAC4 soap_in_ctids(struct soap *soap, const char *tag, ctids *a, const char *type)
{
	int i, j;
	ns1__ctid **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ctids*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ctids, sizeof(ctids), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__ctid **)soap_malloc(soap, sizeof(ns1__ctid *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ctid(soap, NULL, a->__ptr + i, "ns1:ctid"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ctid **)soap_push_block(soap, NULL, sizeof(ns1__ctid *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__ctid(soap, NULL, p, "ns1:ctid"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__ctid **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ctids *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ctids, SOAP_TYPE_ctids, sizeof(ctids), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ctids * SOAP_FMAC2 rrapi__instantiate_ctids(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ctids(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ctids *p;
	size_t k = sizeof(ctids);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ctids, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ctids);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ctids, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ctids location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ctids::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ctids(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ctids::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ctids(soap, this, tag, type);
}

SOAP_FMAC3 ctids * SOAP_FMAC4 soap_get_ctids(struct soap *soap, ctids *p, const char *tag, const char *type)
{
	if ((p = soap_in_ctids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Counties::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Counties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Counties))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__County(soap, this->__ptr + i);
		}
	}
#endif
}

int Counties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Counties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Counties(struct soap *soap, const char *tag, int id, const Counties *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:County", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Counties, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__County(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Counties::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Counties(soap, tag, this, type);
}

SOAP_FMAC3 Counties * SOAP_FMAC4 soap_in_Counties(struct soap *soap, const char *tag, Counties *a, const char *type)
{
	int i, j;
	ns1__County **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Counties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Counties, sizeof(Counties), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__County **)soap_malloc(soap, sizeof(ns1__County *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__County(soap, NULL, a->__ptr + i, "ns1:County"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__County **)soap_push_block(soap, NULL, sizeof(ns1__County *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__County(soap, NULL, p, "ns1:County"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__County **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Counties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Counties, SOAP_TYPE_Counties, sizeof(Counties), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Counties * SOAP_FMAC2 rrapi__instantiate_Counties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Counties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Counties *p;
	size_t k = sizeof(Counties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Counties, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Counties);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Counties, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Counties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Counties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Counties(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Counties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Counties(soap, this, tag, type);
}

SOAP_FMAC3 Counties * SOAP_FMAC4 soap_get_Counties(struct soap *soap, Counties *p, const char *tag, const char *type)
{
	if ((p = soap_in_Counties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__County::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__County::ctid);
	soap_default_std__string(soap, &this->ns1__County::countyName);
	soap_default_std__string(soap, &this->ns1__County::countyHeader);
}

void ns1__County::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__County::countyName);
	soap_serialize_std__string(soap, &this->ns1__County::countyHeader);
#endif
}

int ns1__County::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__County(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__County(struct soap *soap, const char *tag, int id, const ns1__County *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__County), type))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ns1__County::ctid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countyName", -1, &a->ns1__County::countyName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countyHeader", -1, &a->ns1__County::countyHeader, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__County::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__County(soap, tag, this, type);
}

SOAP_FMAC3 ns1__County * SOAP_FMAC4 soap_in_ns1__County(struct soap *soap, const char *tag, ns1__County *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__County*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__County, sizeof(ns1__County), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__County)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__County *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ctid1 = 1;
	size_t soap_flag_countyName1 = 1;
	size_t soap_flag_countyHeader1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ctid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ns1__County::ctid, "xsd:int"))
				{	soap_flag_ctid1--;
					continue;
				}
			}
			if (soap_flag_countyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countyName", &a->ns1__County::countyName, "xsd:string"))
				{	soap_flag_countyName1--;
					continue;
				}
			}
			if (soap_flag_countyHeader1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countyHeader", &a->ns1__County::countyHeader, "xsd:string"))
				{	soap_flag_countyHeader1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ctid1 > 0 || soap_flag_countyName1 > 0 || soap_flag_countyHeader1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__County *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__County, SOAP_TYPE_ns1__County, sizeof(ns1__County), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__County * SOAP_FMAC2 rrapi__instantiate_ns1__County(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__County(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__County *p;
	size_t k = sizeof(ns1__County);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__County, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__County);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__County, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__County location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__County::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__County(soap, tag ? tag : "ns1:County", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__County::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__County(soap, this, tag, type);
}

SOAP_FMAC3 ns1__County * SOAP_FMAC4 soap_get_ns1__County(struct soap *soap, ns1__County *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__County(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__StateInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__StateInfo::stid);
	soap_default_std__string(soap, &this->ns1__StateInfo::stateName);
	soap_default_std__string(soap, &this->ns1__StateInfo::stateEntityType);
	this->ns1__StateInfo::trsList = NULL;
	this->ns1__StateInfo::agencyList = NULL;
	this->ns1__StateInfo::countyList = NULL;
}

void ns1__StateInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__StateInfo::stateName);
	soap_serialize_std__string(soap, &this->ns1__StateInfo::stateEntityType);
	soap_serialize_PointerToTrsList(soap, &this->ns1__StateInfo::trsList);
	soap_serialize_PointerToAgencies(soap, &this->ns1__StateInfo::agencyList);
	soap_serialize_PointerToCounties(soap, &this->ns1__StateInfo::countyList);
#endif
}

int ns1__StateInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StateInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StateInfo(struct soap *soap, const char *tag, int id, const ns1__StateInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StateInfo), type))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->ns1__StateInfo::stid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "stateName", -1, &a->ns1__StateInfo::stateName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "stateEntityType", -1, &a->ns1__StateInfo::stateEntityType, ""))
		return soap->error;
	if (!a->ns1__StateInfo::trsList)
	{	if (soap_element_empty(soap, "trsList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsList(soap, "trsList", -1, &a->ns1__StateInfo::trsList, ""))
		return soap->error;
	if (!a->ns1__StateInfo::agencyList)
	{	if (soap_element_empty(soap, "agencyList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToAgencies(soap, "agencyList", -1, &a->ns1__StateInfo::agencyList, ""))
		return soap->error;
	if (!a->ns1__StateInfo::countyList)
	{	if (soap_element_empty(soap, "countyList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToCounties(soap, "countyList", -1, &a->ns1__StateInfo::countyList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__StateInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__StateInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StateInfo * SOAP_FMAC4 soap_in_ns1__StateInfo(struct soap *soap, const char *tag, ns1__StateInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StateInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StateInfo, sizeof(ns1__StateInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__StateInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__StateInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_stid1 = 1;
	size_t soap_flag_stateName1 = 1;
	size_t soap_flag_stateEntityType1 = 1;
	size_t soap_flag_trsList1 = 1;
	size_t soap_flag_agencyList1 = 1;
	size_t soap_flag_countyList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->ns1__StateInfo::stid, "xsd:int"))
				{	soap_flag_stid1--;
					continue;
				}
			}
			if (soap_flag_stateName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "stateName", &a->ns1__StateInfo::stateName, "xsd:string"))
				{	soap_flag_stateName1--;
					continue;
				}
			}
			if (soap_flag_stateEntityType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "stateEntityType", &a->ns1__StateInfo::stateEntityType, "xsd:string"))
				{	soap_flag_stateEntityType1--;
					continue;
				}
			}
			if (soap_flag_trsList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsList(soap, "trsList", &a->ns1__StateInfo::trsList, "ns1:TrsListDef"))
				{	soap_flag_trsList1--;
					continue;
				}
			}
			if (soap_flag_agencyList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToAgencies(soap, "agencyList", &a->ns1__StateInfo::agencyList, "ns1:Agency"))
				{	soap_flag_agencyList1--;
					continue;
				}
			}
			if (soap_flag_countyList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToCounties(soap, "countyList", &a->ns1__StateInfo::countyList, "ns1:County"))
				{	soap_flag_countyList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stid1 > 0 || soap_flag_stateName1 > 0 || soap_flag_stateEntityType1 > 0 || !a->ns1__StateInfo::trsList || !a->ns1__StateInfo::agencyList || !a->ns1__StateInfo::countyList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__StateInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StateInfo, SOAP_TYPE_ns1__StateInfo, sizeof(ns1__StateInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__StateInfo * SOAP_FMAC2 rrapi__instantiate_ns1__StateInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__StateInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__StateInfo *p;
	size_t k = sizeof(ns1__StateInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__StateInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__StateInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__StateInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__StateInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__StateInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__StateInfo(soap, tag ? tag : "ns1:StateInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__StateInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StateInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StateInfo * SOAP_FMAC4 soap_get_ns1__StateInfo(struct soap *soap, ns1__StateInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CountyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__CountyInfo::ctid);
	soap_default_std__string(soap, &this->ns1__CountyInfo::countyName);
	soap_default_std__string(soap, &this->ns1__CountyInfo::countyHeader);
	soap_default_int(soap, &this->ns1__CountyInfo::stid);
	soap_default_xsd__decimal(soap, &this->ns1__CountyInfo::lat);
	soap_default_xsd__decimal(soap, &this->ns1__CountyInfo::lon);
	soap_default_xsd__decimal(soap, &this->ns1__CountyInfo::range);
	soap_default_std__string(soap, &this->ns1__CountyInfo::fips);
	soap_default_dateTime(soap, &this->ns1__CountyInfo::lastUpdated);
	this->ns1__CountyInfo::cats = NULL;
	this->ns1__CountyInfo::trsList = NULL;
	this->ns1__CountyInfo::agencyList = NULL;
}

void ns1__CountyInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__CountyInfo::countyName);
	soap_serialize_std__string(soap, &this->ns1__CountyInfo::countyHeader);
	soap_serialize_xsd__decimal(soap, &this->ns1__CountyInfo::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__CountyInfo::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__CountyInfo::range);
	soap_serialize_std__string(soap, &this->ns1__CountyInfo::fips);
	soap_serialize_PointerToCats(soap, &this->ns1__CountyInfo::cats);
	soap_serialize_PointerToTrsList(soap, &this->ns1__CountyInfo::trsList);
	soap_serialize_PointerToAgencies(soap, &this->ns1__CountyInfo::agencyList);
#endif
}

int ns1__CountyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CountyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountyInfo(struct soap *soap, const char *tag, int id, const ns1__CountyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CountyInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ns1__CountyInfo::ctid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countyName", -1, &a->ns1__CountyInfo::countyName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countyHeader", -1, &a->ns1__CountyInfo::countyHeader, ""))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->ns1__CountyInfo::stid, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__CountyInfo::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__CountyInfo::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->ns1__CountyInfo::range, ""))
		return soap->error;
	if (soap_out_std__string(soap, "fips", -1, &a->ns1__CountyInfo::fips, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "lastUpdated", -1, &a->ns1__CountyInfo::lastUpdated, ""))
		return soap->error;
	if (!a->ns1__CountyInfo::cats)
	{	if (soap_element_empty(soap, "cats", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToCats(soap, "cats", -1, &a->ns1__CountyInfo::cats, ""))
		return soap->error;
	if (!a->ns1__CountyInfo::trsList)
	{	if (soap_element_empty(soap, "trsList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsList(soap, "trsList", -1, &a->ns1__CountyInfo::trsList, ""))
		return soap->error;
	if (!a->ns1__CountyInfo::agencyList)
	{	if (soap_element_empty(soap, "agencyList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToAgencies(soap, "agencyList", -1, &a->ns1__CountyInfo::agencyList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CountyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CountyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CountyInfo * SOAP_FMAC4 soap_in_ns1__CountyInfo(struct soap *soap, const char *tag, ns1__CountyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CountyInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CountyInfo, sizeof(ns1__CountyInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CountyInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CountyInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ctid1 = 1;
	size_t soap_flag_countyName1 = 1;
	size_t soap_flag_countyHeader1 = 1;
	size_t soap_flag_stid1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_range1 = 1;
	size_t soap_flag_fips1 = 1;
	size_t soap_flag_lastUpdated1 = 1;
	size_t soap_flag_cats1 = 1;
	size_t soap_flag_trsList1 = 1;
	size_t soap_flag_agencyList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ctid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ns1__CountyInfo::ctid, "xsd:int"))
				{	soap_flag_ctid1--;
					continue;
				}
			}
			if (soap_flag_countyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countyName", &a->ns1__CountyInfo::countyName, "xsd:string"))
				{	soap_flag_countyName1--;
					continue;
				}
			}
			if (soap_flag_countyHeader1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countyHeader", &a->ns1__CountyInfo::countyHeader, "xsd:string"))
				{	soap_flag_countyHeader1--;
					continue;
				}
			}
			if (soap_flag_stid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->ns1__CountyInfo::stid, "xsd:int"))
				{	soap_flag_stid1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__CountyInfo::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__CountyInfo::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_range1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->ns1__CountyInfo::range, "xsd:decimal"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap_flag_fips1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "fips", &a->ns1__CountyInfo::fips, "xsd:string"))
				{	soap_flag_fips1--;
					continue;
				}
			}
			if (soap_flag_lastUpdated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "lastUpdated", &a->ns1__CountyInfo::lastUpdated, "xsd:dateTime"))
				{	soap_flag_lastUpdated1--;
					continue;
				}
			}
			if (soap_flag_cats1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToCats(soap, "cats", &a->ns1__CountyInfo::cats, "ns1:cat"))
				{	soap_flag_cats1--;
					continue;
				}
			}
			if (soap_flag_trsList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsList(soap, "trsList", &a->ns1__CountyInfo::trsList, "ns1:TrsListDef"))
				{	soap_flag_trsList1--;
					continue;
				}
			}
			if (soap_flag_agencyList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToAgencies(soap, "agencyList", &a->ns1__CountyInfo::agencyList, "ns1:Agency"))
				{	soap_flag_agencyList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ctid1 > 0 || soap_flag_countyName1 > 0 || soap_flag_countyHeader1 > 0 || soap_flag_stid1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_range1 > 0 || soap_flag_fips1 > 0 || soap_flag_lastUpdated1 > 0 || !a->ns1__CountyInfo::cats || !a->ns1__CountyInfo::trsList || !a->ns1__CountyInfo::agencyList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CountyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CountyInfo, SOAP_TYPE_ns1__CountyInfo, sizeof(ns1__CountyInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CountyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__CountyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__CountyInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CountyInfo *p;
	size_t k = sizeof(ns1__CountyInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CountyInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CountyInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CountyInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CountyInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CountyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CountyInfo(soap, tag ? tag : "ns1:CountyInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CountyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CountyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CountyInfo * SOAP_FMAC4 soap_get_ns1__CountyInfo(struct soap *soap, ns1__CountyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CountryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__CountryInfo::coid);
	soap_default_std__string(soap, &this->ns1__CountryInfo::countryName);
	soap_default_std__string(soap, &this->ns1__CountryInfo::countryCode);
	this->ns1__CountryInfo::agencyList = NULL;
	this->ns1__CountryInfo::stateList = NULL;
}

void ns1__CountryInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__CountryInfo::countryName);
	soap_serialize_std__string(soap, &this->ns1__CountryInfo::countryCode);
	soap_serialize_PointerToAgencies(soap, &this->ns1__CountryInfo::agencyList);
	soap_serialize_PointerToStates(soap, &this->ns1__CountryInfo::stateList);
#endif
}

int ns1__CountryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CountryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CountryInfo(struct soap *soap, const char *tag, int id, const ns1__CountryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CountryInfo), type))
		return soap->error;
	if (soap_out_int(soap, "coid", -1, &a->ns1__CountryInfo::coid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countryName", -1, &a->ns1__CountryInfo::countryName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "countryCode", -1, &a->ns1__CountryInfo::countryCode, ""))
		return soap->error;
	if (!a->ns1__CountryInfo::agencyList)
	{	if (soap_element_empty(soap, "agencyList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToAgencies(soap, "agencyList", -1, &a->ns1__CountryInfo::agencyList, ""))
		return soap->error;
	if (!a->ns1__CountryInfo::stateList)
	{	if (soap_element_empty(soap, "stateList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToStates(soap, "stateList", -1, &a->ns1__CountryInfo::stateList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CountryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__CountryInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CountryInfo * SOAP_FMAC4 soap_in_ns1__CountryInfo(struct soap *soap, const char *tag, ns1__CountryInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CountryInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CountryInfo, sizeof(ns1__CountryInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__CountryInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__CountryInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_coid1 = 1;
	size_t soap_flag_countryName1 = 1;
	size_t soap_flag_countryCode1 = 1;
	size_t soap_flag_agencyList1 = 1;
	size_t soap_flag_stateList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_coid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "coid", &a->ns1__CountryInfo::coid, "xsd:int"))
				{	soap_flag_coid1--;
					continue;
				}
			}
			if (soap_flag_countryName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countryName", &a->ns1__CountryInfo::countryName, "xsd:string"))
				{	soap_flag_countryName1--;
					continue;
				}
			}
			if (soap_flag_countryCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "countryCode", &a->ns1__CountryInfo::countryCode, "xsd:string"))
				{	soap_flag_countryCode1--;
					continue;
				}
			}
			if (soap_flag_agencyList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToAgencies(soap, "agencyList", &a->ns1__CountryInfo::agencyList, "ns1:Agency"))
				{	soap_flag_agencyList1--;
					continue;
				}
			}
			if (soap_flag_stateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToStates(soap, "stateList", &a->ns1__CountryInfo::stateList, "ns1:State"))
				{	soap_flag_stateList1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coid1 > 0 || soap_flag_countryName1 > 0 || soap_flag_countryCode1 > 0 || !a->ns1__CountryInfo::agencyList || !a->ns1__CountryInfo::stateList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__CountryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CountryInfo, SOAP_TYPE_ns1__CountryInfo, sizeof(ns1__CountryInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__CountryInfo * SOAP_FMAC2 rrapi__instantiate_ns1__CountryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__CountryInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__CountryInfo *p;
	size_t k = sizeof(ns1__CountryInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__CountryInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__CountryInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__CountryInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__CountryInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__CountryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__CountryInfo(soap, tag ? tag : "ns1:CountryInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CountryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CountryInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CountryInfo * SOAP_FMAC4 soap_get_ns1__CountryInfo(struct soap *soap, ns1__CountryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CountryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__AgencyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__AgencyInfo::aid);
	soap_default_std__string(soap, &this->ns1__AgencyInfo::agencyName);
	soap_default_std__string(soap, &this->ns1__AgencyInfo::agencyType);
	soap_default_int(soap, &this->ns1__AgencyInfo::ctid);
	soap_default_int(soap, &this->ns1__AgencyInfo::stid);
	soap_default_xsd__decimal(soap, &this->ns1__AgencyInfo::lat);
	soap_default_xsd__decimal(soap, &this->ns1__AgencyInfo::lon);
	soap_default_xsd__decimal(soap, &this->ns1__AgencyInfo::range);
	soap_default_dateTime(soap, &this->ns1__AgencyInfo::lastUpdated);
	this->ns1__AgencyInfo::cats = NULL;
}

void ns1__AgencyInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__AgencyInfo::agencyName);
	soap_serialize_std__string(soap, &this->ns1__AgencyInfo::agencyType);
	soap_serialize_xsd__decimal(soap, &this->ns1__AgencyInfo::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__AgencyInfo::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__AgencyInfo::range);
	soap_serialize_PointerToCats(soap, &this->ns1__AgencyInfo::cats);
#endif
}

int ns1__AgencyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AgencyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AgencyInfo(struct soap *soap, const char *tag, int id, const ns1__AgencyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AgencyInfo), type))
		return soap->error;
	if (soap_out_int(soap, "aid", -1, &a->ns1__AgencyInfo::aid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "agencyName", -1, &a->ns1__AgencyInfo::agencyName, ""))
		return soap->error;
	if (soap_out_std__string(soap, "agencyType", -1, &a->ns1__AgencyInfo::agencyType, ""))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ns1__AgencyInfo::ctid, ""))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->ns1__AgencyInfo::stid, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__AgencyInfo::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__AgencyInfo::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->ns1__AgencyInfo::range, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "lastUpdated", -1, &a->ns1__AgencyInfo::lastUpdated, ""))
		return soap->error;
	if (!a->ns1__AgencyInfo::cats)
	{	if (soap_element_empty(soap, "cats", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToCats(soap, "cats", -1, &a->ns1__AgencyInfo::cats, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AgencyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__AgencyInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AgencyInfo * SOAP_FMAC4 soap_in_ns1__AgencyInfo(struct soap *soap, const char *tag, ns1__AgencyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AgencyInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AgencyInfo, sizeof(ns1__AgencyInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__AgencyInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__AgencyInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_aid1 = 1;
	size_t soap_flag_agencyName1 = 1;
	size_t soap_flag_agencyType1 = 1;
	size_t soap_flag_ctid1 = 1;
	size_t soap_flag_stid1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_range1 = 1;
	size_t soap_flag_lastUpdated1 = 1;
	size_t soap_flag_cats1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_aid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "aid", &a->ns1__AgencyInfo::aid, "xsd:int"))
				{	soap_flag_aid1--;
					continue;
				}
			}
			if (soap_flag_agencyName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "agencyName", &a->ns1__AgencyInfo::agencyName, "xsd:string"))
				{	soap_flag_agencyName1--;
					continue;
				}
			}
			if (soap_flag_agencyType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "agencyType", &a->ns1__AgencyInfo::agencyType, "xsd:string"))
				{	soap_flag_agencyType1--;
					continue;
				}
			}
			if (soap_flag_ctid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ns1__AgencyInfo::ctid, "xsd:int"))
				{	soap_flag_ctid1--;
					continue;
				}
			}
			if (soap_flag_stid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->ns1__AgencyInfo::stid, "xsd:int"))
				{	soap_flag_stid1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__AgencyInfo::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__AgencyInfo::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_range1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->ns1__AgencyInfo::range, "xsd:decimal"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap_flag_lastUpdated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "lastUpdated", &a->ns1__AgencyInfo::lastUpdated, "xsd:dateTime"))
				{	soap_flag_lastUpdated1--;
					continue;
				}
			}
			if (soap_flag_cats1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToCats(soap, "cats", &a->ns1__AgencyInfo::cats, "ns1:cat"))
				{	soap_flag_cats1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_aid1 > 0 || soap_flag_agencyName1 > 0 || soap_flag_agencyType1 > 0 || soap_flag_ctid1 > 0 || soap_flag_stid1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_range1 > 0 || soap_flag_lastUpdated1 > 0 || !a->ns1__AgencyInfo::cats))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__AgencyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AgencyInfo, SOAP_TYPE_ns1__AgencyInfo, sizeof(ns1__AgencyInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__AgencyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__AgencyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__AgencyInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__AgencyInfo *p;
	size_t k = sizeof(ns1__AgencyInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__AgencyInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__AgencyInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__AgencyInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__AgencyInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__AgencyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__AgencyInfo(soap, tag ? tag : "ns1:AgencyInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AgencyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AgencyInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AgencyInfo * SOAP_FMAC4 soap_get_ns1__AgencyInfo(struct soap *soap, ns1__AgencyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AgencyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__subcat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__subcat::scid);
	soap_default_std__string(soap, &this->ns1__subcat::scName);
	soap_default_xsd__decimal(soap, &this->ns1__subcat::lat);
	soap_default_xsd__decimal(soap, &this->ns1__subcat::lon);
	soap_default_xsd__decimal(soap, &this->ns1__subcat::range);
	this->ns1__subcat::sids_ = NULL;
}

void ns1__subcat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__subcat::scName);
	soap_serialize_xsd__decimal(soap, &this->ns1__subcat::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__subcat::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__subcat::range);
	soap_serialize_PointerTosids(soap, &this->ns1__subcat::sids_);
#endif
}

int ns1__subcat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__subcat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__subcat(struct soap *soap, const char *tag, int id, const ns1__subcat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__subcat), type))
		return soap->error;
	if (soap_out_int(soap, "scid", -1, &a->ns1__subcat::scid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "scName", -1, &a->ns1__subcat::scName, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__subcat::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__subcat::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->ns1__subcat::range, ""))
		return soap->error;
	if (!a->ns1__subcat::sids_)
	{	if (soap_element_empty(soap, "sids", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTosids(soap, "sids", -1, &a->ns1__subcat::sids_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__subcat::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__subcat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__subcat * SOAP_FMAC4 soap_in_ns1__subcat(struct soap *soap, const char *tag, ns1__subcat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__subcat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__subcat, sizeof(ns1__subcat), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__subcat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__subcat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_scid1 = 1;
	size_t soap_flag_scName1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_range1 = 1;
	size_t soap_flag_sids_1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_scid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "scid", &a->ns1__subcat::scid, "xsd:int"))
				{	soap_flag_scid1--;
					continue;
				}
			}
			if (soap_flag_scName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "scName", &a->ns1__subcat::scName, "xsd:string"))
				{	soap_flag_scName1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__subcat::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__subcat::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_range1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->ns1__subcat::range, "xsd:decimal"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap_flag_sids_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosids(soap, "sids", &a->ns1__subcat::sids_, "ns1:sid"))
				{	soap_flag_sids_1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_scid1 > 0 || soap_flag_scName1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_range1 > 0 || !a->ns1__subcat::sids_))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__subcat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__subcat, SOAP_TYPE_ns1__subcat, sizeof(ns1__subcat), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__subcat * SOAP_FMAC2 rrapi__instantiate_ns1__subcat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__subcat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__subcat *p;
	size_t k = sizeof(ns1__subcat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__subcat, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__subcat);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__subcat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__subcat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__subcat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__subcat(soap, tag ? tag : "ns1:subcat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__subcat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__subcat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__subcat * SOAP_FMAC4 soap_get_ns1__subcat(struct soap *soap, ns1__subcat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__subcat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SubCats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void SubCats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_SubCats))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__subcat(soap, this->__ptr + i);
		}
	}
#endif
}

int SubCats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SubCats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SubCats(struct soap *soap, const char *tag, int id, const SubCats *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:subcat", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_SubCats, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__subcat(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *SubCats::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SubCats(soap, tag, this, type);
}

SOAP_FMAC3 SubCats * SOAP_FMAC4 soap_in_SubCats(struct soap *soap, const char *tag, SubCats *a, const char *type)
{
	int i, j;
	ns1__subcat **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (SubCats*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SubCats, sizeof(SubCats), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__subcat **)soap_malloc(soap, sizeof(ns1__subcat *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__subcat(soap, NULL, a->__ptr + i, "ns1:subcat"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__subcat **)soap_push_block(soap, NULL, sizeof(ns1__subcat *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__subcat(soap, NULL, p, "ns1:subcat"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__subcat **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SubCats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SubCats, SOAP_TYPE_SubCats, sizeof(SubCats), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 SubCats * SOAP_FMAC2 rrapi__instantiate_SubCats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SubCats(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SubCats *p;
	size_t k = sizeof(SubCats);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SubCats, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SubCats);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SubCats, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SubCats location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SubCats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SubCats(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SubCats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SubCats(soap, this, tag, type);
}

SOAP_FMAC3 SubCats * SOAP_FMAC4 soap_get_SubCats(struct soap *soap, SubCats *p, const char *tag, const char *type)
{
	if ((p = soap_in_SubCats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__cat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__cat::cid);
	soap_default_std__string(soap, &this->ns1__cat::cName);
	this->ns1__cat::subcats = NULL;
}

void ns1__cat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__cat::cName);
	soap_serialize_PointerToSubCats(soap, &this->ns1__cat::subcats);
#endif
}

int ns1__cat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cat(struct soap *soap, const char *tag, int id, const ns1__cat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cat), type))
		return soap->error;
	if (soap_out_int(soap, "cid", -1, &a->ns1__cat::cid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "cName", -1, &a->ns1__cat::cName, ""))
		return soap->error;
	if (!a->ns1__cat::subcats)
	{	if (soap_element_empty(soap, "subcats", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToSubCats(soap, "subcats", -1, &a->ns1__cat::subcats, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__cat::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__cat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cat * SOAP_FMAC4 soap_in_ns1__cat(struct soap *soap, const char *tag, ns1__cat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cat, sizeof(ns1__cat), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__cat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__cat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_cid1 = 1;
	size_t soap_flag_cName1 = 1;
	size_t soap_flag_subcats1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "cid", &a->ns1__cat::cid, "xsd:int"))
				{	soap_flag_cid1--;
					continue;
				}
			}
			if (soap_flag_cName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "cName", &a->ns1__cat::cName, "xsd:string"))
				{	soap_flag_cName1--;
					continue;
				}
			}
			if (soap_flag_subcats1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSubCats(soap, "subcats", &a->ns1__cat::subcats, "ns1:subcat"))
				{	soap_flag_subcats1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cid1 > 0 || soap_flag_cName1 > 0 || !a->ns1__cat::subcats))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__cat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cat, SOAP_TYPE_ns1__cat, sizeof(ns1__cat), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__cat * SOAP_FMAC2 rrapi__instantiate_ns1__cat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__cat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__cat *p;
	size_t k = sizeof(ns1__cat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__cat, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__cat);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__cat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__cat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__cat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__cat(soap, tag ? tag : "ns1:cat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cat * SOAP_FMAC4 soap_get_ns1__cat(struct soap *soap, ns1__cat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Cats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Cats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Cats))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__cat(soap, this->__ptr + i);
		}
	}
#endif
}

int Cats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Cats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Cats(struct soap *soap, const char *tag, int id, const Cats *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:cat", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Cats, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__cat(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Cats::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Cats(soap, tag, this, type);
}

SOAP_FMAC3 Cats * SOAP_FMAC4 soap_in_Cats(struct soap *soap, const char *tag, Cats *a, const char *type)
{
	int i, j;
	ns1__cat **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Cats*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Cats, sizeof(Cats), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__cat **)soap_malloc(soap, sizeof(ns1__cat *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__cat(soap, NULL, a->__ptr + i, "ns1:cat"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__cat **)soap_push_block(soap, NULL, sizeof(ns1__cat *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__cat(soap, NULL, p, "ns1:cat"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__cat **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Cats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Cats, SOAP_TYPE_Cats, sizeof(Cats), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Cats * SOAP_FMAC2 rrapi__instantiate_Cats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Cats(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Cats *p;
	size_t k = sizeof(Cats);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Cats, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Cats);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Cats, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Cats location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Cats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Cats(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Cats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Cats(soap, this, tag, type);
}

SOAP_FMAC3 Cats * SOAP_FMAC4 soap_get_Cats(struct soap *soap, Cats *p, const char *tag, const char *type)
{
	if ((p = soap_in_Cats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Freqs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Freqs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Freqs))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__freq(soap, this->__ptr + i);
		}
	}
#endif
}

int Freqs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Freqs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Freqs(struct soap *soap, const char *tag, int id, const Freqs *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:freq", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Freqs, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__freq(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Freqs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Freqs(soap, tag, this, type);
}

SOAP_FMAC3 Freqs * SOAP_FMAC4 soap_in_Freqs(struct soap *soap, const char *tag, Freqs *a, const char *type)
{
	int i, j;
	ns1__freq **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Freqs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Freqs, sizeof(Freqs), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__freq **)soap_malloc(soap, sizeof(ns1__freq *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__freq(soap, NULL, a->__ptr + i, "ns1:freq"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__freq **)soap_push_block(soap, NULL, sizeof(ns1__freq *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__freq(soap, NULL, p, "ns1:freq"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__freq **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Freqs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Freqs, SOAP_TYPE_Freqs, sizeof(Freqs), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Freqs * SOAP_FMAC2 rrapi__instantiate_Freqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Freqs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Freqs *p;
	size_t k = sizeof(Freqs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Freqs, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Freqs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Freqs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Freqs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Freqs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Freqs(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Freqs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Freqs(soap, this, tag, type);
}

SOAP_FMAC3 Freqs * SOAP_FMAC4 soap_get_Freqs(struct soap *soap, Freqs *p, const char *tag, const char *type)
{
	if ((p = soap_in_Freqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void searchFreqResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void searchFreqResults::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_searchFreqResults))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__searchFreqResult(soap, this->__ptr + i);
		}
	}
#endif
}

int searchFreqResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_searchFreqResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_searchFreqResults(struct soap *soap, const char *tag, int id, const searchFreqResults *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:searchFreqResult", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_searchFreqResults, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__searchFreqResult(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *searchFreqResults::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_searchFreqResults(soap, tag, this, type);
}

SOAP_FMAC3 searchFreqResults * SOAP_FMAC4 soap_in_searchFreqResults(struct soap *soap, const char *tag, searchFreqResults *a, const char *type)
{
	int i, j;
	ns1__searchFreqResult **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (searchFreqResults*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_searchFreqResults, sizeof(searchFreqResults), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__searchFreqResult **)soap_malloc(soap, sizeof(ns1__searchFreqResult *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__searchFreqResult(soap, NULL, a->__ptr + i, "ns1:searchFreqResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__searchFreqResult **)soap_push_block(soap, NULL, sizeof(ns1__searchFreqResult *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__searchFreqResult(soap, NULL, p, "ns1:searchFreqResult"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__searchFreqResult **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (searchFreqResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_searchFreqResults, SOAP_TYPE_searchFreqResults, sizeof(searchFreqResults), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 searchFreqResults * SOAP_FMAC2 rrapi__instantiate_searchFreqResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_searchFreqResults(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	searchFreqResults *p;
	size_t k = sizeof(searchFreqResults);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_searchFreqResults, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, searchFreqResults);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, searchFreqResults, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated searchFreqResults location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int searchFreqResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_searchFreqResults(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *searchFreqResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_searchFreqResults(soap, this, tag, type);
}

SOAP_FMAC3 searchFreqResults * SOAP_FMAC4 soap_get_searchFreqResults(struct soap *soap, searchFreqResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_searchFreqResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__searchFreqResult::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &this->ns1__searchFreqResult::out);
	soap_default_xsd__decimal(soap, &this->ns1__searchFreqResult::in);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::callsign);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::descr);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::alpha);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::tone);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::colorCode);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::tg);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::slot);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::mode);
	soap_default_std__string(soap, &this->ns1__searchFreqResult::class_);
	this->ns1__searchFreqResult::tags_ = NULL;
	soap_default_int(soap, &this->ns1__searchFreqResult::scid);
	soap_default_int(soap, &this->ns1__searchFreqResult::sid);
	soap_default_int(soap, &this->ns1__searchFreqResult::aid);
	soap_default_int(soap, &this->ns1__searchFreqResult::ctid);
}

void ns1__searchFreqResult::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &this->ns1__searchFreqResult::out);
	soap_serialize_xsd__decimal(soap, &this->ns1__searchFreqResult::in);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::callsign);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::descr);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::alpha);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::tone);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::colorCode);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::tg);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::slot);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::mode);
	soap_serialize_std__string(soap, &this->ns1__searchFreqResult::class_);
	soap_serialize_PointerTotags(soap, &this->ns1__searchFreqResult::tags_);
#endif
}

int ns1__searchFreqResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__searchFreqResult(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchFreqResult(struct soap *soap, const char *tag, int id, const ns1__searchFreqResult *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchFreqResult), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "out", -1, &a->ns1__searchFreqResult::out, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "in", -1, &a->ns1__searchFreqResult::in, ""))
		return soap->error;
	if (soap_out_std__string(soap, "callsign", -1, &a->ns1__searchFreqResult::callsign, ""))
		return soap->error;
	if (soap_out_std__string(soap, "descr", -1, &a->ns1__searchFreqResult::descr, ""))
		return soap->error;
	if (soap_out_std__string(soap, "alpha", -1, &a->ns1__searchFreqResult::alpha, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tone", -1, &a->ns1__searchFreqResult::tone, ""))
		return soap->error;
	if (soap_out_std__string(soap, "colorCode", -1, &a->ns1__searchFreqResult::colorCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tg", -1, &a->ns1__searchFreqResult::tg, ""))
		return soap->error;
	if (soap_out_std__string(soap, "slot", -1, &a->ns1__searchFreqResult::slot, ""))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &a->ns1__searchFreqResult::mode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "class", -1, &a->ns1__searchFreqResult::class_, ""))
		return soap->error;
	if (!a->ns1__searchFreqResult::tags_)
	{	if (soap_element_empty(soap, "tags", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotags(soap, "tags", -1, &a->ns1__searchFreqResult::tags_, ""))
		return soap->error;
	if (soap_out_int(soap, "scid", -1, &a->ns1__searchFreqResult::scid, ""))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->ns1__searchFreqResult::sid, ""))
		return soap->error;
	if (soap_out_int(soap, "aid", -1, &a->ns1__searchFreqResult::aid, ""))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ns1__searchFreqResult::ctid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__searchFreqResult::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__searchFreqResult(soap, tag, this, type);
}

SOAP_FMAC3 ns1__searchFreqResult * SOAP_FMAC4 soap_in_ns1__searchFreqResult(struct soap *soap, const char *tag, ns1__searchFreqResult *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__searchFreqResult*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchFreqResult, sizeof(ns1__searchFreqResult), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__searchFreqResult)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__searchFreqResult *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_out1 = 1;
	size_t soap_flag_in1 = 1;
	size_t soap_flag_callsign1 = 1;
	size_t soap_flag_descr1 = 1;
	size_t soap_flag_alpha1 = 1;
	size_t soap_flag_tone1 = 1;
	size_t soap_flag_colorCode1 = 1;
	size_t soap_flag_tg1 = 1;
	size_t soap_flag_slot1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_class_1 = 1;
	size_t soap_flag_tags_1 = 1;
	size_t soap_flag_scid1 = 1;
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_aid1 = 1;
	size_t soap_flag_ctid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "out", &a->ns1__searchFreqResult::out, "xsd:decimal"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "in", &a->ns1__searchFreqResult::in, "xsd:decimal"))
				{	soap_flag_in1--;
					continue;
				}
			}
			if (soap_flag_callsign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "callsign", &a->ns1__searchFreqResult::callsign, "xsd:string"))
				{	soap_flag_callsign1--;
					continue;
				}
			}
			if (soap_flag_descr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "descr", &a->ns1__searchFreqResult::descr, "xsd:string"))
				{	soap_flag_descr1--;
					continue;
				}
			}
			if (soap_flag_alpha1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "alpha", &a->ns1__searchFreqResult::alpha, "xsd:string"))
				{	soap_flag_alpha1--;
					continue;
				}
			}
			if (soap_flag_tone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tone", &a->ns1__searchFreqResult::tone, "xsd:string"))
				{	soap_flag_tone1--;
					continue;
				}
			}
			if (soap_flag_colorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "colorCode", &a->ns1__searchFreqResult::colorCode, "xsd:string"))
				{	soap_flag_colorCode1--;
					continue;
				}
			}
			if (soap_flag_tg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tg", &a->ns1__searchFreqResult::tg, "xsd:string"))
				{	soap_flag_tg1--;
					continue;
				}
			}
			if (soap_flag_slot1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "slot", &a->ns1__searchFreqResult::slot, "xsd:string"))
				{	soap_flag_slot1--;
					continue;
				}
			}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "mode", &a->ns1__searchFreqResult::mode, "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			}
			if (soap_flag_class_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "class", &a->ns1__searchFreqResult::class_, "xsd:string"))
				{	soap_flag_class_1--;
					continue;
				}
			}
			if (soap_flag_tags_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotags(soap, "tags", &a->ns1__searchFreqResult::tags_, "ns1:tag"))
				{	soap_flag_tags_1--;
					continue;
				}
			}
			if (soap_flag_scid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "scid", &a->ns1__searchFreqResult::scid, "xsd:int"))
				{	soap_flag_scid1--;
					continue;
				}
			}
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->ns1__searchFreqResult::sid, "xsd:int"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_aid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "aid", &a->ns1__searchFreqResult::aid, "xsd:int"))
				{	soap_flag_aid1--;
					continue;
				}
			}
			if (soap_flag_ctid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ns1__searchFreqResult::ctid, "xsd:int"))
				{	soap_flag_ctid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_out1 > 0 || soap_flag_in1 > 0 || soap_flag_callsign1 > 0 || soap_flag_descr1 > 0 || soap_flag_alpha1 > 0 || soap_flag_tone1 > 0 || soap_flag_colorCode1 > 0 || soap_flag_tg1 > 0 || soap_flag_slot1 > 0 || soap_flag_mode1 > 0 || soap_flag_class_1 > 0 || !a->ns1__searchFreqResult::tags_ || soap_flag_scid1 > 0 || soap_flag_sid1 > 0 || soap_flag_aid1 > 0 || soap_flag_ctid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__searchFreqResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchFreqResult, SOAP_TYPE_ns1__searchFreqResult, sizeof(ns1__searchFreqResult), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__searchFreqResult * SOAP_FMAC2 rrapi__instantiate_ns1__searchFreqResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchFreqResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__searchFreqResult *p;
	size_t k = sizeof(ns1__searchFreqResult);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchFreqResult, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__searchFreqResult);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__searchFreqResult, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__searchFreqResult location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__searchFreqResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__searchFreqResult(soap, tag ? tag : "ns1:searchFreqResult", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__searchFreqResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__searchFreqResult(soap, this, tag, type);
}

SOAP_FMAC3 ns1__searchFreqResult * SOAP_FMAC4 soap_get_ns1__searchFreqResult(struct soap *soap, ns1__searchFreqResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchFreqResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__freq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__freq::fid);
	soap_default_xsd__decimal(soap, &this->ns1__freq::out);
	soap_default_xsd__decimal(soap, &this->ns1__freq::in);
	soap_default_std__string(soap, &this->ns1__freq::callsign);
	soap_default_std__string(soap, &this->ns1__freq::descr);
	soap_default_std__string(soap, &this->ns1__freq::alpha);
	soap_default_std__string(soap, &this->ns1__freq::tone);
	soap_default_std__string(soap, &this->ns1__freq::colorCode);
	soap_default_std__string(soap, &this->ns1__freq::tg);
	soap_default_std__string(soap, &this->ns1__freq::slot);
	soap_default_std__string(soap, &this->ns1__freq::mode);
	soap_default_int(soap, &this->ns1__freq::enc);
	soap_default_std__string(soap, &this->ns1__freq::class_);
	this->ns1__freq::tags_ = NULL;
	soap_default_int(soap, &this->ns1__freq::scid);
	soap_default_int(soap, &this->ns1__freq::sort);
	soap_default_dateTime(soap, &this->ns1__freq::lastUpdated);
}

void ns1__freq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &this->ns1__freq::out);
	soap_serialize_xsd__decimal(soap, &this->ns1__freq::in);
	soap_serialize_std__string(soap, &this->ns1__freq::callsign);
	soap_serialize_std__string(soap, &this->ns1__freq::descr);
	soap_serialize_std__string(soap, &this->ns1__freq::alpha);
	soap_serialize_std__string(soap, &this->ns1__freq::tone);
	soap_serialize_std__string(soap, &this->ns1__freq::colorCode);
	soap_serialize_std__string(soap, &this->ns1__freq::tg);
	soap_serialize_std__string(soap, &this->ns1__freq::slot);
	soap_serialize_std__string(soap, &this->ns1__freq::mode);
	soap_serialize_std__string(soap, &this->ns1__freq::class_);
	soap_serialize_PointerTotags(soap, &this->ns1__freq::tags_);
#endif
}

int ns1__freq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__freq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__freq(struct soap *soap, const char *tag, int id, const ns1__freq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__freq), type))
		return soap->error;
	if (soap_out_int(soap, "fid", -1, &a->ns1__freq::fid, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "out", -1, &a->ns1__freq::out, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "in", -1, &a->ns1__freq::in, ""))
		return soap->error;
	if (soap_out_std__string(soap, "callsign", -1, &a->ns1__freq::callsign, ""))
		return soap->error;
	if (soap_out_std__string(soap, "descr", -1, &a->ns1__freq::descr, ""))
		return soap->error;
	if (soap_out_std__string(soap, "alpha", -1, &a->ns1__freq::alpha, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tone", -1, &a->ns1__freq::tone, ""))
		return soap->error;
	if (soap_out_std__string(soap, "colorCode", -1, &a->ns1__freq::colorCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tg", -1, &a->ns1__freq::tg, ""))
		return soap->error;
	if (soap_out_std__string(soap, "slot", -1, &a->ns1__freq::slot, ""))
		return soap->error;
	if (soap_out_std__string(soap, "mode", -1, &a->ns1__freq::mode, ""))
		return soap->error;
	if (soap_out_int(soap, "enc", -1, &a->ns1__freq::enc, ""))
		return soap->error;
	if (soap_out_std__string(soap, "class", -1, &a->ns1__freq::class_, ""))
		return soap->error;
	if (!a->ns1__freq::tags_)
	{	if (soap_element_empty(soap, "tags", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotags(soap, "tags", -1, &a->ns1__freq::tags_, ""))
		return soap->error;
	if (soap_out_int(soap, "scid", -1, &a->ns1__freq::scid, ""))
		return soap->error;
	if (soap_out_int(soap, "sort", -1, &a->ns1__freq::sort, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "lastUpdated", -1, &a->ns1__freq::lastUpdated, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__freq::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__freq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__freq * SOAP_FMAC4 soap_in_ns1__freq(struct soap *soap, const char *tag, ns1__freq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__freq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__freq, sizeof(ns1__freq), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__freq)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__freq *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_fid1 = 1;
	size_t soap_flag_out1 = 1;
	size_t soap_flag_in1 = 1;
	size_t soap_flag_callsign1 = 1;
	size_t soap_flag_descr1 = 1;
	size_t soap_flag_alpha1 = 1;
	size_t soap_flag_tone1 = 1;
	size_t soap_flag_colorCode1 = 1;
	size_t soap_flag_tg1 = 1;
	size_t soap_flag_slot1 = 1;
	size_t soap_flag_mode1 = 1;
	size_t soap_flag_enc1 = 1;
	size_t soap_flag_class_1 = 1;
	size_t soap_flag_tags_1 = 1;
	size_t soap_flag_scid1 = 1;
	size_t soap_flag_sort1 = 1;
	size_t soap_flag_lastUpdated1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "fid", &a->ns1__freq::fid, "xsd:int"))
				{	soap_flag_fid1--;
					continue;
				}
			}
			if (soap_flag_out1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "out", &a->ns1__freq::out, "xsd:decimal"))
				{	soap_flag_out1--;
					continue;
				}
			}
			if (soap_flag_in1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "in", &a->ns1__freq::in, "xsd:decimal"))
				{	soap_flag_in1--;
					continue;
				}
			}
			if (soap_flag_callsign1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "callsign", &a->ns1__freq::callsign, "xsd:string"))
				{	soap_flag_callsign1--;
					continue;
				}
			}
			if (soap_flag_descr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "descr", &a->ns1__freq::descr, "xsd:string"))
				{	soap_flag_descr1--;
					continue;
				}
			}
			if (soap_flag_alpha1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "alpha", &a->ns1__freq::alpha, "xsd:string"))
				{	soap_flag_alpha1--;
					continue;
				}
			}
			if (soap_flag_tone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tone", &a->ns1__freq::tone, "xsd:string"))
				{	soap_flag_tone1--;
					continue;
				}
			}
			if (soap_flag_colorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "colorCode", &a->ns1__freq::colorCode, "xsd:string"))
				{	soap_flag_colorCode1--;
					continue;
				}
			}
			if (soap_flag_tg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tg", &a->ns1__freq::tg, "xsd:string"))
				{	soap_flag_tg1--;
					continue;
				}
			}
			if (soap_flag_slot1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "slot", &a->ns1__freq::slot, "xsd:string"))
				{	soap_flag_slot1--;
					continue;
				}
			}
			if (soap_flag_mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "mode", &a->ns1__freq::mode, "xsd:string"))
				{	soap_flag_mode1--;
					continue;
				}
			}
			if (soap_flag_enc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "enc", &a->ns1__freq::enc, "xsd:int"))
				{	soap_flag_enc1--;
					continue;
				}
			}
			if (soap_flag_class_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "class", &a->ns1__freq::class_, "xsd:string"))
				{	soap_flag_class_1--;
					continue;
				}
			}
			if (soap_flag_tags_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotags(soap, "tags", &a->ns1__freq::tags_, "ns1:tag"))
				{	soap_flag_tags_1--;
					continue;
				}
			}
			if (soap_flag_scid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "scid", &a->ns1__freq::scid, "xsd:int"))
				{	soap_flag_scid1--;
					continue;
				}
			}
			if (soap_flag_sort1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sort", &a->ns1__freq::sort, "xsd:int"))
				{	soap_flag_sort1--;
					continue;
				}
			}
			if (soap_flag_lastUpdated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "lastUpdated", &a->ns1__freq::lastUpdated, "xsd:dateTime"))
				{	soap_flag_lastUpdated1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fid1 > 0 || soap_flag_out1 > 0 || soap_flag_in1 > 0 || soap_flag_callsign1 > 0 || soap_flag_descr1 > 0 || soap_flag_alpha1 > 0 || soap_flag_tone1 > 0 || soap_flag_colorCode1 > 0 || soap_flag_tg1 > 0 || soap_flag_slot1 > 0 || soap_flag_mode1 > 0 || soap_flag_enc1 > 0 || soap_flag_class_1 > 0 || !a->ns1__freq::tags_ || soap_flag_scid1 > 0 || soap_flag_sort1 > 0 || soap_flag_lastUpdated1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__freq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__freq, SOAP_TYPE_ns1__freq, sizeof(ns1__freq), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__freq * SOAP_FMAC2 rrapi__instantiate_ns1__freq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__freq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__freq *p;
	size_t k = sizeof(ns1__freq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__freq, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__freq);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__freq, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__freq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__freq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__freq(soap, tag ? tag : "ns1:freq", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__freq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__freq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__freq * SOAP_FMAC4 soap_get_ns1__freq(struct soap *soap, ns1__freq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__freq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsVoice::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsVoice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsVoice))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__trsVoiceDef(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsVoice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsVoice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsVoice(struct soap *soap, const char *tag, int id, const TrsVoice *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:trsVoiceDef", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsVoice, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__trsVoiceDef(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsVoice::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsVoice(soap, tag, this, type);
}

SOAP_FMAC3 TrsVoice * SOAP_FMAC4 soap_in_TrsVoice(struct soap *soap, const char *tag, TrsVoice *a, const char *type)
{
	int i, j;
	ns1__trsVoiceDef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsVoice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsVoice, sizeof(TrsVoice), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__trsVoiceDef **)soap_malloc(soap, sizeof(ns1__trsVoiceDef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__trsVoiceDef(soap, NULL, a->__ptr + i, "ns1:trsVoiceDef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__trsVoiceDef **)soap_push_block(soap, NULL, sizeof(ns1__trsVoiceDef *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__trsVoiceDef(soap, NULL, p, "ns1:trsVoiceDef"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__trsVoiceDef **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsVoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsVoice, SOAP_TYPE_TrsVoice, sizeof(TrsVoice), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsVoice * SOAP_FMAC2 rrapi__instantiate_TrsVoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsVoice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsVoice *p;
	size_t k = sizeof(TrsVoice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsVoice, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsVoice);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsVoice, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsVoice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsVoice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsVoice(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsVoice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsVoice(soap, this, tag, type);
}

SOAP_FMAC3 TrsVoice * SOAP_FMAC4 soap_get_TrsVoice(struct soap *soap, TrsVoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsVoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__trsVoiceDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__trsVoiceDef::sType);
	soap_default_int(soap, &this->ns1__trsVoiceDef::sVoice);
	soap_default_std__string(soap, &this->ns1__trsVoiceDef::sVoiceDescr);
}

void ns1__trsVoiceDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__trsVoiceDef::sVoiceDescr);
#endif
}

int ns1__trsVoiceDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__trsVoiceDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trsVoiceDef(struct soap *soap, const char *tag, int id, const ns1__trsVoiceDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trsVoiceDef), type))
		return soap->error;
	if (soap_out_int(soap, "sType", -1, &a->ns1__trsVoiceDef::sType, ""))
		return soap->error;
	if (soap_out_int(soap, "sVoice", -1, &a->ns1__trsVoiceDef::sVoice, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sVoiceDescr", -1, &a->ns1__trsVoiceDef::sVoiceDescr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__trsVoiceDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__trsVoiceDef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__trsVoiceDef * SOAP_FMAC4 soap_in_ns1__trsVoiceDef(struct soap *soap, const char *tag, ns1__trsVoiceDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__trsVoiceDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trsVoiceDef, sizeof(ns1__trsVoiceDef), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__trsVoiceDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__trsVoiceDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sType1 = 1;
	size_t soap_flag_sVoice1 = 1;
	size_t soap_flag_sVoiceDescr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sType", &a->ns1__trsVoiceDef::sType, "xsd:int"))
				{	soap_flag_sType1--;
					continue;
				}
			}
			if (soap_flag_sVoice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sVoice", &a->ns1__trsVoiceDef::sVoice, "xsd:int"))
				{	soap_flag_sVoice1--;
					continue;
				}
			}
			if (soap_flag_sVoiceDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sVoiceDescr", &a->ns1__trsVoiceDef::sVoiceDescr, "xsd:string"))
				{	soap_flag_sVoiceDescr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sType1 > 0 || soap_flag_sVoice1 > 0 || soap_flag_sVoiceDescr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__trsVoiceDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trsVoiceDef, SOAP_TYPE_ns1__trsVoiceDef, sizeof(ns1__trsVoiceDef), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__trsVoiceDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsVoiceDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__trsVoiceDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__trsVoiceDef *p;
	size_t k = sizeof(ns1__trsVoiceDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__trsVoiceDef, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__trsVoiceDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__trsVoiceDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__trsVoiceDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__trsVoiceDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__trsVoiceDef(soap, tag ? tag : "ns1:trsVoiceDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__trsVoiceDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__trsVoiceDef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__trsVoiceDef * SOAP_FMAC4 soap_get_ns1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trsVoiceDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsFlavor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsFlavor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsFlavor))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__trsFlavorDef(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsFlavor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsFlavor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsFlavor(struct soap *soap, const char *tag, int id, const TrsFlavor *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:trsFlavorDef", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsFlavor, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__trsFlavorDef(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsFlavor::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsFlavor(soap, tag, this, type);
}

SOAP_FMAC3 TrsFlavor * SOAP_FMAC4 soap_in_TrsFlavor(struct soap *soap, const char *tag, TrsFlavor *a, const char *type)
{
	int i, j;
	ns1__trsFlavorDef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsFlavor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsFlavor, sizeof(TrsFlavor), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__trsFlavorDef **)soap_malloc(soap, sizeof(ns1__trsFlavorDef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__trsFlavorDef(soap, NULL, a->__ptr + i, "ns1:trsFlavorDef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__trsFlavorDef **)soap_push_block(soap, NULL, sizeof(ns1__trsFlavorDef *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__trsFlavorDef(soap, NULL, p, "ns1:trsFlavorDef"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__trsFlavorDef **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsFlavor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsFlavor, SOAP_TYPE_TrsFlavor, sizeof(TrsFlavor), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsFlavor * SOAP_FMAC2 rrapi__instantiate_TrsFlavor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsFlavor(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsFlavor *p;
	size_t k = sizeof(TrsFlavor);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsFlavor, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsFlavor);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsFlavor, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsFlavor location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsFlavor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsFlavor(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsFlavor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsFlavor(soap, this, tag, type);
}

SOAP_FMAC3 TrsFlavor * SOAP_FMAC4 soap_get_TrsFlavor(struct soap *soap, TrsFlavor *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsFlavor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__trsFlavorDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__trsFlavorDef::sType);
	soap_default_int(soap, &this->ns1__trsFlavorDef::sFlavor);
	soap_default_std__string(soap, &this->ns1__trsFlavorDef::sFlavorDescr);
}

void ns1__trsFlavorDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__trsFlavorDef::sFlavorDescr);
#endif
}

int ns1__trsFlavorDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__trsFlavorDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trsFlavorDef(struct soap *soap, const char *tag, int id, const ns1__trsFlavorDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trsFlavorDef), type))
		return soap->error;
	if (soap_out_int(soap, "sType", -1, &a->ns1__trsFlavorDef::sType, ""))
		return soap->error;
	if (soap_out_int(soap, "sFlavor", -1, &a->ns1__trsFlavorDef::sFlavor, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sFlavorDescr", -1, &a->ns1__trsFlavorDef::sFlavorDescr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__trsFlavorDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__trsFlavorDef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__trsFlavorDef * SOAP_FMAC4 soap_in_ns1__trsFlavorDef(struct soap *soap, const char *tag, ns1__trsFlavorDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__trsFlavorDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trsFlavorDef, sizeof(ns1__trsFlavorDef), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__trsFlavorDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__trsFlavorDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sType1 = 1;
	size_t soap_flag_sFlavor1 = 1;
	size_t soap_flag_sFlavorDescr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sType", &a->ns1__trsFlavorDef::sType, "xsd:int"))
				{	soap_flag_sType1--;
					continue;
				}
			}
			if (soap_flag_sFlavor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sFlavor", &a->ns1__trsFlavorDef::sFlavor, "xsd:int"))
				{	soap_flag_sFlavor1--;
					continue;
				}
			}
			if (soap_flag_sFlavorDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sFlavorDescr", &a->ns1__trsFlavorDef::sFlavorDescr, "xsd:string"))
				{	soap_flag_sFlavorDescr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sType1 > 0 || soap_flag_sFlavor1 > 0 || soap_flag_sFlavorDescr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__trsFlavorDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trsFlavorDef, SOAP_TYPE_ns1__trsFlavorDef, sizeof(ns1__trsFlavorDef), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__trsFlavorDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsFlavorDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__trsFlavorDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__trsFlavorDef *p;
	size_t k = sizeof(ns1__trsFlavorDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__trsFlavorDef, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__trsFlavorDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__trsFlavorDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__trsFlavorDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__trsFlavorDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__trsFlavorDef(soap, tag ? tag : "ns1:trsFlavorDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__trsFlavorDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__trsFlavorDef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__trsFlavorDef * SOAP_FMAC4 soap_get_ns1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trsFlavorDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsType))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__trsTypeDef(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsType(struct soap *soap, const char *tag, int id, const TrsType *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:trsTypeDef", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsType, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__trsTypeDef(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsType(soap, tag, this, type);
}

SOAP_FMAC3 TrsType * SOAP_FMAC4 soap_in_TrsType(struct soap *soap, const char *tag, TrsType *a, const char *type)
{
	int i, j;
	ns1__trsTypeDef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsType, sizeof(TrsType), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__trsTypeDef **)soap_malloc(soap, sizeof(ns1__trsTypeDef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__trsTypeDef(soap, NULL, a->__ptr + i, "ns1:trsTypeDef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__trsTypeDef **)soap_push_block(soap, NULL, sizeof(ns1__trsTypeDef *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__trsTypeDef(soap, NULL, p, "ns1:trsTypeDef"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__trsTypeDef **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsType, SOAP_TYPE_TrsType, sizeof(TrsType), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsType * SOAP_FMAC2 rrapi__instantiate_TrsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsType *p;
	size_t k = sizeof(TrsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsType, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsType(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsType(soap, this, tag, type);
}

SOAP_FMAC3 TrsType * SOAP_FMAC4 soap_get_TrsType(struct soap *soap, TrsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__trsTypeDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__trsTypeDef::sType);
	soap_default_std__string(soap, &this->ns1__trsTypeDef::sTypeDescr);
}

void ns1__trsTypeDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__trsTypeDef::sTypeDescr);
#endif
}

int ns1__trsTypeDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__trsTypeDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trsTypeDef(struct soap *soap, const char *tag, int id, const ns1__trsTypeDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trsTypeDef), type))
		return soap->error;
	if (soap_out_int(soap, "sType", -1, &a->ns1__trsTypeDef::sType, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sTypeDescr", -1, &a->ns1__trsTypeDef::sTypeDescr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__trsTypeDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__trsTypeDef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__trsTypeDef * SOAP_FMAC4 soap_in_ns1__trsTypeDef(struct soap *soap, const char *tag, ns1__trsTypeDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__trsTypeDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trsTypeDef, sizeof(ns1__trsTypeDef), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__trsTypeDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__trsTypeDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sType1 = 1;
	size_t soap_flag_sTypeDescr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sType", &a->ns1__trsTypeDef::sType, "xsd:int"))
				{	soap_flag_sType1--;
					continue;
				}
			}
			if (soap_flag_sTypeDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sTypeDescr", &a->ns1__trsTypeDef::sTypeDescr, "xsd:string"))
				{	soap_flag_sTypeDescr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sType1 > 0 || soap_flag_sTypeDescr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__trsTypeDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trsTypeDef, SOAP_TYPE_ns1__trsTypeDef, sizeof(ns1__trsTypeDef), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__trsTypeDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsTypeDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__trsTypeDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__trsTypeDef *p;
	size_t k = sizeof(ns1__trsTypeDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__trsTypeDef, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__trsTypeDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__trsTypeDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__trsTypeDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__trsTypeDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__trsTypeDef(soap, tag ? tag : "ns1:trsTypeDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__trsTypeDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__trsTypeDef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__trsTypeDef * SOAP_FMAC4 soap_get_ns1__trsTypeDef(struct soap *soap, ns1__trsTypeDef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trsTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TrsFleetmap::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b0);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b1);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b2);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b3);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b4);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b5);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b6);
	soap_default_std__string(soap, &this->ns1__TrsFleetmap::b7);
}

void ns1__TrsFleetmap::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b0);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b1);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b2);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b3);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b4);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b5);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b6);
	soap_serialize_std__string(soap, &this->ns1__TrsFleetmap::b7);
#endif
}

int ns1__TrsFleetmap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TrsFleetmap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrsFleetmap(struct soap *soap, const char *tag, int id, const ns1__TrsFleetmap *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrsFleetmap), type))
		return soap->error;
	if (soap_out_std__string(soap, "b0", -1, &a->ns1__TrsFleetmap::b0, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b1", -1, &a->ns1__TrsFleetmap::b1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b2", -1, &a->ns1__TrsFleetmap::b2, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b3", -1, &a->ns1__TrsFleetmap::b3, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b4", -1, &a->ns1__TrsFleetmap::b4, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b5", -1, &a->ns1__TrsFleetmap::b5, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b6", -1, &a->ns1__TrsFleetmap::b6, ""))
		return soap->error;
	if (soap_out_std__string(soap, "b7", -1, &a->ns1__TrsFleetmap::b7, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TrsFleetmap::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TrsFleetmap(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TrsFleetmap * SOAP_FMAC4 soap_in_ns1__TrsFleetmap(struct soap *soap, const char *tag, ns1__TrsFleetmap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TrsFleetmap*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrsFleetmap, sizeof(ns1__TrsFleetmap), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TrsFleetmap)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TrsFleetmap *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_b01 = 1;
	size_t soap_flag_b11 = 1;
	size_t soap_flag_b21 = 1;
	size_t soap_flag_b31 = 1;
	size_t soap_flag_b41 = 1;
	size_t soap_flag_b51 = 1;
	size_t soap_flag_b61 = 1;
	size_t soap_flag_b71 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_b01 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b0", &a->ns1__TrsFleetmap::b0, "xsd:string"))
				{	soap_flag_b01--;
					continue;
				}
			}
			if (soap_flag_b11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b1", &a->ns1__TrsFleetmap::b1, "xsd:string"))
				{	soap_flag_b11--;
					continue;
				}
			}
			if (soap_flag_b21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b2", &a->ns1__TrsFleetmap::b2, "xsd:string"))
				{	soap_flag_b21--;
					continue;
				}
			}
			if (soap_flag_b31 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b3", &a->ns1__TrsFleetmap::b3, "xsd:string"))
				{	soap_flag_b31--;
					continue;
				}
			}
			if (soap_flag_b41 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b4", &a->ns1__TrsFleetmap::b4, "xsd:string"))
				{	soap_flag_b41--;
					continue;
				}
			}
			if (soap_flag_b51 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b5", &a->ns1__TrsFleetmap::b5, "xsd:string"))
				{	soap_flag_b51--;
					continue;
				}
			}
			if (soap_flag_b61 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b6", &a->ns1__TrsFleetmap::b6, "xsd:string"))
				{	soap_flag_b61--;
					continue;
				}
			}
			if (soap_flag_b71 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "b7", &a->ns1__TrsFleetmap::b7, "xsd:string"))
				{	soap_flag_b71--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_b01 > 0 || soap_flag_b11 > 0 || soap_flag_b21 > 0 || soap_flag_b31 > 0 || soap_flag_b41 > 0 || soap_flag_b51 > 0 || soap_flag_b61 > 0 || soap_flag_b71 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TrsFleetmap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TrsFleetmap, SOAP_TYPE_ns1__TrsFleetmap, sizeof(ns1__TrsFleetmap), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TrsFleetmap * SOAP_FMAC2 rrapi__instantiate_ns1__TrsFleetmap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__TrsFleetmap(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TrsFleetmap *p;
	size_t k = sizeof(ns1__TrsFleetmap);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TrsFleetmap, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TrsFleetmap);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TrsFleetmap, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TrsFleetmap location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TrsFleetmap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TrsFleetmap(soap, tag ? tag : "ns1:TrsFleetmap", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TrsFleetmap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TrsFleetmap(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TrsFleetmap * SOAP_FMAC4 soap_get_ns1__TrsFleetmap(struct soap *soap, ns1__TrsFleetmap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrsFleetmap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsBandplan::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsBandplan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsBandplan))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__trsBandplanDef(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsBandplan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsBandplan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsBandplan(struct soap *soap, const char *tag, int id, const TrsBandplan *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:trsBandplanDef", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsBandplan, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__trsBandplanDef(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsBandplan::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsBandplan(soap, tag, this, type);
}

SOAP_FMAC3 TrsBandplan * SOAP_FMAC4 soap_in_TrsBandplan(struct soap *soap, const char *tag, TrsBandplan *a, const char *type)
{
	int i, j;
	ns1__trsBandplanDef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsBandplan*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsBandplan, sizeof(TrsBandplan), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__trsBandplanDef **)soap_malloc(soap, sizeof(ns1__trsBandplanDef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__trsBandplanDef(soap, NULL, a->__ptr + i, "ns1:trsBandplanDef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__trsBandplanDef **)soap_push_block(soap, NULL, sizeof(ns1__trsBandplanDef *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__trsBandplanDef(soap, NULL, p, "ns1:trsBandplanDef"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__trsBandplanDef **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsBandplan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsBandplan, SOAP_TYPE_TrsBandplan, sizeof(TrsBandplan), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsBandplan * SOAP_FMAC2 rrapi__instantiate_TrsBandplan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsBandplan(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsBandplan *p;
	size_t k = sizeof(TrsBandplan);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsBandplan, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsBandplan);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsBandplan, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsBandplan location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsBandplan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsBandplan(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsBandplan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsBandplan(soap, this, tag, type);
}

SOAP_FMAC3 TrsBandplan * SOAP_FMAC4 soap_get_TrsBandplan(struct soap *soap, TrsBandplan *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsBandplan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__trsBandplanDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__trsBandplanDef::base);
	soap_default_std__string(soap, &this->ns1__trsBandplanDef::spacing);
	soap_default_std__string(soap, &this->ns1__trsBandplanDef::offset);
}

void ns1__trsBandplanDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__trsBandplanDef::base);
	soap_serialize_std__string(soap, &this->ns1__trsBandplanDef::spacing);
	soap_serialize_std__string(soap, &this->ns1__trsBandplanDef::offset);
#endif
}

int ns1__trsBandplanDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__trsBandplanDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trsBandplanDef(struct soap *soap, const char *tag, int id, const ns1__trsBandplanDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trsBandplanDef), type))
		return soap->error;
	if (soap_out_std__string(soap, "base", -1, &a->ns1__trsBandplanDef::base, ""))
		return soap->error;
	if (soap_out_std__string(soap, "spacing", -1, &a->ns1__trsBandplanDef::spacing, ""))
		return soap->error;
	if (soap_out_std__string(soap, "offset", -1, &a->ns1__trsBandplanDef::offset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__trsBandplanDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__trsBandplanDef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__trsBandplanDef * SOAP_FMAC4 soap_in_ns1__trsBandplanDef(struct soap *soap, const char *tag, ns1__trsBandplanDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__trsBandplanDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trsBandplanDef, sizeof(ns1__trsBandplanDef), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__trsBandplanDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__trsBandplanDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_base1 = 1;
	size_t soap_flag_spacing1 = 1;
	size_t soap_flag_offset1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "base", &a->ns1__trsBandplanDef::base, "xsd:string"))
				{	soap_flag_base1--;
					continue;
				}
			}
			if (soap_flag_spacing1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "spacing", &a->ns1__trsBandplanDef::spacing, "xsd:string"))
				{	soap_flag_spacing1--;
					continue;
				}
			}
			if (soap_flag_offset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "offset", &a->ns1__trsBandplanDef::offset, "xsd:string"))
				{	soap_flag_offset1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_base1 > 0 || soap_flag_spacing1 > 0 || soap_flag_offset1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__trsBandplanDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trsBandplanDef, SOAP_TYPE_ns1__trsBandplanDef, sizeof(ns1__trsBandplanDef), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__trsBandplanDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsBandplanDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__trsBandplanDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__trsBandplanDef *p;
	size_t k = sizeof(ns1__trsBandplanDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__trsBandplanDef, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__trsBandplanDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__trsBandplanDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__trsBandplanDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__trsBandplanDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__trsBandplanDef(soap, tag ? tag : "ns1:trsBandplanDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__trsBandplanDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__trsBandplanDef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__trsBandplanDef * SOAP_FMAC4 soap_get_ns1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trsBandplanDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsSysid::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsSysid::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsSysid))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__trsSysidDef(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsSysid::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsSysid(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsSysid(struct soap *soap, const char *tag, int id, const TrsSysid *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:trsSysidDef", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsSysid, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__trsSysidDef(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsSysid::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsSysid(soap, tag, this, type);
}

SOAP_FMAC3 TrsSysid * SOAP_FMAC4 soap_in_TrsSysid(struct soap *soap, const char *tag, TrsSysid *a, const char *type)
{
	int i, j;
	ns1__trsSysidDef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsSysid*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsSysid, sizeof(TrsSysid), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__trsSysidDef **)soap_malloc(soap, sizeof(ns1__trsSysidDef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__trsSysidDef(soap, NULL, a->__ptr + i, "ns1:trsSysidDef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__trsSysidDef **)soap_push_block(soap, NULL, sizeof(ns1__trsSysidDef *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__trsSysidDef(soap, NULL, p, "ns1:trsSysidDef"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__trsSysidDef **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsSysid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsSysid, SOAP_TYPE_TrsSysid, sizeof(TrsSysid), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsSysid * SOAP_FMAC2 rrapi__instantiate_TrsSysid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsSysid(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsSysid *p;
	size_t k = sizeof(TrsSysid);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsSysid, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsSysid);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsSysid, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsSysid location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsSysid::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsSysid(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsSysid::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsSysid(soap, this, tag, type);
}

SOAP_FMAC3 TrsSysid * SOAP_FMAC4 soap_get_TrsSysid(struct soap *soap, TrsSysid *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsSysid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__trsSysidDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__trsSysidDef::sysid);
	soap_default_std__string(soap, &this->ns1__trsSysidDef::ct);
	soap_default_std__string(soap, &this->ns1__trsSysidDef::wacn);
}

void ns1__trsSysidDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__trsSysidDef::sysid);
	soap_serialize_std__string(soap, &this->ns1__trsSysidDef::ct);
	soap_serialize_std__string(soap, &this->ns1__trsSysidDef::wacn);
#endif
}

int ns1__trsSysidDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__trsSysidDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__trsSysidDef(struct soap *soap, const char *tag, int id, const ns1__trsSysidDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__trsSysidDef), type))
		return soap->error;
	if (soap_out_std__string(soap, "sysid", -1, &a->ns1__trsSysidDef::sysid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ct", -1, &a->ns1__trsSysidDef::ct, ""))
		return soap->error;
	if (soap_out_std__string(soap, "wacn", -1, &a->ns1__trsSysidDef::wacn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__trsSysidDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__trsSysidDef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__trsSysidDef * SOAP_FMAC4 soap_in_ns1__trsSysidDef(struct soap *soap, const char *tag, ns1__trsSysidDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__trsSysidDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__trsSysidDef, sizeof(ns1__trsSysidDef), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__trsSysidDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__trsSysidDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sysid1 = 1;
	size_t soap_flag_ct1 = 1;
	size_t soap_flag_wacn1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sysid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sysid", &a->ns1__trsSysidDef::sysid, "xsd:string"))
				{	soap_flag_sysid1--;
					continue;
				}
			}
			if (soap_flag_ct1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ct", &a->ns1__trsSysidDef::ct, "xsd:string"))
				{	soap_flag_ct1--;
					continue;
				}
			}
			if (soap_flag_wacn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "wacn", &a->ns1__trsSysidDef::wacn, "xsd:string"))
				{	soap_flag_wacn1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sysid1 > 0 || soap_flag_ct1 > 0 || soap_flag_wacn1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__trsSysidDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__trsSysidDef, SOAP_TYPE_ns1__trsSysidDef, sizeof(ns1__trsSysidDef), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__trsSysidDef * SOAP_FMAC2 rrapi__instantiate_ns1__trsSysidDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__trsSysidDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__trsSysidDef *p;
	size_t k = sizeof(ns1__trsSysidDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__trsSysidDef, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__trsSysidDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__trsSysidDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__trsSysidDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__trsSysidDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__trsSysidDef(soap, tag ? tag : "ns1:trsSysidDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__trsSysidDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__trsSysidDef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__trsSysidDef * SOAP_FMAC4 soap_get_ns1__trsSysidDef(struct soap *soap, ns1__trsSysidDef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__trsSysidDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsList))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__TrsListDef(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsList(struct soap *soap, const char *tag, int id, const TrsList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:TrsListDef", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__TrsListDef(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsList(soap, tag, this, type);
}

SOAP_FMAC3 TrsList * SOAP_FMAC4 soap_in_TrsList(struct soap *soap, const char *tag, TrsList *a, const char *type)
{
	int i, j;
	ns1__TrsListDef **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsList, sizeof(TrsList), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__TrsListDef **)soap_malloc(soap, sizeof(ns1__TrsListDef *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__TrsListDef(soap, NULL, a->__ptr + i, "ns1:TrsListDef"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__TrsListDef **)soap_push_block(soap, NULL, sizeof(ns1__TrsListDef *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__TrsListDef(soap, NULL, p, "ns1:TrsListDef"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__TrsListDef **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsList, SOAP_TYPE_TrsList, sizeof(TrsList), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsList * SOAP_FMAC2 rrapi__instantiate_TrsList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsList *p;
	size_t k = sizeof(TrsList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsList, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsList(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsList(soap, this, tag, type);
}

SOAP_FMAC3 TrsList * SOAP_FMAC4 soap_get_TrsList(struct soap *soap, TrsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TrsListDef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TrsListDef::sid);
	soap_default_std__string(soap, &this->ns1__TrsListDef::sName);
	soap_default_int(soap, &this->ns1__TrsListDef::sType);
	soap_default_int(soap, &this->ns1__TrsListDef::sFlavor);
	soap_default_int(soap, &this->ns1__TrsListDef::sVoice);
	soap_default_std__string(soap, &this->ns1__TrsListDef::sCity);
	soap_default_dateTime(soap, &this->ns1__TrsListDef::lastUpdated);
}

void ns1__TrsListDef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__TrsListDef::sName);
	soap_serialize_std__string(soap, &this->ns1__TrsListDef::sCity);
#endif
}

int ns1__TrsListDef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TrsListDef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrsListDef(struct soap *soap, const char *tag, int id, const ns1__TrsListDef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrsListDef), type))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->ns1__TrsListDef::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &a->ns1__TrsListDef::sName, ""))
		return soap->error;
	if (soap_out_int(soap, "sType", -1, &a->ns1__TrsListDef::sType, ""))
		return soap->error;
	if (soap_out_int(soap, "sFlavor", -1, &a->ns1__TrsListDef::sFlavor, ""))
		return soap->error;
	if (soap_out_int(soap, "sVoice", -1, &a->ns1__TrsListDef::sVoice, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sCity", -1, &a->ns1__TrsListDef::sCity, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "lastUpdated", -1, &a->ns1__TrsListDef::lastUpdated, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TrsListDef::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TrsListDef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TrsListDef * SOAP_FMAC4 soap_in_ns1__TrsListDef(struct soap *soap, const char *tag, ns1__TrsListDef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TrsListDef*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrsListDef, sizeof(ns1__TrsListDef), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TrsListDef)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TrsListDef *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_sType1 = 1;
	size_t soap_flag_sFlavor1 = 1;
	size_t soap_flag_sVoice1 = 1;
	size_t soap_flag_sCity1 = 1;
	size_t soap_flag_lastUpdated1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->ns1__TrsListDef::sid, "xsd:int"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sName", &a->ns1__TrsListDef::sName, "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			}
			if (soap_flag_sType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sType", &a->ns1__TrsListDef::sType, "xsd:int"))
				{	soap_flag_sType1--;
					continue;
				}
			}
			if (soap_flag_sFlavor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sFlavor", &a->ns1__TrsListDef::sFlavor, "xsd:int"))
				{	soap_flag_sFlavor1--;
					continue;
				}
			}
			if (soap_flag_sVoice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sVoice", &a->ns1__TrsListDef::sVoice, "xsd:int"))
				{	soap_flag_sVoice1--;
					continue;
				}
			}
			if (soap_flag_sCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sCity", &a->ns1__TrsListDef::sCity, "xsd:string"))
				{	soap_flag_sCity1--;
					continue;
				}
			}
			if (soap_flag_lastUpdated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "lastUpdated", &a->ns1__TrsListDef::lastUpdated, "xsd:dateTime"))
				{	soap_flag_lastUpdated1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid1 > 0 || soap_flag_sName1 > 0 || soap_flag_sType1 > 0 || soap_flag_sFlavor1 > 0 || soap_flag_sVoice1 > 0 || soap_flag_sCity1 > 0 || soap_flag_lastUpdated1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TrsListDef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TrsListDef, SOAP_TYPE_ns1__TrsListDef, sizeof(ns1__TrsListDef), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TrsListDef * SOAP_FMAC2 rrapi__instantiate_ns1__TrsListDef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__TrsListDef(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TrsListDef *p;
	size_t k = sizeof(ns1__TrsListDef);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TrsListDef, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TrsListDef);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TrsListDef, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TrsListDef location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TrsListDef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TrsListDef(soap, tag ? tag : "ns1:TrsListDef", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TrsListDef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TrsListDef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TrsListDef * SOAP_FMAC4 soap_get_ns1__TrsListDef(struct soap *soap, ns1__TrsListDef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrsListDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Trs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Trs::sName);
	soap_default_int(soap, &this->ns1__Trs::sType);
	soap_default_int(soap, &this->ns1__Trs::sFlavor);
	soap_default_int(soap, &this->ns1__Trs::sVoice);
	soap_default_std__string(soap, &this->ns1__Trs::sCity);
	this->ns1__Trs::sCounty = NULL;
	this->ns1__Trs::sState = NULL;
	soap_default_std__string(soap, &this->ns1__Trs::sCountry);
	soap_default_xsd__decimal(soap, &this->ns1__Trs::lat);
	soap_default_xsd__decimal(soap, &this->ns1__Trs::lon);
	soap_default_xsd__decimal(soap, &this->ns1__Trs::range);
	soap_default_dateTime(soap, &this->ns1__Trs::lastUpdated);
	this->ns1__Trs::sysid = NULL;
	this->ns1__Trs::bandplan = NULL;
	this->ns1__Trs::fleetmap = NULL;
}

void ns1__Trs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__Trs::sName);
	soap_serialize_std__string(soap, &this->ns1__Trs::sCity);
	soap_serialize_PointerToctids(soap, &this->ns1__Trs::sCounty);
	soap_serialize_PointerTostids(soap, &this->ns1__Trs::sState);
	soap_serialize_std__string(soap, &this->ns1__Trs::sCountry);
	soap_serialize_xsd__decimal(soap, &this->ns1__Trs::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__Trs::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__Trs::range);
	soap_serialize_PointerToTrsSysid(soap, &this->ns1__Trs::sysid);
	soap_serialize_PointerToTrsBandplan(soap, &this->ns1__Trs::bandplan);
	soap_serialize_PointerTons1__TrsFleetmap(soap, &this->ns1__Trs::fleetmap);
#endif
}

int ns1__Trs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Trs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Trs(struct soap *soap, const char *tag, int id, const ns1__Trs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Trs), type))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &a->ns1__Trs::sName, ""))
		return soap->error;
	if (soap_out_int(soap, "sType", -1, &a->ns1__Trs::sType, ""))
		return soap->error;
	if (soap_out_int(soap, "sFlavor", -1, &a->ns1__Trs::sFlavor, ""))
		return soap->error;
	if (soap_out_int(soap, "sVoice", -1, &a->ns1__Trs::sVoice, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sCity", -1, &a->ns1__Trs::sCity, ""))
		return soap->error;
	if (!a->ns1__Trs::sCounty)
	{	if (soap_element_empty(soap, "sCounty", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToctids(soap, "sCounty", -1, &a->ns1__Trs::sCounty, ""))
		return soap->error;
	if (!a->ns1__Trs::sState)
	{	if (soap_element_empty(soap, "sState", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTostids(soap, "sState", -1, &a->ns1__Trs::sState, ""))
		return soap->error;
	if (soap_out_std__string(soap, "sCountry", -1, &a->ns1__Trs::sCountry, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__Trs::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__Trs::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->ns1__Trs::range, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "lastUpdated", -1, &a->ns1__Trs::lastUpdated, ""))
		return soap->error;
	if (!a->ns1__Trs::sysid)
	{	if (soap_element_empty(soap, "sysid", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsSysid(soap, "sysid", -1, &a->ns1__Trs::sysid, ""))
		return soap->error;
	if (!a->ns1__Trs::bandplan)
	{	if (soap_element_empty(soap, "bandplan", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsBandplan(soap, "bandplan", -1, &a->ns1__Trs::bandplan, ""))
		return soap->error;
	if (!a->ns1__Trs::fleetmap)
	{	if (soap_element_empty(soap, "fleetmap", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTons1__TrsFleetmap(soap, "fleetmap", -1, &a->ns1__Trs::fleetmap, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Trs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Trs(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Trs * SOAP_FMAC4 soap_in_ns1__Trs(struct soap *soap, const char *tag, ns1__Trs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Trs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Trs, sizeof(ns1__Trs), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Trs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Trs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_sType1 = 1;
	size_t soap_flag_sFlavor1 = 1;
	size_t soap_flag_sVoice1 = 1;
	size_t soap_flag_sCity1 = 1;
	size_t soap_flag_sCounty1 = 1;
	size_t soap_flag_sState1 = 1;
	size_t soap_flag_sCountry1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_range1 = 1;
	size_t soap_flag_lastUpdated1 = 1;
	size_t soap_flag_sysid1 = 1;
	size_t soap_flag_bandplan1 = 1;
	size_t soap_flag_fleetmap1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sName", &a->ns1__Trs::sName, "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			}
			if (soap_flag_sType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sType", &a->ns1__Trs::sType, "xsd:int"))
				{	soap_flag_sType1--;
					continue;
				}
			}
			if (soap_flag_sFlavor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sFlavor", &a->ns1__Trs::sFlavor, "xsd:int"))
				{	soap_flag_sFlavor1--;
					continue;
				}
			}
			if (soap_flag_sVoice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sVoice", &a->ns1__Trs::sVoice, "xsd:int"))
				{	soap_flag_sVoice1--;
					continue;
				}
			}
			if (soap_flag_sCity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sCity", &a->ns1__Trs::sCity, "xsd:string"))
				{	soap_flag_sCity1--;
					continue;
				}
			}
			if (soap_flag_sCounty1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToctids(soap, "sCounty", &a->ns1__Trs::sCounty, "ns1:ctid"))
				{	soap_flag_sCounty1--;
					continue;
				}
			}
			if (soap_flag_sState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostids(soap, "sState", &a->ns1__Trs::sState, "ns1:stid"))
				{	soap_flag_sState1--;
					continue;
				}
			}
			if (soap_flag_sCountry1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sCountry", &a->ns1__Trs::sCountry, "xsd:string"))
				{	soap_flag_sCountry1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__Trs::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__Trs::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_range1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->ns1__Trs::range, "xsd:decimal"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap_flag_lastUpdated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "lastUpdated", &a->ns1__Trs::lastUpdated, "xsd:dateTime"))
				{	soap_flag_lastUpdated1--;
					continue;
				}
			}
			if (soap_flag_sysid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsSysid(soap, "sysid", &a->ns1__Trs::sysid, "ns1:trsSysidDef"))
				{	soap_flag_sysid1--;
					continue;
				}
			}
			if (soap_flag_bandplan1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsBandplan(soap, "bandplan", &a->ns1__Trs::bandplan, "ns1:trsBandplanDef"))
				{	soap_flag_bandplan1--;
					continue;
				}
			}
			if (soap_flag_fleetmap1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__TrsFleetmap(soap, "fleetmap", &a->ns1__Trs::fleetmap, "ns1:TrsFleetmap"))
				{	soap_flag_fleetmap1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sName1 > 0 || soap_flag_sType1 > 0 || soap_flag_sFlavor1 > 0 || soap_flag_sVoice1 > 0 || soap_flag_sCity1 > 0 || !a->ns1__Trs::sCounty || !a->ns1__Trs::sState || soap_flag_sCountry1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_range1 > 0 || soap_flag_lastUpdated1 > 0 || !a->ns1__Trs::sysid || !a->ns1__Trs::bandplan || !a->ns1__Trs::fleetmap))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Trs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Trs, SOAP_TYPE_ns1__Trs, sizeof(ns1__Trs), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Trs * SOAP_FMAC2 rrapi__instantiate_ns1__Trs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__Trs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Trs *p;
	size_t k = sizeof(ns1__Trs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Trs, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Trs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Trs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Trs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Trs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Trs(soap, tag ? tag : "ns1:Trs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Trs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Trs(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Trs * SOAP_FMAC4 soap_get_ns1__Trs(struct soap *soap, ns1__Trs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Trs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsSiteLicenses::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsSiteLicenses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsSiteLicenses))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__TrsSiteLicense(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsSiteLicenses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsSiteLicenses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsSiteLicenses(struct soap *soap, const char *tag, int id, const TrsSiteLicenses *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:TrsSiteLicense", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsSiteLicenses, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__TrsSiteLicense(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsSiteLicenses::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsSiteLicenses(soap, tag, this, type);
}

SOAP_FMAC3 TrsSiteLicenses * SOAP_FMAC4 soap_in_TrsSiteLicenses(struct soap *soap, const char *tag, TrsSiteLicenses *a, const char *type)
{
	int i, j;
	ns1__TrsSiteLicense **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsSiteLicenses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsSiteLicenses, sizeof(TrsSiteLicenses), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__TrsSiteLicense **)soap_malloc(soap, sizeof(ns1__TrsSiteLicense *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__TrsSiteLicense(soap, NULL, a->__ptr + i, "ns1:TrsSiteLicense"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__TrsSiteLicense **)soap_push_block(soap, NULL, sizeof(ns1__TrsSiteLicense *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__TrsSiteLicense(soap, NULL, p, "ns1:TrsSiteLicense"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__TrsSiteLicense **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsSiteLicenses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsSiteLicenses, SOAP_TYPE_TrsSiteLicenses, sizeof(TrsSiteLicenses), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsSiteLicenses * SOAP_FMAC2 rrapi__instantiate_TrsSiteLicenses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsSiteLicenses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsSiteLicenses *p;
	size_t k = sizeof(TrsSiteLicenses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsSiteLicenses, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsSiteLicenses);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsSiteLicenses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsSiteLicenses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsSiteLicenses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsSiteLicenses(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsSiteLicenses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsSiteLicenses(soap, this, tag, type);
}

SOAP_FMAC3 TrsSiteLicenses * SOAP_FMAC4 soap_get_TrsSiteLicenses(struct soap *soap, TrsSiteLicenses *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsSiteLicenses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TrsSiteLicense::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__TrsSiteLicense::license);
}

void ns1__TrsSiteLicense::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__TrsSiteLicense::license);
#endif
}

int ns1__TrsSiteLicense::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TrsSiteLicense(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrsSiteLicense(struct soap *soap, const char *tag, int id, const ns1__TrsSiteLicense *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrsSiteLicense), type))
		return soap->error;
	if (soap_out_std__string(soap, "license", -1, &a->ns1__TrsSiteLicense::license, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TrsSiteLicense::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TrsSiteLicense(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TrsSiteLicense * SOAP_FMAC4 soap_in_ns1__TrsSiteLicense(struct soap *soap, const char *tag, ns1__TrsSiteLicense *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TrsSiteLicense*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrsSiteLicense, sizeof(ns1__TrsSiteLicense), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TrsSiteLicense)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TrsSiteLicense *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_license1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_license1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "license", &a->ns1__TrsSiteLicense::license, "xsd:string"))
				{	soap_flag_license1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_license1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TrsSiteLicense *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TrsSiteLicense, SOAP_TYPE_ns1__TrsSiteLicense, sizeof(ns1__TrsSiteLicense), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TrsSiteLicense * SOAP_FMAC2 rrapi__instantiate_ns1__TrsSiteLicense(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__TrsSiteLicense(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TrsSiteLicense *p;
	size_t k = sizeof(ns1__TrsSiteLicense);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TrsSiteLicense, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TrsSiteLicense);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TrsSiteLicense, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TrsSiteLicense location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TrsSiteLicense::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TrsSiteLicense(soap, tag ? tag : "ns1:TrsSiteLicense", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TrsSiteLicense::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TrsSiteLicense(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TrsSiteLicense * SOAP_FMAC4 soap_get_ns1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrsSiteLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsSiteFreqs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsSiteFreqs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsSiteFreqs))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__TrsSiteFreq(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsSiteFreqs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsSiteFreqs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsSiteFreqs(struct soap *soap, const char *tag, int id, const TrsSiteFreqs *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:TrsSiteFreq", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsSiteFreqs, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__TrsSiteFreq(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsSiteFreqs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsSiteFreqs(soap, tag, this, type);
}

SOAP_FMAC3 TrsSiteFreqs * SOAP_FMAC4 soap_in_TrsSiteFreqs(struct soap *soap, const char *tag, TrsSiteFreqs *a, const char *type)
{
	int i, j;
	ns1__TrsSiteFreq **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsSiteFreqs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsSiteFreqs, sizeof(TrsSiteFreqs), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__TrsSiteFreq **)soap_malloc(soap, sizeof(ns1__TrsSiteFreq *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__TrsSiteFreq(soap, NULL, a->__ptr + i, "ns1:TrsSiteFreq"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__TrsSiteFreq **)soap_push_block(soap, NULL, sizeof(ns1__TrsSiteFreq *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__TrsSiteFreq(soap, NULL, p, "ns1:TrsSiteFreq"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__TrsSiteFreq **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsSiteFreqs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsSiteFreqs, SOAP_TYPE_TrsSiteFreqs, sizeof(TrsSiteFreqs), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsSiteFreqs * SOAP_FMAC2 rrapi__instantiate_TrsSiteFreqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsSiteFreqs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsSiteFreqs *p;
	size_t k = sizeof(TrsSiteFreqs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsSiteFreqs, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsSiteFreqs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsSiteFreqs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsSiteFreqs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsSiteFreqs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsSiteFreqs(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsSiteFreqs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsSiteFreqs(soap, this, tag, type);
}

SOAP_FMAC3 TrsSiteFreqs * SOAP_FMAC4 soap_get_TrsSiteFreqs(struct soap *soap, TrsSiteFreqs *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsSiteFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TrsSiteFreq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TrsSiteFreq::lcn);
	soap_default_xsd__decimal(soap, &this->ns1__TrsSiteFreq::freq);
	soap_default_std__string(soap, &this->ns1__TrsSiteFreq::use);
	soap_default_std__string(soap, &this->ns1__TrsSiteFreq::colorCode);
	soap_default_std__string(soap, &this->ns1__TrsSiteFreq::ch_USCOREid);
}

void ns1__TrsSiteFreq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &this->ns1__TrsSiteFreq::freq);
	soap_serialize_std__string(soap, &this->ns1__TrsSiteFreq::use);
	soap_serialize_std__string(soap, &this->ns1__TrsSiteFreq::colorCode);
	soap_serialize_std__string(soap, &this->ns1__TrsSiteFreq::ch_USCOREid);
#endif
}

int ns1__TrsSiteFreq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TrsSiteFreq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrsSiteFreq(struct soap *soap, const char *tag, int id, const ns1__TrsSiteFreq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrsSiteFreq), type))
		return soap->error;
	if (soap_out_int(soap, "lcn", -1, &a->ns1__TrsSiteFreq::lcn, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "freq", -1, &a->ns1__TrsSiteFreq::freq, ""))
		return soap->error;
	if (soap_out_std__string(soap, "use", -1, &a->ns1__TrsSiteFreq::use, ""))
		return soap->error;
	if (soap_out_std__string(soap, "colorCode", -1, &a->ns1__TrsSiteFreq::colorCode, ""))
		return soap->error;
	if (soap_out_std__string(soap, "ch_id", -1, &a->ns1__TrsSiteFreq::ch_USCOREid, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TrsSiteFreq::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TrsSiteFreq(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TrsSiteFreq * SOAP_FMAC4 soap_in_ns1__TrsSiteFreq(struct soap *soap, const char *tag, ns1__TrsSiteFreq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TrsSiteFreq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrsSiteFreq, sizeof(ns1__TrsSiteFreq), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TrsSiteFreq)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TrsSiteFreq *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_lcn1 = 1;
	size_t soap_flag_freq1 = 1;
	size_t soap_flag_use1 = 1;
	size_t soap_flag_colorCode1 = 1;
	size_t soap_flag_ch_USCOREid1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lcn1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "lcn", &a->ns1__TrsSiteFreq::lcn, "xsd:int"))
				{	soap_flag_lcn1--;
					continue;
				}
			}
			if (soap_flag_freq1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "freq", &a->ns1__TrsSiteFreq::freq, "xsd:decimal"))
				{	soap_flag_freq1--;
					continue;
				}
			}
			if (soap_flag_use1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "use", &a->ns1__TrsSiteFreq::use, "xsd:string"))
				{	soap_flag_use1--;
					continue;
				}
			}
			if (soap_flag_colorCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "colorCode", &a->ns1__TrsSiteFreq::colorCode, "xsd:string"))
				{	soap_flag_colorCode1--;
					continue;
				}
			}
			if (soap_flag_ch_USCOREid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "ch_id", &a->ns1__TrsSiteFreq::ch_USCOREid, "xsd:string"))
				{	soap_flag_ch_USCOREid1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lcn1 > 0 || soap_flag_freq1 > 0 || soap_flag_use1 > 0 || soap_flag_colorCode1 > 0 || soap_flag_ch_USCOREid1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TrsSiteFreq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TrsSiteFreq, SOAP_TYPE_ns1__TrsSiteFreq, sizeof(ns1__TrsSiteFreq), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TrsSiteFreq * SOAP_FMAC2 rrapi__instantiate_ns1__TrsSiteFreq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__TrsSiteFreq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TrsSiteFreq *p;
	size_t k = sizeof(ns1__TrsSiteFreq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TrsSiteFreq, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TrsSiteFreq);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TrsSiteFreq, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TrsSiteFreq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TrsSiteFreq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TrsSiteFreq(soap, tag ? tag : "ns1:TrsSiteFreq", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TrsSiteFreq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TrsSiteFreq(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TrsSiteFreq * SOAP_FMAC4 soap_get_ns1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrsSiteFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TrsSites::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TrsSites::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TrsSites))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__TrsSite(soap, this->__ptr + i);
		}
	}
#endif
}

int TrsSites::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TrsSites(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TrsSites(struct soap *soap, const char *tag, int id, const TrsSites *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:TrsSite", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TrsSites, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__TrsSite(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TrsSites::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TrsSites(soap, tag, this, type);
}

SOAP_FMAC3 TrsSites * SOAP_FMAC4 soap_in_TrsSites(struct soap *soap, const char *tag, TrsSites *a, const char *type)
{
	int i, j;
	ns1__TrsSite **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TrsSites*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TrsSites, sizeof(TrsSites), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__TrsSite **)soap_malloc(soap, sizeof(ns1__TrsSite *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__TrsSite(soap, NULL, a->__ptr + i, "ns1:TrsSite"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__TrsSite **)soap_push_block(soap, NULL, sizeof(ns1__TrsSite *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__TrsSite(soap, NULL, p, "ns1:TrsSite"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__TrsSite **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TrsSites *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TrsSites, SOAP_TYPE_TrsSites, sizeof(TrsSites), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TrsSites * SOAP_FMAC2 rrapi__instantiate_TrsSites(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TrsSites(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TrsSites *p;
	size_t k = sizeof(TrsSites);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TrsSites, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TrsSites);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TrsSites, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TrsSites location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TrsSites::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TrsSites(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TrsSites::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TrsSites(soap, this, tag, type);
}

SOAP_FMAC3 TrsSites * SOAP_FMAC4 soap_get_TrsSites(struct soap *soap, TrsSites *p, const char *tag, const char *type)
{
	if ((p = soap_in_TrsSites(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TrsSite::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TrsSite::siteId);
	soap_default_int(soap, &this->ns1__TrsSite::sid);
	soap_default_int(soap, &this->ns1__TrsSite::siteNumber);
	soap_default_std__string(soap, &this->ns1__TrsSite::siteDescr);
	soap_default_int(soap, &this->ns1__TrsSite::zoneNumber);
	soap_default_std__string(soap, &this->ns1__TrsSite::zoneDescr);
	soap_default_int(soap, &this->ns1__TrsSite::rfss);
	soap_default_std__string(soap, &this->ns1__TrsSite::nac);
	soap_default_int(soap, &this->ns1__TrsSite::ran);
	soap_default_std__string(soap, &this->ns1__TrsSite::siteNeighbors);
	soap_default_std__string(soap, &this->ns1__TrsSite::siteLocation);
	soap_default_int(soap, &this->ns1__TrsSite::siteCtid);
	soap_default_std__string(soap, &this->ns1__TrsSite::siteCt);
	soap_default_std__string(soap, &this->ns1__TrsSite::siteModulation);
	soap_default_std__string(soap, &this->ns1__TrsSite::siteNotes);
	soap_default_xsd__decimal(soap, &this->ns1__TrsSite::lat);
	soap_default_xsd__decimal(soap, &this->ns1__TrsSite::lon);
	soap_default_xsd__decimal(soap, &this->ns1__TrsSite::range);
	soap_default_int(soap, &this->ns1__TrsSite::splinter);
	soap_default_int(soap, &this->ns1__TrsSite::rebanded);
	this->ns1__TrsSite::siteLicenses = NULL;
	this->ns1__TrsSite::siteFreqs = NULL;
	this->ns1__TrsSite::bandplan = NULL;
}

void ns1__TrsSite::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__TrsSite::siteDescr);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::zoneDescr);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::nac);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::siteNeighbors);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::siteLocation);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::siteCt);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::siteModulation);
	soap_serialize_std__string(soap, &this->ns1__TrsSite::siteNotes);
	soap_serialize_xsd__decimal(soap, &this->ns1__TrsSite::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__TrsSite::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__TrsSite::range);
	soap_serialize_PointerToTrsSiteLicenses(soap, &this->ns1__TrsSite::siteLicenses);
	soap_serialize_PointerToTrsSiteFreqs(soap, &this->ns1__TrsSite::siteFreqs);
	soap_serialize_PointerToTrsBandplan(soap, &this->ns1__TrsSite::bandplan);
#endif
}

int ns1__TrsSite::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TrsSite(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TrsSite(struct soap *soap, const char *tag, int id, const ns1__TrsSite *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TrsSite), type))
		return soap->error;
	if (soap_out_int(soap, "siteId", -1, &a->ns1__TrsSite::siteId, ""))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->ns1__TrsSite::sid, ""))
		return soap->error;
	if (soap_out_int(soap, "siteNumber", -1, &a->ns1__TrsSite::siteNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "siteDescr", -1, &a->ns1__TrsSite::siteDescr, ""))
		return soap->error;
	if (soap_out_int(soap, "zoneNumber", -1, &a->ns1__TrsSite::zoneNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "zoneDescr", -1, &a->ns1__TrsSite::zoneDescr, ""))
		return soap->error;
	if (soap_out_int(soap, "rfss", -1, &a->ns1__TrsSite::rfss, ""))
		return soap->error;
	if (soap_out_std__string(soap, "nac", -1, &a->ns1__TrsSite::nac, ""))
		return soap->error;
	if (soap_out_int(soap, "ran", -1, &a->ns1__TrsSite::ran, ""))
		return soap->error;
	if (soap_out_std__string(soap, "siteNeighbors", -1, &a->ns1__TrsSite::siteNeighbors, ""))
		return soap->error;
	if (soap_out_std__string(soap, "siteLocation", -1, &a->ns1__TrsSite::siteLocation, ""))
		return soap->error;
	if (soap_out_int(soap, "siteCtid", -1, &a->ns1__TrsSite::siteCtid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "siteCt", -1, &a->ns1__TrsSite::siteCt, ""))
		return soap->error;
	if (soap_out_std__string(soap, "siteModulation", -1, &a->ns1__TrsSite::siteModulation, ""))
		return soap->error;
	if (soap_out_std__string(soap, "siteNotes", -1, &a->ns1__TrsSite::siteNotes, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__TrsSite::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__TrsSite::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->ns1__TrsSite::range, ""))
		return soap->error;
	if (soap_out_int(soap, "splinter", -1, &a->ns1__TrsSite::splinter, ""))
		return soap->error;
	if (soap_out_int(soap, "rebanded", -1, &a->ns1__TrsSite::rebanded, ""))
		return soap->error;
	if (!a->ns1__TrsSite::siteLicenses)
	{	if (soap_element_empty(soap, "siteLicenses", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsSiteLicenses(soap, "siteLicenses", -1, &a->ns1__TrsSite::siteLicenses, ""))
		return soap->error;
	if (!a->ns1__TrsSite::siteFreqs)
	{	if (soap_element_empty(soap, "siteFreqs", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsSiteFreqs(soap, "siteFeqs", -1, &a->ns1__TrsSite::siteFreqs, ""))
		return soap->error;
	if (!a->ns1__TrsSite::bandplan)
	{	if (soap_element_empty(soap, "bandplan", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerToTrsBandplan(soap, "bandplan", -1, &a->ns1__TrsSite::bandplan, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TrsSite::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TrsSite(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TrsSite * SOAP_FMAC4 soap_in_ns1__TrsSite(struct soap *soap, const char *tag, ns1__TrsSite *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TrsSite*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TrsSite, sizeof(ns1__TrsSite), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TrsSite)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TrsSite *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_siteId1 = 1;
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_siteNumber1 = 1;
	size_t soap_flag_siteDescr1 = 1;
	size_t soap_flag_zoneNumber1 = 1;
	size_t soap_flag_zoneDescr1 = 1;
	size_t soap_flag_rfss1 = 1;
	size_t soap_flag_nac1 = 1;
	size_t soap_flag_ran1 = 1;
	size_t soap_flag_siteNeighbors1 = 1;
	size_t soap_flag_siteLocation1 = 1;
	size_t soap_flag_siteCtid1 = 1;
	size_t soap_flag_siteCt1 = 1;
	size_t soap_flag_siteModulation1 = 1;
	size_t soap_flag_siteNotes1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_range1 = 1;
	size_t soap_flag_splinter1 = 1;
	size_t soap_flag_rebanded1 = 1;
	size_t soap_flag_siteLicenses1 = 1;
	size_t soap_flag_siteFreqs1 = 1;
	size_t soap_flag_bandplan1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_siteId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "siteId", &a->ns1__TrsSite::siteId, "xsd:int"))
				{	soap_flag_siteId1--;
					continue;
				}
			}
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->ns1__TrsSite::sid, "xsd:int"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_siteNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "siteNumber", &a->ns1__TrsSite::siteNumber, "xsd:int"))
				{	soap_flag_siteNumber1--;
					continue;
				}
			}
			if (soap_flag_siteDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "siteDescr", &a->ns1__TrsSite::siteDescr, "xsd:string"))
				{	soap_flag_siteDescr1--;
					continue;
				}
			}
			if (soap_flag_zoneNumber1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "zoneNumber", &a->ns1__TrsSite::zoneNumber, "xsd:int"))
				{	soap_flag_zoneNumber1--;
					continue;
				}
			}
			if (soap_flag_zoneDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "zoneDescr", &a->ns1__TrsSite::zoneDescr, "xsd:string"))
				{	soap_flag_zoneDescr1--;
					continue;
				}
			}
			if (soap_flag_rfss1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "rfss", &a->ns1__TrsSite::rfss, "xsd:int"))
				{	soap_flag_rfss1--;
					continue;
				}
			}
			if (soap_flag_nac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "nac", &a->ns1__TrsSite::nac, "xsd:string"))
				{	soap_flag_nac1--;
					continue;
				}
			}
			if (soap_flag_ran1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ran", &a->ns1__TrsSite::ran, "xsd:int"))
				{	soap_flag_ran1--;
					continue;
				}
			}
			if (soap_flag_siteNeighbors1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "siteNeighbors", &a->ns1__TrsSite::siteNeighbors, "xsd:string"))
				{	soap_flag_siteNeighbors1--;
					continue;
				}
			}
			if (soap_flag_siteLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "siteLocation", &a->ns1__TrsSite::siteLocation, "xsd:string"))
				{	soap_flag_siteLocation1--;
					continue;
				}
			}
			if (soap_flag_siteCtid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "siteCtid", &a->ns1__TrsSite::siteCtid, "xsd:int"))
				{	soap_flag_siteCtid1--;
					continue;
				}
			}
			if (soap_flag_siteCt1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "siteCt", &a->ns1__TrsSite::siteCt, "xsd:string"))
				{	soap_flag_siteCt1--;
					continue;
				}
			}
			if (soap_flag_siteModulation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "siteModulation", &a->ns1__TrsSite::siteModulation, "xsd:string"))
				{	soap_flag_siteModulation1--;
					continue;
				}
			}
			if (soap_flag_siteNotes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "siteNotes", &a->ns1__TrsSite::siteNotes, "xsd:string"))
				{	soap_flag_siteNotes1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__TrsSite::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__TrsSite::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_range1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->ns1__TrsSite::range, "xsd:decimal"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap_flag_splinter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "splinter", &a->ns1__TrsSite::splinter, "xsd:int"))
				{	soap_flag_splinter1--;
					continue;
				}
			}
			if (soap_flag_rebanded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "rebanded", &a->ns1__TrsSite::rebanded, "xsd:int"))
				{	soap_flag_rebanded1--;
					continue;
				}
			}
			if (soap_flag_siteLicenses1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsSiteLicenses(soap, "siteLicenses", &a->ns1__TrsSite::siteLicenses, "ns1:TrsSiteLicense"))
				{	soap_flag_siteLicenses1--;
					continue;
				}
			}
			if (soap_flag_siteFreqs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsSiteFreqs(soap, "siteFeqs", &a->ns1__TrsSite::siteFreqs, "ns1:TrsSiteFreq"))
				{	soap_flag_siteFreqs1--;
					continue;
				}
			}
			if (soap_flag_bandplan1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsBandplan(soap, "bandplan", &a->ns1__TrsSite::bandplan, "ns1:trsBandplanDef"))
				{	soap_flag_bandplan1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_siteId1 > 0 || soap_flag_sid1 > 0 || soap_flag_siteNumber1 > 0 || soap_flag_siteDescr1 > 0 || soap_flag_zoneNumber1 > 0 || soap_flag_zoneDescr1 > 0 || soap_flag_rfss1 > 0 || soap_flag_nac1 > 0 || soap_flag_ran1 > 0 || soap_flag_siteNeighbors1 > 0 || soap_flag_siteLocation1 > 0 || soap_flag_siteCtid1 > 0 || soap_flag_siteCt1 > 0 || soap_flag_siteModulation1 > 0 || soap_flag_siteNotes1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_range1 > 0 || soap_flag_splinter1 > 0 || soap_flag_rebanded1 > 0 || !a->ns1__TrsSite::siteLicenses || !a->ns1__TrsSite::siteFreqs || !a->ns1__TrsSite::bandplan))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TrsSite *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TrsSite, SOAP_TYPE_ns1__TrsSite, sizeof(ns1__TrsSite), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TrsSite * SOAP_FMAC2 rrapi__instantiate_ns1__TrsSite(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__TrsSite(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TrsSite *p;
	size_t k = sizeof(ns1__TrsSite);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TrsSite, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TrsSite);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TrsSite, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TrsSite location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TrsSite::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TrsSite(soap, tag ? tag : "ns1:TrsSite", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TrsSite::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TrsSite(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TrsSite * SOAP_FMAC4 soap_get_ns1__TrsSite(struct soap *soap, ns1__TrsSite *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TrsSite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void TalkgroupCats::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void TalkgroupCats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_TalkgroupCats))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__TalkgroupCat(soap, this->__ptr + i);
		}
	}
#endif
}

int TalkgroupCats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_TalkgroupCats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_TalkgroupCats(struct soap *soap, const char *tag, int id, const TalkgroupCats *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:TalkgroupCat", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_TalkgroupCats, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__TalkgroupCat(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *TalkgroupCats::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_TalkgroupCats(soap, tag, this, type);
}

SOAP_FMAC3 TalkgroupCats * SOAP_FMAC4 soap_in_TalkgroupCats(struct soap *soap, const char *tag, TalkgroupCats *a, const char *type)
{
	int i, j;
	ns1__TalkgroupCat **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (TalkgroupCats*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_TalkgroupCats, sizeof(TalkgroupCats), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__TalkgroupCat **)soap_malloc(soap, sizeof(ns1__TalkgroupCat *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__TalkgroupCat(soap, NULL, a->__ptr + i, "ns1:TalkgroupCat"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__TalkgroupCat **)soap_push_block(soap, NULL, sizeof(ns1__TalkgroupCat *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__TalkgroupCat(soap, NULL, p, "ns1:TalkgroupCat"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__TalkgroupCat **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (TalkgroupCats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_TalkgroupCats, SOAP_TYPE_TalkgroupCats, sizeof(TalkgroupCats), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 TalkgroupCats * SOAP_FMAC2 rrapi__instantiate_TalkgroupCats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_TalkgroupCats(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	TalkgroupCats *p;
	size_t k = sizeof(TalkgroupCats);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_TalkgroupCats, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, TalkgroupCats);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, TalkgroupCats, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated TalkgroupCats location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int TalkgroupCats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_TalkgroupCats(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *TalkgroupCats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_TalkgroupCats(soap, this, tag, type);
}

SOAP_FMAC3 TalkgroupCats * SOAP_FMAC4 soap_get_TalkgroupCats(struct soap *soap, TalkgroupCats *p, const char *tag, const char *type)
{
	if ((p = soap_in_TalkgroupCats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__TalkgroupCat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TalkgroupCat::tgCid);
	soap_default_int(soap, &this->ns1__TalkgroupCat::sid);
	soap_default_std__string(soap, &this->ns1__TalkgroupCat::tgCname);
	soap_default_int(soap, &this->ns1__TalkgroupCat::tgSort);
	soap_default_int(soap, &this->ns1__TalkgroupCat::tgSortBy);
	soap_default_xsd__decimal(soap, &this->ns1__TalkgroupCat::lat);
	soap_default_xsd__decimal(soap, &this->ns1__TalkgroupCat::lon);
	soap_default_xsd__decimal(soap, &this->ns1__TalkgroupCat::range);
	soap_default_dateTime(soap, &this->ns1__TalkgroupCat::lastUpdated);
}

void ns1__TalkgroupCat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__TalkgroupCat::tgCname);
	soap_serialize_xsd__decimal(soap, &this->ns1__TalkgroupCat::lat);
	soap_serialize_xsd__decimal(soap, &this->ns1__TalkgroupCat::lon);
	soap_serialize_xsd__decimal(soap, &this->ns1__TalkgroupCat::range);
#endif
}

int ns1__TalkgroupCat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TalkgroupCat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TalkgroupCat(struct soap *soap, const char *tag, int id, const ns1__TalkgroupCat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TalkgroupCat), type))
		return soap->error;
	if (soap_out_int(soap, "tgCid", -1, &a->ns1__TalkgroupCat::tgCid, ""))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->ns1__TalkgroupCat::sid, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tgCname", -1, &a->ns1__TalkgroupCat::tgCname, ""))
		return soap->error;
	if (soap_out_int(soap, "tgSort", -1, &a->ns1__TalkgroupCat::tgSort, ""))
		return soap->error;
	if (soap_out_int(soap, "tgSortBy", -1, &a->ns1__TalkgroupCat::tgSortBy, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->ns1__TalkgroupCat::lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->ns1__TalkgroupCat::lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->ns1__TalkgroupCat::range, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "lastUpdated", -1, &a->ns1__TalkgroupCat::lastUpdated, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__TalkgroupCat::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__TalkgroupCat(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TalkgroupCat * SOAP_FMAC4 soap_in_ns1__TalkgroupCat(struct soap *soap, const char *tag, ns1__TalkgroupCat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TalkgroupCat*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TalkgroupCat, sizeof(ns1__TalkgroupCat), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__TalkgroupCat)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__TalkgroupCat *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tgCid1 = 1;
	size_t soap_flag_sid1 = 1;
	size_t soap_flag_tgCname1 = 1;
	size_t soap_flag_tgSort1 = 1;
	size_t soap_flag_tgSortBy1 = 1;
	size_t soap_flag_lat1 = 1;
	size_t soap_flag_lon1 = 1;
	size_t soap_flag_range1 = 1;
	size_t soap_flag_lastUpdated1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tgCid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgCid", &a->ns1__TalkgroupCat::tgCid, "xsd:int"))
				{	soap_flag_tgCid1--;
					continue;
				}
			}
			if (soap_flag_sid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->ns1__TalkgroupCat::sid, "xsd:int"))
				{	soap_flag_sid1--;
					continue;
				}
			}
			if (soap_flag_tgCname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tgCname", &a->ns1__TalkgroupCat::tgCname, "xsd:string"))
				{	soap_flag_tgCname1--;
					continue;
				}
			}
			if (soap_flag_tgSort1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgSort", &a->ns1__TalkgroupCat::tgSort, "xsd:int"))
				{	soap_flag_tgSort1--;
					continue;
				}
			}
			if (soap_flag_tgSortBy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgSortBy", &a->ns1__TalkgroupCat::tgSortBy, "xsd:int"))
				{	soap_flag_tgSortBy1--;
					continue;
				}
			}
			if (soap_flag_lat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->ns1__TalkgroupCat::lat, "xsd:decimal"))
				{	soap_flag_lat1--;
					continue;
				}
			}
			if (soap_flag_lon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->ns1__TalkgroupCat::lon, "xsd:decimal"))
				{	soap_flag_lon1--;
					continue;
				}
			}
			if (soap_flag_range1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->ns1__TalkgroupCat::range, "xsd:decimal"))
				{	soap_flag_range1--;
					continue;
				}
			}
			if (soap_flag_lastUpdated1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "lastUpdated", &a->ns1__TalkgroupCat::lastUpdated, "xsd:dateTime"))
				{	soap_flag_lastUpdated1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tgCid1 > 0 || soap_flag_sid1 > 0 || soap_flag_tgCname1 > 0 || soap_flag_tgSort1 > 0 || soap_flag_tgSortBy1 > 0 || soap_flag_lat1 > 0 || soap_flag_lon1 > 0 || soap_flag_range1 > 0 || soap_flag_lastUpdated1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__TalkgroupCat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TalkgroupCat, SOAP_TYPE_ns1__TalkgroupCat, sizeof(ns1__TalkgroupCat), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__TalkgroupCat * SOAP_FMAC2 rrapi__instantiate_ns1__TalkgroupCat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__TalkgroupCat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__TalkgroupCat *p;
	size_t k = sizeof(ns1__TalkgroupCat);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__TalkgroupCat, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__TalkgroupCat);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__TalkgroupCat, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__TalkgroupCat location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__TalkgroupCat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__TalkgroupCat(soap, tag ? tag : "ns1:TalkgroupCat", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TalkgroupCat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TalkgroupCat(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TalkgroupCat * SOAP_FMAC4 soap_get_ns1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TalkgroupCat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void Talkgroups::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void Talkgroups::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_Talkgroups))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__Talkgroup(soap, this->__ptr + i);
		}
	}
#endif
}

int Talkgroups::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Talkgroups(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Talkgroups(struct soap *soap, const char *tag, int id, const Talkgroups *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:Talkgroup", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_Talkgroups, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__Talkgroup(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *Talkgroups::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_Talkgroups(soap, tag, this, type);
}

SOAP_FMAC3 Talkgroups * SOAP_FMAC4 soap_in_Talkgroups(struct soap *soap, const char *tag, Talkgroups *a, const char *type)
{
	int i, j;
	ns1__Talkgroup **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (Talkgroups*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Talkgroups, sizeof(Talkgroups), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__Talkgroup **)soap_malloc(soap, sizeof(ns1__Talkgroup *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__Talkgroup(soap, NULL, a->__ptr + i, "ns1:Talkgroup"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__Talkgroup **)soap_push_block(soap, NULL, sizeof(ns1__Talkgroup *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__Talkgroup(soap, NULL, p, "ns1:Talkgroup"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__Talkgroup **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Talkgroups *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Talkgroups, SOAP_TYPE_Talkgroups, sizeof(Talkgroups), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 Talkgroups * SOAP_FMAC2 rrapi__instantiate_Talkgroups(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_Talkgroups(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	Talkgroups *p;
	size_t k = sizeof(Talkgroups);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_Talkgroups, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, Talkgroups);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, Talkgroups, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated Talkgroups location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int Talkgroups::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_Talkgroups(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Talkgroups::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Talkgroups(soap, this, tag, type);
}

SOAP_FMAC3 Talkgroups * SOAP_FMAC4 soap_get_Talkgroups(struct soap *soap, Talkgroups *p, const char *tag, const char *type)
{
	if ((p = soap_in_Talkgroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Talkgroup::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__Talkgroup::tgId);
	soap_default_int(soap, &this->ns1__Talkgroup::tgDec);
	soap_default_std__string(soap, &this->ns1__Talkgroup::tgSubfleet);
	soap_default_bool(soap, &this->ns1__Talkgroup::tgLtr);
	soap_default_std__string(soap, &this->ns1__Talkgroup::tgSlot);
	soap_default_std__string(soap, &this->ns1__Talkgroup::tgDescr);
	soap_default_std__string(soap, &this->ns1__Talkgroup::tgAlpha);
	soap_default_std__string(soap, &this->ns1__Talkgroup::tgMode);
	soap_default_int(soap, &this->ns1__Talkgroup::enc);
	this->ns1__Talkgroup::tags_ = NULL;
	soap_default_int(soap, &this->ns1__Talkgroup::tgCid);
	soap_default_int(soap, &this->ns1__Talkgroup::tgSort);
	soap_default_dateTime(soap, &this->ns1__Talkgroup::tgDate);
}

void ns1__Talkgroup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__Talkgroup::tgSubfleet);
	soap_serialize_std__string(soap, &this->ns1__Talkgroup::tgSlot);
	soap_serialize_std__string(soap, &this->ns1__Talkgroup::tgDescr);
	soap_serialize_std__string(soap, &this->ns1__Talkgroup::tgAlpha);
	soap_serialize_std__string(soap, &this->ns1__Talkgroup::tgMode);
	soap_serialize_PointerTotags(soap, &this->ns1__Talkgroup::tags_);
#endif
}

int ns1__Talkgroup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Talkgroup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Talkgroup(struct soap *soap, const char *tag, int id, const ns1__Talkgroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Talkgroup), type))
		return soap->error;
	if (soap_out_int(soap, "tgId", -1, &a->ns1__Talkgroup::tgId, ""))
		return soap->error;
	if (soap_out_int(soap, "tgDec", -1, &a->ns1__Talkgroup::tgDec, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tgSubfleet", -1, &a->ns1__Talkgroup::tgSubfleet, ""))
		return soap->error;
	if (soap_out_bool(soap, "tgLtr", -1, &a->ns1__Talkgroup::tgLtr, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tgSlot", -1, &a->ns1__Talkgroup::tgSlot, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tgDescr", -1, &a->ns1__Talkgroup::tgDescr, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tgAlpha", -1, &a->ns1__Talkgroup::tgAlpha, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tgMode", -1, &a->ns1__Talkgroup::tgMode, ""))
		return soap->error;
	if (soap_out_int(soap, "enc", -1, &a->ns1__Talkgroup::enc, ""))
		return soap->error;
	if (!a->ns1__Talkgroup::tags_)
	{	if (soap_element_empty(soap, "tags", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotags(soap, "tags", -1, &a->ns1__Talkgroup::tags_, ""))
		return soap->error;
	if (soap_out_int(soap, "tgCid", -1, &a->ns1__Talkgroup::tgCid, ""))
		return soap->error;
	if (soap_out_int(soap, "tgSort", -1, &a->ns1__Talkgroup::tgSort, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tgDate", -1, &a->ns1__Talkgroup::tgDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Talkgroup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__Talkgroup(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Talkgroup * SOAP_FMAC4 soap_in_ns1__Talkgroup(struct soap *soap, const char *tag, ns1__Talkgroup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Talkgroup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Talkgroup, sizeof(ns1__Talkgroup), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Talkgroup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Talkgroup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_tgId1 = 1;
	size_t soap_flag_tgDec1 = 1;
	size_t soap_flag_tgSubfleet1 = 1;
	size_t soap_flag_tgLtr1 = 1;
	size_t soap_flag_tgSlot1 = 1;
	size_t soap_flag_tgDescr1 = 1;
	size_t soap_flag_tgAlpha1 = 1;
	size_t soap_flag_tgMode1 = 1;
	size_t soap_flag_enc1 = 1;
	size_t soap_flag_tags_1 = 1;
	size_t soap_flag_tgCid1 = 1;
	size_t soap_flag_tgSort1 = 1;
	size_t soap_flag_tgDate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tgId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgId", &a->ns1__Talkgroup::tgId, "xsd:int"))
				{	soap_flag_tgId1--;
					continue;
				}
			}
			if (soap_flag_tgDec1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgDec", &a->ns1__Talkgroup::tgDec, "xsd:int"))
				{	soap_flag_tgDec1--;
					continue;
				}
			}
			if (soap_flag_tgSubfleet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tgSubfleet", &a->ns1__Talkgroup::tgSubfleet, "xsd:string"))
				{	soap_flag_tgSubfleet1--;
					continue;
				}
			}
			if (soap_flag_tgLtr1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tgLtr", &a->ns1__Talkgroup::tgLtr, "xsd:boolean"))
				{	soap_flag_tgLtr1--;
					continue;
				}
			}
			if (soap_flag_tgSlot1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tgSlot", &a->ns1__Talkgroup::tgSlot, "xsd:string"))
				{	soap_flag_tgSlot1--;
					continue;
				}
			}
			if (soap_flag_tgDescr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tgDescr", &a->ns1__Talkgroup::tgDescr, "xsd:string"))
				{	soap_flag_tgDescr1--;
					continue;
				}
			}
			if (soap_flag_tgAlpha1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tgAlpha", &a->ns1__Talkgroup::tgAlpha, "xsd:string"))
				{	soap_flag_tgAlpha1--;
					continue;
				}
			}
			if (soap_flag_tgMode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tgMode", &a->ns1__Talkgroup::tgMode, "xsd:string"))
				{	soap_flag_tgMode1--;
					continue;
				}
			}
			if (soap_flag_enc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "enc", &a->ns1__Talkgroup::enc, "xsd:int"))
				{	soap_flag_enc1--;
					continue;
				}
			}
			if (soap_flag_tags_1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotags(soap, "tags", &a->ns1__Talkgroup::tags_, "ns1:tag"))
				{	soap_flag_tags_1--;
					continue;
				}
			}
			if (soap_flag_tgCid1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgCid", &a->ns1__Talkgroup::tgCid, "xsd:int"))
				{	soap_flag_tgCid1--;
					continue;
				}
			}
			if (soap_flag_tgSort1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgSort", &a->ns1__Talkgroup::tgSort, "xsd:int"))
				{	soap_flag_tgSort1--;
					continue;
				}
			}
			if (soap_flag_tgDate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tgDate", &a->ns1__Talkgroup::tgDate, "xsd:dateTime"))
				{	soap_flag_tgDate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tgId1 > 0 || soap_flag_tgDec1 > 0 || soap_flag_tgSubfleet1 > 0 || soap_flag_tgLtr1 > 0 || soap_flag_tgSlot1 > 0 || soap_flag_tgDescr1 > 0 || soap_flag_tgAlpha1 > 0 || soap_flag_tgMode1 > 0 || soap_flag_enc1 > 0 || !a->ns1__Talkgroup::tags_ || soap_flag_tgCid1 > 0 || soap_flag_tgSort1 > 0 || soap_flag_tgDate1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Talkgroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Talkgroup, SOAP_TYPE_ns1__Talkgroup, sizeof(ns1__Talkgroup), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Talkgroup * SOAP_FMAC2 rrapi__instantiate_ns1__Talkgroup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__Talkgroup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Talkgroup *p;
	size_t k = sizeof(ns1__Talkgroup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__Talkgroup, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__Talkgroup);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__Talkgroup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Talkgroup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__Talkgroup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Talkgroup(soap, tag ? tag : "ns1:Talkgroup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Talkgroup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Talkgroup(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Talkgroup * SOAP_FMAC4 soap_get_ns1__Talkgroup(struct soap *soap, ns1__Talkgroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Talkgroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ctidList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void ctidList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_ctidList))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__ctid(soap, this->__ptr + i);
		}
	}
#endif
}

int ctidList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ctidList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ctidList(struct soap *soap, const char *tag, int id, const ctidList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:ctid", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_ctidList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__ctid(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ctidList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ctidList(soap, tag, this, type);
}

SOAP_FMAC3 ctidList * SOAP_FMAC4 soap_in_ctidList(struct soap *soap, const char *tag, ctidList *a, const char *type)
{
	int i, j;
	ns1__ctid **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ctidList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ctidList, sizeof(ctidList), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__ctid **)soap_malloc(soap, sizeof(ns1__ctid *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ctid(soap, NULL, a->__ptr + i, "ns1:ctid"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ctid **)soap_push_block(soap, NULL, sizeof(ns1__ctid *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__ctid(soap, NULL, p, "ns1:ctid"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__ctid **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ctidList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ctidList, SOAP_TYPE_ctidList, sizeof(ctidList), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ctidList * SOAP_FMAC2 rrapi__instantiate_ctidList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ctidList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ctidList *p;
	size_t k = sizeof(ctidList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ctidList, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ctidList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ctidList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ctidList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ctidList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ctidList(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ctidList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ctidList(soap, this, tag, type);
}

SOAP_FMAC3 ctidList * SOAP_FMAC4 soap_get_ctidList(struct soap *soap, ctidList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ctidList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void stidList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void stidList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_stidList))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__stid(soap, this->__ptr + i);
		}
	}
#endif
}

int stidList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_stidList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_stidList(struct soap *soap, const char *tag, int id, const stidList *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:stid", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_stidList, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__stid(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *stidList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_stidList(soap, tag, this, type);
}

SOAP_FMAC3 stidList * SOAP_FMAC4 soap_in_stidList(struct soap *soap, const char *tag, stidList *a, const char *type)
{
	int i, j;
	ns1__stid **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (stidList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_stidList, sizeof(stidList), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__stid **)soap_malloc(soap, sizeof(ns1__stid *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__stid(soap, NULL, a->__ptr + i, "ns1:stid"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__stid **)soap_push_block(soap, NULL, sizeof(ns1__stid *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__stid(soap, NULL, p, "ns1:stid"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__stid **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (stidList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_stidList, SOAP_TYPE_stidList, sizeof(stidList), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 stidList * SOAP_FMAC2 rrapi__instantiate_stidList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_stidList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	stidList *p;
	size_t k = sizeof(stidList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_stidList, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, stidList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, stidList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated stidList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int stidList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_stidList(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *stidList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_stidList(soap, this, tag, type);
}

SOAP_FMAC3 stidList * SOAP_FMAC4 soap_get_stidList(struct soap *soap, stidList *p, const char *tag, const char *type)
{
	if ((p = soap_in_stidList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void userFeedBroadcasts::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__ptr = NULL;
	this->__size = 0;
}

void userFeedBroadcasts::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_userFeedBroadcasts))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
			soap_serialize_PointerTons1__userFeedBroadcast(soap, this->__ptr + i);
		}
	}
#endif
}

int userFeedBroadcasts::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_userFeedBroadcasts(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_userFeedBroadcasts(struct soap *soap, const char *tag, int id, const userFeedBroadcasts *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsizesoffsets(soap, "ns1:userFeedBroadcast", &a->__size, NULL, 1) : NULL;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_userFeedBroadcasts, NULL);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		if (soap_out_PointerTons1__userFeedBroadcast(soap, "item", -1, &a->__ptr[i], ""))
			return soap->error;
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *userFeedBroadcasts::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_userFeedBroadcasts(soap, tag, this, type);
}

SOAP_FMAC3 userFeedBroadcasts * SOAP_FMAC4 soap_in_userFeedBroadcasts(struct soap *soap, const char *tag, userFeedBroadcasts *a, const char *type)
{
	int i, j;
	ns1__userFeedBroadcast **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (userFeedBroadcasts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_userFeedBroadcasts, sizeof(userFeedBroadcasts), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (ns1__userFeedBroadcast **)soap_malloc(soap, sizeof(ns1__userFeedBroadcast *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__userFeedBroadcast(soap, NULL, a->__ptr + i, "ns1:userFeedBroadcast"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__userFeedBroadcast **)soap_push_block(soap, NULL, sizeof(ns1__userFeedBroadcast *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_in_PointerTons1__userFeedBroadcast(soap, NULL, p, "ns1:userFeedBroadcast"))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (ns1__userFeedBroadcast **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (userFeedBroadcasts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_userFeedBroadcasts, SOAP_TYPE_userFeedBroadcasts, sizeof(userFeedBroadcasts), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 userFeedBroadcasts * SOAP_FMAC2 rrapi__instantiate_userFeedBroadcasts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_userFeedBroadcasts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	userFeedBroadcasts *p;
	size_t k = sizeof(userFeedBroadcasts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_userFeedBroadcasts, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, userFeedBroadcasts);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, userFeedBroadcasts, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated userFeedBroadcasts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int userFeedBroadcasts::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_userFeedBroadcasts(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *userFeedBroadcasts::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_userFeedBroadcasts(soap, this, tag, type);
}

SOAP_FMAC3 userFeedBroadcasts * SOAP_FMAC4 soap_get_userFeedBroadcasts(struct soap *soap, userFeedBroadcasts *p, const char *tag, const char *type)
{
	if ((p = soap_in_userFeedBroadcasts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__userFeedBroadcast::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__userFeedBroadcast::feedId);
	soap_default_std__string(soap, &this->ns1__userFeedBroadcast::descr);
	soap_default_std__string(soap, &this->ns1__userFeedBroadcast::hostname);
	soap_default_std__string(soap, &this->ns1__userFeedBroadcast::port);
	soap_default_std__string(soap, &this->ns1__userFeedBroadcast::mount);
	soap_default_std__string(soap, &this->ns1__userFeedBroadcast::password);
}

void ns1__userFeedBroadcast::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__userFeedBroadcast::descr);
	soap_serialize_std__string(soap, &this->ns1__userFeedBroadcast::hostname);
	soap_serialize_std__string(soap, &this->ns1__userFeedBroadcast::port);
	soap_serialize_std__string(soap, &this->ns1__userFeedBroadcast::mount);
	soap_serialize_std__string(soap, &this->ns1__userFeedBroadcast::password);
#endif
}

int ns1__userFeedBroadcast::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__userFeedBroadcast(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__userFeedBroadcast(struct soap *soap, const char *tag, int id, const ns1__userFeedBroadcast *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__userFeedBroadcast), type))
		return soap->error;
	if (soap_out_int(soap, "feedId", -1, &a->ns1__userFeedBroadcast::feedId, ""))
		return soap->error;
	if (soap_out_std__string(soap, "descr", -1, &a->ns1__userFeedBroadcast::descr, ""))
		return soap->error;
	if (soap_out_std__string(soap, "hostname", -1, &a->ns1__userFeedBroadcast::hostname, ""))
		return soap->error;
	if (soap_out_std__string(soap, "port", -1, &a->ns1__userFeedBroadcast::port, ""))
		return soap->error;
	if (soap_out_std__string(soap, "mount", -1, &a->ns1__userFeedBroadcast::mount, ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &a->ns1__userFeedBroadcast::password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__userFeedBroadcast::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__userFeedBroadcast(soap, tag, this, type);
}

SOAP_FMAC3 ns1__userFeedBroadcast * SOAP_FMAC4 soap_in_ns1__userFeedBroadcast(struct soap *soap, const char *tag, ns1__userFeedBroadcast *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__userFeedBroadcast*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__userFeedBroadcast, sizeof(ns1__userFeedBroadcast), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__userFeedBroadcast)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__userFeedBroadcast *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_feedId1 = 1;
	size_t soap_flag_descr1 = 1;
	size_t soap_flag_hostname1 = 1;
	size_t soap_flag_port1 = 1;
	size_t soap_flag_mount1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_feedId1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "feedId", &a->ns1__userFeedBroadcast::feedId, "xsd:int"))
				{	soap_flag_feedId1--;
					continue;
				}
			}
			if (soap_flag_descr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "descr", &a->ns1__userFeedBroadcast::descr, "xsd:string"))
				{	soap_flag_descr1--;
					continue;
				}
			}
			if (soap_flag_hostname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "hostname", &a->ns1__userFeedBroadcast::hostname, "xsd:string"))
				{	soap_flag_hostname1--;
					continue;
				}
			}
			if (soap_flag_port1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "port", &a->ns1__userFeedBroadcast::port, "xsd:string"))
				{	soap_flag_port1--;
					continue;
				}
			}
			if (soap_flag_mount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "mount", &a->ns1__userFeedBroadcast::mount, "xsd:string"))
				{	soap_flag_mount1--;
					continue;
				}
			}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "password", &a->ns1__userFeedBroadcast::password, "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_feedId1 > 0 || soap_flag_descr1 > 0 || soap_flag_hostname1 > 0 || soap_flag_port1 > 0 || soap_flag_mount1 > 0 || soap_flag_password1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__userFeedBroadcast *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__userFeedBroadcast, SOAP_TYPE_ns1__userFeedBroadcast, sizeof(ns1__userFeedBroadcast), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__userFeedBroadcast * SOAP_FMAC2 rrapi__instantiate_ns1__userFeedBroadcast(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__userFeedBroadcast(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__userFeedBroadcast *p;
	size_t k = sizeof(ns1__userFeedBroadcast);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__userFeedBroadcast, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__userFeedBroadcast);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__userFeedBroadcast, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__userFeedBroadcast location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__userFeedBroadcast::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__userFeedBroadcast(soap, tag ? tag : "ns1:userFeedBroadcast", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__userFeedBroadcast::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__userFeedBroadcast(soap, this, tag, type);
}

SOAP_FMAC3 ns1__userFeedBroadcast * SOAP_FMAC4 soap_get_ns1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__userFeedBroadcast(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__authInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__authInfo::username);
	soap_default_std__string(soap, &this->ns1__authInfo::password);
	soap_default_std__string(soap, &this->ns1__authInfo::appKey);
	soap_default_std__string(soap, &this->ns1__authInfo::version);
	soap_default_std__string(soap, &this->ns1__authInfo::style);
}

void ns1__authInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &this->ns1__authInfo::username);
	soap_serialize_std__string(soap, &this->ns1__authInfo::password);
	soap_serialize_std__string(soap, &this->ns1__authInfo::appKey);
	soap_serialize_std__string(soap, &this->ns1__authInfo::version);
	soap_serialize_std__string(soap, &this->ns1__authInfo::style);
#endif
}

int ns1__authInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__authInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__authInfo(struct soap *soap, const char *tag, int id, const ns1__authInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__authInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &a->ns1__authInfo::username, ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &a->ns1__authInfo::password, ""))
		return soap->error;
	if (soap_out_std__string(soap, "appKey", -1, &a->ns1__authInfo::appKey, ""))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &a->ns1__authInfo::version, ""))
		return soap->error;
	if (soap_out_std__string(soap, "style", -1, &a->ns1__authInfo::style, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__authInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_ns1__authInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__authInfo * SOAP_FMAC4 soap_in_ns1__authInfo(struct soap *soap, const char *tag, ns1__authInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__authInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__authInfo, sizeof(ns1__authInfo), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__authInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__authInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_username1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_appKey1 = 1;
	size_t soap_flag_version1 = 1;
	size_t soap_flag_style1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "username", &a->ns1__authInfo::username, "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "password", &a->ns1__authInfo::password, "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			}
			if (soap_flag_appKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "appKey", &a->ns1__authInfo::appKey, "xsd:string"))
				{	soap_flag_appKey1--;
					continue;
				}
			}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "version", &a->ns1__authInfo::version, "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			}
			if (soap_flag_style1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "style", &a->ns1__authInfo::style, "xsd:string"))
				{	soap_flag_style1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_username1 > 0 || soap_flag_password1 > 0 || soap_flag_appKey1 > 0 || soap_flag_version1 > 0 || soap_flag_style1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__authInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__authInfo, SOAP_TYPE_ns1__authInfo, sizeof(ns1__authInfo), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__authInfo * SOAP_FMAC2 rrapi__instantiate_ns1__authInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__authInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__authInfo *p;
	size_t k = sizeof(ns1__authInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__authInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, ns1__authInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, ns1__authInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__authInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int ns1__authInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__authInfo(soap, tag ? tag : "ns1:authInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__authInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__authInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__authInfo * SOAP_FMAC4 soap_get_ns1__authInfo(struct soap *soap, ns1__authInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__authInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?(\\d+|\\d*\\.\\d*)")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase), 0, SOAP_TYPE_xsd__decimal, SOAP_TYPE_xsd__decimal, sizeof(std::string), 0, rrapi__finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__decimal(soap, tag ? tag : "xsd:decimal", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, rrapi__finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 rrapi__instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SOAP_ENC__Array::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void SOAP_ENC__Array::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_SOAP_ENC__Array))
	{	for (size_t i = 0; i < (size_t)this->__size; i++)
		{
		}
	}
#endif
}

int SOAP_ENC__Array::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAP_ENC__Array(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENC__Array(struct soap *soap, const char *tag, int id, const SOAP_ENC__Array *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_SOAP_ENC__Array, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		if (soap_outliteral(soap, "item", &a->__ptr[i], NULL))
			return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *SOAP_ENC__Array::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SOAP_ENC__Array(soap, tag, this, type);
}

SOAP_FMAC3 SOAP_ENC__Array * SOAP_FMAC4 soap_in_SOAP_ENC__Array(struct soap *soap, const char *tag, SOAP_ENC__Array *a, const char *type)
{
	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (SOAP_ENC__Array*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENC__Array, sizeof(SOAP_ENC__Array), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		if (*soap->arraySize)
		{
			soap_getsizes(soap->arraySize, &a->__size, 1);
			a->__size -= j = soap_getoffsets(soap->arrayOffset, &a->__size, NULL, 1);
			if ((size_t)a->__size > soap->maxoccurs)
			{	soap->error = SOAP_OCCURS;
				return NULL;
			}
			a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_inliteral(soap, NULL, (char**)(a->__ptr + i)))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_alloc_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					break;
				*p = NULL;
				if (!soap_inliteral(soap, NULL, p))
				{	if (soap->error == SOAP_NO_TAG)
						soap->error = SOAP_OK;
					soap_pop_block(soap, NULL);
					break;
				}
				if ((size_t)a->__size > soap->maxoccurs)
				{	soap->error = SOAP_OCCURS;
					return NULL;
				}
			}
			a->__ptr = (char **)soap_save_block(soap, NULL, NULL, 1);
		}
		if (soap->error || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SOAP_ENC__Array *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENC__Array, SOAP_TYPE_SOAP_ENC__Array, sizeof(SOAP_ENC__Array), 0, rrapi__finsert, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 SOAP_ENC__Array * SOAP_FMAC2 rrapi__instantiate_SOAP_ENC__Array(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SOAP_ENC__Array(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SOAP_ENC__Array *p;
	size_t k = sizeof(SOAP_ENC__Array);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENC__Array, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SOAP_ENC__Array);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SOAP_ENC__Array, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SOAP_ENC__Array location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SOAP_ENC__Array::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SOAP_ENC__Array(soap, tag ? tag : "SOAP-ENC:Array", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SOAP_ENC__Array::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAP_ENC__Array(soap, this, tag, type);
}

SOAP_FMAC3 SOAP_ENC__Array * SOAP_FMAC4 soap_get_SOAP_ENC__Array(struct soap *soap, SOAP_ENC__Array *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENC__Array(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 rrapi__instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserFeedBroadcasts(struct soap *soap, struct ns1__getUserFeedBroadcasts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserFeedBroadcasts(struct soap *soap, const struct ns1__getUserFeedBroadcasts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserFeedBroadcasts(struct soap *soap, const char *tag, int id, const struct ns1__getUserFeedBroadcasts *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserFeedBroadcasts), type))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserFeedBroadcasts * SOAP_FMAC4 soap_in_ns1__getUserFeedBroadcasts(struct soap *soap, const char *tag, struct ns1__getUserFeedBroadcasts *a, const char *type)
{
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getUserFeedBroadcasts*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserFeedBroadcasts, sizeof(struct ns1__getUserFeedBroadcasts), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserFeedBroadcasts(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserFeedBroadcasts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserFeedBroadcasts, SOAP_TYPE_ns1__getUserFeedBroadcasts, sizeof(struct ns1__getUserFeedBroadcasts), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getUserFeedBroadcasts * SOAP_FMAC2 rrapi__instantiate_ns1__getUserFeedBroadcasts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getUserFeedBroadcasts(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getUserFeedBroadcasts *p;
	size_t k = sizeof(struct ns1__getUserFeedBroadcasts);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getUserFeedBroadcasts, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getUserFeedBroadcasts);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getUserFeedBroadcasts, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getUserFeedBroadcasts location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserFeedBroadcasts(struct soap *soap, const struct ns1__getUserFeedBroadcasts *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getUserFeedBroadcasts(soap, tag ? tag : "ns1:getUserFeedBroadcasts", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserFeedBroadcasts * SOAP_FMAC4 soap_get_ns1__getUserFeedBroadcasts(struct soap *soap, struct ns1__getUserFeedBroadcasts *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserFeedBroadcasts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserFeedBroadcastsResponse(struct soap *soap, struct ns1__getUserFeedBroadcastsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserFeedBroadcastsResponse(struct soap *soap, const struct ns1__getUserFeedBroadcastsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTouserFeedBroadcasts(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserFeedBroadcastsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserFeedBroadcastsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserFeedBroadcastsResponse), type))
		return soap->error;
	if (soap_out_PointerTouserFeedBroadcasts(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserFeedBroadcastsResponse * SOAP_FMAC4 soap_in_ns1__getUserFeedBroadcastsResponse(struct soap *soap, const char *tag, struct ns1__getUserFeedBroadcastsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getUserFeedBroadcastsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserFeedBroadcastsResponse, sizeof(struct ns1__getUserFeedBroadcastsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserFeedBroadcastsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTouserFeedBroadcasts(soap, "return", &a->return_, "ns1:userFeedBroadcast"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserFeedBroadcastsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserFeedBroadcastsResponse, SOAP_TYPE_ns1__getUserFeedBroadcastsResponse, sizeof(struct ns1__getUserFeedBroadcastsResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getUserFeedBroadcastsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getUserFeedBroadcastsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getUserFeedBroadcastsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getUserFeedBroadcastsResponse *p;
	size_t k = sizeof(struct ns1__getUserFeedBroadcastsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getUserFeedBroadcastsResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getUserFeedBroadcastsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getUserFeedBroadcastsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getUserFeedBroadcastsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserFeedBroadcastsResponse(struct soap *soap, const struct ns1__getUserFeedBroadcastsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getUserFeedBroadcastsResponse(soap, tag ? tag : "ns1:getUserFeedBroadcastsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserFeedBroadcastsResponse * SOAP_FMAC4 soap_get_ns1__getUserFeedBroadcastsResponse(struct soap *soap, struct ns1__getUserFeedBroadcastsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserFeedBroadcastsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserData(struct soap *soap, struct ns1__getUserData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserData(struct soap *soap, const struct ns1__getUserData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserData(struct soap *soap, const char *tag, int id, const struct ns1__getUserData *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserData), type))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserData * SOAP_FMAC4 soap_in_ns1__getUserData(struct soap *soap, const char *tag, struct ns1__getUserData *a, const char *type)
{
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getUserData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserData, sizeof(struct ns1__getUserData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserData(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserData, SOAP_TYPE_ns1__getUserData, sizeof(struct ns1__getUserData), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getUserData * SOAP_FMAC2 rrapi__instantiate_ns1__getUserData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getUserData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getUserData *p;
	size_t k = sizeof(struct ns1__getUserData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getUserData, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getUserData);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getUserData, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getUserData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserData(struct soap *soap, const struct ns1__getUserData *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getUserData(soap, tag ? tag : "ns1:getUserData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserData * SOAP_FMAC4 soap_get_ns1__getUserData(struct soap *soap, struct ns1__getUserData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserDataResponse(struct soap *soap, struct ns1__getUserDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserDataResponse(struct soap *soap, const struct ns1__getUserDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__UserInfo(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserDataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__UserInfo(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserDataResponse * SOAP_FMAC4 soap_in_ns1__getUserDataResponse(struct soap *soap, const char *tag, struct ns1__getUserDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getUserDataResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserDataResponse, sizeof(struct ns1__getUserDataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserDataResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__UserInfo(soap, "return", &a->return_, "ns1:UserInfo"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserDataResponse, SOAP_TYPE_ns1__getUserDataResponse, sizeof(struct ns1__getUserDataResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getUserDataResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getUserDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getUserDataResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getUserDataResponse *p;
	size_t k = sizeof(struct ns1__getUserDataResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getUserDataResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getUserDataResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getUserDataResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getUserDataResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserDataResponse(struct soap *soap, const struct ns1__getUserDataResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getUserDataResponse(soap, tag ? tag : "ns1:getUserDataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserDataResponse * SOAP_FMAC4 soap_get_ns1__getUserDataResponse(struct soap *soap, struct ns1__getUserDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fccGetProxCallsigns(struct soap *soap, struct ns1__fccGetProxCallsigns *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__decimal(soap, &a->lat);
	soap_default_xsd__decimal(soap, &a->lon);
	soap_default_xsd__decimal(soap, &a->range);
	soap_default_std__string(soap, &a->unit);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fccGetProxCallsigns(struct soap *soap, const struct ns1__fccGetProxCallsigns *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &a->lat);
	soap_serialize_xsd__decimal(soap, &a->lon);
	soap_serialize_xsd__decimal(soap, &a->range);
	soap_serialize_std__string(soap, &a->unit);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccGetProxCallsigns(struct soap *soap, const char *tag, int id, const struct ns1__fccGetProxCallsigns *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccGetProxCallsigns), type))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lat", -1, &a->lat, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "lon", -1, &a->lon, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "range", -1, &a->range, ""))
		return soap->error;
	if (soap_out_std__string(soap, "unit", -1, &a->unit, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fccGetProxCallsigns * SOAP_FMAC4 soap_in_ns1__fccGetProxCallsigns(struct soap *soap, const char *tag, struct ns1__fccGetProxCallsigns *a, const char *type)
{
	size_t soap_flag_lat = 1;
	size_t soap_flag_lon = 1;
	size_t soap_flag_range = 1;
	size_t soap_flag_unit = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__fccGetProxCallsigns*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccGetProxCallsigns, sizeof(struct ns1__fccGetProxCallsigns), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__fccGetProxCallsigns(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_lat && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lat", &a->lat, "xsd:decimal"))
				{	soap_flag_lat--;
					continue;
				}
			}
			if (soap_flag_lon && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "lon", &a->lon, "xsd:decimal"))
				{	soap_flag_lon--;
					continue;
				}
			}
			if (soap_flag_range && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "range", &a->range, "xsd:decimal"))
				{	soap_flag_range--;
					continue;
				}
			}
			if (soap_flag_unit && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "unit", &a->unit, "xsd:string"))
				{	soap_flag_unit--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_lat > 0 || soap_flag_lon > 0 || soap_flag_range > 0 || soap_flag_unit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__fccGetProxCallsigns *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccGetProxCallsigns, SOAP_TYPE_ns1__fccGetProxCallsigns, sizeof(struct ns1__fccGetProxCallsigns), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fccGetProxCallsigns * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetProxCallsigns(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccGetProxCallsigns(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fccGetProxCallsigns *p;
	size_t k = sizeof(struct ns1__fccGetProxCallsigns);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccGetProxCallsigns, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__fccGetProxCallsigns);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__fccGetProxCallsigns, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fccGetProxCallsigns location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fccGetProxCallsigns(struct soap *soap, const struct ns1__fccGetProxCallsigns *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fccGetProxCallsigns(soap, tag ? tag : "ns1:fccGetProxCallsigns", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fccGetProxCallsigns * SOAP_FMAC4 soap_get_ns1__fccGetProxCallsigns(struct soap *soap, struct ns1__fccGetProxCallsigns *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccGetProxCallsigns(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fccGetProxCallsignsResponse(struct soap *soap, struct ns1__fccGetProxCallsignsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fccGetProxCallsignsResponse(struct soap *soap, const struct ns1__fccGetProxCallsignsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToproxCallsignResults(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccGetProxCallsignsResponse(struct soap *soap, const char *tag, int id, const struct ns1__fccGetProxCallsignsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccGetProxCallsignsResponse), type))
		return soap->error;
	if (soap_out_PointerToproxCallsignResults(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fccGetProxCallsignsResponse * SOAP_FMAC4 soap_in_ns1__fccGetProxCallsignsResponse(struct soap *soap, const char *tag, struct ns1__fccGetProxCallsignsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__fccGetProxCallsignsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccGetProxCallsignsResponse, sizeof(struct ns1__fccGetProxCallsignsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fccGetProxCallsignsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToproxCallsignResults(soap, "return", &a->return_, "ns1:proxCallsignResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__fccGetProxCallsignsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccGetProxCallsignsResponse, SOAP_TYPE_ns1__fccGetProxCallsignsResponse, sizeof(struct ns1__fccGetProxCallsignsResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fccGetProxCallsignsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetProxCallsignsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccGetProxCallsignsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fccGetProxCallsignsResponse *p;
	size_t k = sizeof(struct ns1__fccGetProxCallsignsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccGetProxCallsignsResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__fccGetProxCallsignsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__fccGetProxCallsignsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fccGetProxCallsignsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fccGetProxCallsignsResponse(struct soap *soap, const struct ns1__fccGetProxCallsignsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fccGetProxCallsignsResponse(soap, tag ? tag : "ns1:fccGetProxCallsignsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fccGetProxCallsignsResponse * SOAP_FMAC4 soap_get_ns1__fccGetProxCallsignsResponse(struct soap *soap, struct ns1__fccGetProxCallsignsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccGetProxCallsignsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fccGetRadioServiceCode(struct soap *soap, struct ns1__fccGetRadioServiceCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->code);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fccGetRadioServiceCode(struct soap *soap, const struct ns1__fccGetRadioServiceCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->code);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccGetRadioServiceCode(struct soap *soap, const char *tag, int id, const struct ns1__fccGetRadioServiceCode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccGetRadioServiceCode), type))
		return soap->error;
	if (soap_out_std__string(soap, "code", -1, &a->code, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fccGetRadioServiceCode * SOAP_FMAC4 soap_in_ns1__fccGetRadioServiceCode(struct soap *soap, const char *tag, struct ns1__fccGetRadioServiceCode *a, const char *type)
{
	size_t soap_flag_code = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__fccGetRadioServiceCode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccGetRadioServiceCode, sizeof(struct ns1__fccGetRadioServiceCode), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__fccGetRadioServiceCode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_code && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "code", &a->code, "xsd:string"))
				{	soap_flag_code--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_code > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__fccGetRadioServiceCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccGetRadioServiceCode, SOAP_TYPE_ns1__fccGetRadioServiceCode, sizeof(struct ns1__fccGetRadioServiceCode), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fccGetRadioServiceCode * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetRadioServiceCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccGetRadioServiceCode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fccGetRadioServiceCode *p;
	size_t k = sizeof(struct ns1__fccGetRadioServiceCode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccGetRadioServiceCode, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__fccGetRadioServiceCode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__fccGetRadioServiceCode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fccGetRadioServiceCode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fccGetRadioServiceCode(struct soap *soap, const struct ns1__fccGetRadioServiceCode *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fccGetRadioServiceCode(soap, tag ? tag : "ns1:fccGetRadioServiceCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fccGetRadioServiceCode * SOAP_FMAC4 soap_get_ns1__fccGetRadioServiceCode(struct soap *soap, struct ns1__fccGetRadioServiceCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccGetRadioServiceCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, struct ns1__fccGetRadioServiceCodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, const struct ns1__fccGetRadioServiceCodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofccRadioServiceCodes(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, const char *tag, int id, const struct ns1__fccGetRadioServiceCodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse), type))
		return soap->error;
	if (soap_out_PointerTofccRadioServiceCodes(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fccGetRadioServiceCodeResponse * SOAP_FMAC4 soap_in_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, const char *tag, struct ns1__fccGetRadioServiceCodeResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__fccGetRadioServiceCodeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse, sizeof(struct ns1__fccGetRadioServiceCodeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fccGetRadioServiceCodeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofccRadioServiceCodes(soap, "return", &a->return_, "ns1:fccRadioServiceCode"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__fccGetRadioServiceCodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse, SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse, sizeof(struct ns1__fccGetRadioServiceCodeResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fccGetRadioServiceCodeResponse * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccGetRadioServiceCodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fccGetRadioServiceCodeResponse *p;
	size_t k = sizeof(struct ns1__fccGetRadioServiceCodeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccGetRadioServiceCodeResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__fccGetRadioServiceCodeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__fccGetRadioServiceCodeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fccGetRadioServiceCodeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, const struct ns1__fccGetRadioServiceCodeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fccGetRadioServiceCodeResponse(soap, tag ? tag : "ns1:fccGetRadioServiceCodeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fccGetRadioServiceCodeResponse * SOAP_FMAC4 soap_get_ns1__fccGetRadioServiceCodeResponse(struct soap *soap, struct ns1__fccGetRadioServiceCodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccGetRadioServiceCodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fccGetCallsign(struct soap *soap, struct ns1__fccGetCallsign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->callsign);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fccGetCallsign(struct soap *soap, const struct ns1__fccGetCallsign *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->callsign);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccGetCallsign(struct soap *soap, const char *tag, int id, const struct ns1__fccGetCallsign *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccGetCallsign), type))
		return soap->error;
	if (soap_out_std__string(soap, "callsign", -1, &a->callsign, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fccGetCallsign * SOAP_FMAC4 soap_in_ns1__fccGetCallsign(struct soap *soap, const char *tag, struct ns1__fccGetCallsign *a, const char *type)
{
	size_t soap_flag_callsign = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__fccGetCallsign*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccGetCallsign, sizeof(struct ns1__fccGetCallsign), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__fccGetCallsign(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_callsign && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "callsign", &a->callsign, "xsd:string"))
				{	soap_flag_callsign--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_callsign > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__fccGetCallsign *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccGetCallsign, SOAP_TYPE_ns1__fccGetCallsign, sizeof(struct ns1__fccGetCallsign), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fccGetCallsign * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetCallsign(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccGetCallsign(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fccGetCallsign *p;
	size_t k = sizeof(struct ns1__fccGetCallsign);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccGetCallsign, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__fccGetCallsign);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__fccGetCallsign, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fccGetCallsign location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fccGetCallsign(struct soap *soap, const struct ns1__fccGetCallsign *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fccGetCallsign(soap, tag ? tag : "ns1:fccGetCallsign", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fccGetCallsign * SOAP_FMAC4 soap_get_ns1__fccGetCallsign(struct soap *soap, struct ns1__fccGetCallsign *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccGetCallsign(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fccGetCallsignResponse(struct soap *soap, struct ns1__fccGetCallsignResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fccGetCallsignResponse(struct soap *soap, const struct ns1__fccGetCallsignResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__fccCallsignDetails(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fccGetCallsignResponse(struct soap *soap, const char *tag, int id, const struct ns1__fccGetCallsignResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fccGetCallsignResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__fccCallsignDetails(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fccGetCallsignResponse * SOAP_FMAC4 soap_in_ns1__fccGetCallsignResponse(struct soap *soap, const char *tag, struct ns1__fccGetCallsignResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__fccGetCallsignResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fccGetCallsignResponse, sizeof(struct ns1__fccGetCallsignResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fccGetCallsignResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__fccCallsignDetails(soap, "return", &a->return_, "ns1:fccCallsignDetails"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__fccGetCallsignResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fccGetCallsignResponse, SOAP_TYPE_ns1__fccGetCallsignResponse, sizeof(struct ns1__fccGetCallsignResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fccGetCallsignResponse * SOAP_FMAC2 rrapi__instantiate_ns1__fccGetCallsignResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__fccGetCallsignResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fccGetCallsignResponse *p;
	size_t k = sizeof(struct ns1__fccGetCallsignResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__fccGetCallsignResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__fccGetCallsignResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__fccGetCallsignResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fccGetCallsignResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fccGetCallsignResponse(struct soap *soap, const struct ns1__fccGetCallsignResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fccGetCallsignResponse(soap, tag ? tag : "ns1:fccGetCallsignResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fccGetCallsignResponse * SOAP_FMAC4 soap_get_ns1__fccGetCallsignResponse(struct soap *soap, struct ns1__fccGetCallsignResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fccGetCallsignResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getZipcodeInfo(struct soap *soap, struct ns1__getZipcodeInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->zipcode);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getZipcodeInfo(struct soap *soap, const struct ns1__getZipcodeInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getZipcodeInfo(struct soap *soap, const char *tag, int id, const struct ns1__getZipcodeInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getZipcodeInfo), type))
		return soap->error;
	if (soap_out_int(soap, "zipcode", -1, &a->zipcode, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getZipcodeInfo * SOAP_FMAC4 soap_in_ns1__getZipcodeInfo(struct soap *soap, const char *tag, struct ns1__getZipcodeInfo *a, const char *type)
{
	size_t soap_flag_zipcode = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getZipcodeInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getZipcodeInfo, sizeof(struct ns1__getZipcodeInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getZipcodeInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_zipcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "zipcode", &a->zipcode, "xsd:int"))
				{	soap_flag_zipcode--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_zipcode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getZipcodeInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getZipcodeInfo, SOAP_TYPE_ns1__getZipcodeInfo, sizeof(struct ns1__getZipcodeInfo), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getZipcodeInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getZipcodeInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getZipcodeInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getZipcodeInfo *p;
	size_t k = sizeof(struct ns1__getZipcodeInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getZipcodeInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getZipcodeInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getZipcodeInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getZipcodeInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getZipcodeInfo(struct soap *soap, const struct ns1__getZipcodeInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getZipcodeInfo(soap, tag ? tag : "ns1:getZipcodeInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getZipcodeInfo * SOAP_FMAC4 soap_get_ns1__getZipcodeInfo(struct soap *soap, struct ns1__getZipcodeInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getZipcodeInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getZipcodeInfoResponse(struct soap *soap, struct ns1__getZipcodeInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getZipcodeInfoResponse(struct soap *soap, const struct ns1__getZipcodeInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ZipInfo(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getZipcodeInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getZipcodeInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getZipcodeInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__ZipInfo(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getZipcodeInfoResponse * SOAP_FMAC4 soap_in_ns1__getZipcodeInfoResponse(struct soap *soap, const char *tag, struct ns1__getZipcodeInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getZipcodeInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getZipcodeInfoResponse, sizeof(struct ns1__getZipcodeInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getZipcodeInfoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__ZipInfo(soap, "return", &a->return_, "ns1:ZipInfo"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getZipcodeInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getZipcodeInfoResponse, SOAP_TYPE_ns1__getZipcodeInfoResponse, sizeof(struct ns1__getZipcodeInfoResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getZipcodeInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getZipcodeInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getZipcodeInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getZipcodeInfoResponse *p;
	size_t k = sizeof(struct ns1__getZipcodeInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getZipcodeInfoResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getZipcodeInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getZipcodeInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getZipcodeInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getZipcodeInfoResponse(struct soap *soap, const struct ns1__getZipcodeInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getZipcodeInfoResponse(soap, tag ? tag : "ns1:getZipcodeInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getZipcodeInfoResponse * SOAP_FMAC4 soap_get_ns1__getZipcodeInfoResponse(struct soap *soap, struct ns1__getZipcodeInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getZipcodeInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMetroAreaInfo(struct soap *soap, struct ns1__getMetroAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMetroAreaInfo(struct soap *soap, const struct ns1__getMetroAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetroAreaInfo(struct soap *soap, const char *tag, int id, const struct ns1__getMetroAreaInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetroAreaInfo), type))
		return soap->error;
	if (soap_out_int(soap, "mid", -1, &a->mid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMetroAreaInfo * SOAP_FMAC4 soap_in_ns1__getMetroAreaInfo(struct soap *soap, const char *tag, struct ns1__getMetroAreaInfo *a, const char *type)
{
	size_t soap_flag_mid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getMetroAreaInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetroAreaInfo, sizeof(struct ns1__getMetroAreaInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMetroAreaInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mid", &a->mid, "xsd:int"))
				{	soap_flag_mid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getMetroAreaInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetroAreaInfo, SOAP_TYPE_ns1__getMetroAreaInfo, sizeof(struct ns1__getMetroAreaInfo), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getMetroAreaInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroAreaInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getMetroAreaInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getMetroAreaInfo *p;
	size_t k = sizeof(struct ns1__getMetroAreaInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getMetroAreaInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getMetroAreaInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getMetroAreaInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getMetroAreaInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMetroAreaInfo(struct soap *soap, const struct ns1__getMetroAreaInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getMetroAreaInfo(soap, tag ? tag : "ns1:getMetroAreaInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMetroAreaInfo * SOAP_FMAC4 soap_get_ns1__getMetroAreaInfo(struct soap *soap, struct ns1__getMetroAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetroAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMetroAreaInfoResponse(struct soap *soap, struct ns1__getMetroAreaInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMetroAreaInfoResponse(struct soap *soap, const struct ns1__getMetroAreaInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToCounties(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetroAreaInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getMetroAreaInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetroAreaInfoResponse), type))
		return soap->error;
	if (soap_out_PointerToCounties(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMetroAreaInfoResponse * SOAP_FMAC4 soap_in_ns1__getMetroAreaInfoResponse(struct soap *soap, const char *tag, struct ns1__getMetroAreaInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getMetroAreaInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetroAreaInfoResponse, sizeof(struct ns1__getMetroAreaInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMetroAreaInfoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToCounties(soap, "return", &a->return_, "ns1:County"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getMetroAreaInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetroAreaInfoResponse, SOAP_TYPE_ns1__getMetroAreaInfoResponse, sizeof(struct ns1__getMetroAreaInfoResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getMetroAreaInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroAreaInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getMetroAreaInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getMetroAreaInfoResponse *p;
	size_t k = sizeof(struct ns1__getMetroAreaInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getMetroAreaInfoResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getMetroAreaInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getMetroAreaInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getMetroAreaInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMetroAreaInfoResponse(struct soap *soap, const struct ns1__getMetroAreaInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getMetroAreaInfoResponse(soap, tag ? tag : "ns1:getMetroAreaInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMetroAreaInfoResponse * SOAP_FMAC4 soap_get_ns1__getMetroAreaInfoResponse(struct soap *soap, struct ns1__getMetroAreaInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetroAreaInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMetroArea(struct soap *soap, struct ns1__getMetroArea *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMetroArea(struct soap *soap, const struct ns1__getMetroArea *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetroArea(struct soap *soap, const char *tag, int id, const struct ns1__getMetroArea *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetroArea), type))
		return soap->error;
	if (soap_out_int(soap, "mid", -1, &a->mid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMetroArea * SOAP_FMAC4 soap_in_ns1__getMetroArea(struct soap *soap, const char *tag, struct ns1__getMetroArea *a, const char *type)
{
	size_t soap_flag_mid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getMetroArea*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetroArea, sizeof(struct ns1__getMetroArea), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMetroArea(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mid", &a->mid, "xsd:int"))
				{	soap_flag_mid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getMetroArea *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetroArea, SOAP_TYPE_ns1__getMetroArea, sizeof(struct ns1__getMetroArea), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getMetroArea * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroArea(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getMetroArea(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getMetroArea *p;
	size_t k = sizeof(struct ns1__getMetroArea);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getMetroArea, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getMetroArea);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getMetroArea, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getMetroArea location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMetroArea(struct soap *soap, const struct ns1__getMetroArea *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getMetroArea(soap, tag ? tag : "ns1:getMetroArea", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMetroArea * SOAP_FMAC4 soap_get_ns1__getMetroArea(struct soap *soap, struct ns1__getMetroArea *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetroArea(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMetroAreaResponse(struct soap *soap, struct ns1__getMetroAreaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMetroAreaResponse(struct soap *soap, const struct ns1__getMetroAreaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToMetros(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetroAreaResponse(struct soap *soap, const char *tag, int id, const struct ns1__getMetroAreaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetroAreaResponse), type))
		return soap->error;
	if (soap_out_PointerToMetros(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMetroAreaResponse * SOAP_FMAC4 soap_in_ns1__getMetroAreaResponse(struct soap *soap, const char *tag, struct ns1__getMetroAreaResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getMetroAreaResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetroAreaResponse, sizeof(struct ns1__getMetroAreaResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMetroAreaResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToMetros(soap, "return", &a->return_, "ns1:Metro"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getMetroAreaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetroAreaResponse, SOAP_TYPE_ns1__getMetroAreaResponse, sizeof(struct ns1__getMetroAreaResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getMetroAreaResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getMetroAreaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getMetroAreaResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getMetroAreaResponse *p;
	size_t k = sizeof(struct ns1__getMetroAreaResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getMetroAreaResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getMetroAreaResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getMetroAreaResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getMetroAreaResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMetroAreaResponse(struct soap *soap, const struct ns1__getMetroAreaResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getMetroAreaResponse(soap, tag ? tag : "ns1:getMetroAreaResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMetroAreaResponse * SOAP_FMAC4 soap_get_ns1__getMetroAreaResponse(struct soap *soap, struct ns1__getMetroAreaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetroAreaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAgencyFreqsByTag(struct soap *soap, struct ns1__getAgencyFreqsByTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->aid);
	soap_default_int(soap, &a->tag);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAgencyFreqsByTag(struct soap *soap, const struct ns1__getAgencyFreqsByTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAgencyFreqsByTag(struct soap *soap, const char *tag, int id, const struct ns1__getAgencyFreqsByTag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAgencyFreqsByTag), type))
		return soap->error;
	if (soap_out_int(soap, "aid", -1, &a->aid, ""))
		return soap->error;
	if (soap_out_int(soap, "tag", -1, &a->tag, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAgencyFreqsByTag * SOAP_FMAC4 soap_in_ns1__getAgencyFreqsByTag(struct soap *soap, const char *tag, struct ns1__getAgencyFreqsByTag *a, const char *type)
{
	size_t soap_flag_aid = 1;
	size_t soap_flag_tag = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getAgencyFreqsByTag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAgencyFreqsByTag, sizeof(struct ns1__getAgencyFreqsByTag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAgencyFreqsByTag(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_aid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "aid", &a->aid, "xsd:int"))
				{	soap_flag_aid--;
					continue;
				}
			}
			if (soap_flag_tag && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tag", &a->tag, "xsd:int"))
				{	soap_flag_tag--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_aid > 0 || soap_flag_tag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getAgencyFreqsByTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAgencyFreqsByTag, SOAP_TYPE_ns1__getAgencyFreqsByTag, sizeof(struct ns1__getAgencyFreqsByTag), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getAgencyFreqsByTag * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyFreqsByTag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getAgencyFreqsByTag(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getAgencyFreqsByTag *p;
	size_t k = sizeof(struct ns1__getAgencyFreqsByTag);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getAgencyFreqsByTag, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getAgencyFreqsByTag);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getAgencyFreqsByTag, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getAgencyFreqsByTag location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAgencyFreqsByTag(struct soap *soap, const struct ns1__getAgencyFreqsByTag *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getAgencyFreqsByTag(soap, tag ? tag : "ns1:getAgencyFreqsByTag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAgencyFreqsByTag * SOAP_FMAC4 soap_get_ns1__getAgencyFreqsByTag(struct soap *soap, struct ns1__getAgencyFreqsByTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAgencyFreqsByTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAgencyFreqsByTagResponse(struct soap *soap, struct ns1__getAgencyFreqsByTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAgencyFreqsByTagResponse(struct soap *soap, const struct ns1__getAgencyFreqsByTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToFreqs(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAgencyFreqsByTagResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAgencyFreqsByTagResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAgencyFreqsByTagResponse), type))
		return soap->error;
	if (soap_out_PointerToFreqs(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAgencyFreqsByTagResponse * SOAP_FMAC4 soap_in_ns1__getAgencyFreqsByTagResponse(struct soap *soap, const char *tag, struct ns1__getAgencyFreqsByTagResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getAgencyFreqsByTagResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAgencyFreqsByTagResponse, sizeof(struct ns1__getAgencyFreqsByTagResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAgencyFreqsByTagResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToFreqs(soap, "return", &a->return_, "ns1:freq"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAgencyFreqsByTagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAgencyFreqsByTagResponse, SOAP_TYPE_ns1__getAgencyFreqsByTagResponse, sizeof(struct ns1__getAgencyFreqsByTagResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getAgencyFreqsByTagResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyFreqsByTagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getAgencyFreqsByTagResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getAgencyFreqsByTagResponse *p;
	size_t k = sizeof(struct ns1__getAgencyFreqsByTagResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getAgencyFreqsByTagResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getAgencyFreqsByTagResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getAgencyFreqsByTagResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getAgencyFreqsByTagResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAgencyFreqsByTagResponse(struct soap *soap, const struct ns1__getAgencyFreqsByTagResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getAgencyFreqsByTagResponse(soap, tag ? tag : "ns1:getAgencyFreqsByTagResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAgencyFreqsByTagResponse * SOAP_FMAC4 soap_get_ns1__getAgencyFreqsByTagResponse(struct soap *soap, struct ns1__getAgencyFreqsByTagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAgencyFreqsByTagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountyFreqsByTag(struct soap *soap, struct ns1__getCountyFreqsByTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ctid);
	soap_default_int(soap, &a->tag);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountyFreqsByTag(struct soap *soap, const struct ns1__getCountyFreqsByTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountyFreqsByTag(struct soap *soap, const char *tag, int id, const struct ns1__getCountyFreqsByTag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountyFreqsByTag), type))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ctid, ""))
		return soap->error;
	if (soap_out_int(soap, "tag", -1, &a->tag, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountyFreqsByTag * SOAP_FMAC4 soap_in_ns1__getCountyFreqsByTag(struct soap *soap, const char *tag, struct ns1__getCountyFreqsByTag *a, const char *type)
{
	size_t soap_flag_ctid = 1;
	size_t soap_flag_tag = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountyFreqsByTag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountyFreqsByTag, sizeof(struct ns1__getCountyFreqsByTag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountyFreqsByTag(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ctid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ctid, "xsd:int"))
				{	soap_flag_ctid--;
					continue;
				}
			}
			if (soap_flag_tag && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tag", &a->tag, "xsd:int"))
				{	soap_flag_tag--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ctid > 0 || soap_flag_tag > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getCountyFreqsByTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountyFreqsByTag, SOAP_TYPE_ns1__getCountyFreqsByTag, sizeof(struct ns1__getCountyFreqsByTag), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountyFreqsByTag * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyFreqsByTag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountyFreqsByTag(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountyFreqsByTag *p;
	size_t k = sizeof(struct ns1__getCountyFreqsByTag);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountyFreqsByTag, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountyFreqsByTag);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountyFreqsByTag, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountyFreqsByTag location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountyFreqsByTag(struct soap *soap, const struct ns1__getCountyFreqsByTag *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountyFreqsByTag(soap, tag ? tag : "ns1:getCountyFreqsByTag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountyFreqsByTag * SOAP_FMAC4 soap_get_ns1__getCountyFreqsByTag(struct soap *soap, struct ns1__getCountyFreqsByTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountyFreqsByTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountyFreqsByTagResponse(struct soap *soap, struct ns1__getCountyFreqsByTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountyFreqsByTagResponse(struct soap *soap, const struct ns1__getCountyFreqsByTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToFreqs(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountyFreqsByTagResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCountyFreqsByTagResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountyFreqsByTagResponse), type))
		return soap->error;
	if (soap_out_PointerToFreqs(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountyFreqsByTagResponse * SOAP_FMAC4 soap_in_ns1__getCountyFreqsByTagResponse(struct soap *soap, const char *tag, struct ns1__getCountyFreqsByTagResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountyFreqsByTagResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountyFreqsByTagResponse, sizeof(struct ns1__getCountyFreqsByTagResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountyFreqsByTagResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToFreqs(soap, "return", &a->return_, "ns1:freq"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountyFreqsByTagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountyFreqsByTagResponse, SOAP_TYPE_ns1__getCountyFreqsByTagResponse, sizeof(struct ns1__getCountyFreqsByTagResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountyFreqsByTagResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyFreqsByTagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountyFreqsByTagResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountyFreqsByTagResponse *p;
	size_t k = sizeof(struct ns1__getCountyFreqsByTagResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountyFreqsByTagResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountyFreqsByTagResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountyFreqsByTagResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountyFreqsByTagResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountyFreqsByTagResponse(struct soap *soap, const struct ns1__getCountyFreqsByTagResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountyFreqsByTagResponse(soap, tag ? tag : "ns1:getCountyFreqsByTagResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountyFreqsByTagResponse * SOAP_FMAC4 soap_get_ns1__getCountyFreqsByTagResponse(struct soap *soap, struct ns1__getCountyFreqsByTagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountyFreqsByTagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchMetroFreq(struct soap *soap, struct ns1__searchMetroFreq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mid);
	soap_default_xsd__decimal(soap, &a->freq);
	soap_default_std__string(soap, &a->tone);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchMetroFreq(struct soap *soap, const struct ns1__searchMetroFreq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &a->freq);
	soap_serialize_std__string(soap, &a->tone);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchMetroFreq(struct soap *soap, const char *tag, int id, const struct ns1__searchMetroFreq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchMetroFreq), type))
		return soap->error;
	if (soap_out_int(soap, "mid", -1, &a->mid, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "freq", -1, &a->freq, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tone", -1, &a->tone, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchMetroFreq * SOAP_FMAC4 soap_in_ns1__searchMetroFreq(struct soap *soap, const char *tag, struct ns1__searchMetroFreq *a, const char *type)
{
	size_t soap_flag_mid = 1;
	size_t soap_flag_freq = 1;
	size_t soap_flag_tone = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__searchMetroFreq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchMetroFreq, sizeof(struct ns1__searchMetroFreq), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__searchMetroFreq(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mid", &a->mid, "xsd:int"))
				{	soap_flag_mid--;
					continue;
				}
			}
			if (soap_flag_freq && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "freq", &a->freq, "xsd:decimal"))
				{	soap_flag_freq--;
					continue;
				}
			}
			if (soap_flag_tone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tone", &a->tone, "xsd:string"))
				{	soap_flag_tone--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mid > 0 || soap_flag_freq > 0 || soap_flag_tone > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__searchMetroFreq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchMetroFreq, SOAP_TYPE_ns1__searchMetroFreq, sizeof(struct ns1__searchMetroFreq), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__searchMetroFreq * SOAP_FMAC2 rrapi__instantiate_ns1__searchMetroFreq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchMetroFreq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__searchMetroFreq *p;
	size_t k = sizeof(struct ns1__searchMetroFreq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchMetroFreq, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__searchMetroFreq);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__searchMetroFreq, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__searchMetroFreq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchMetroFreq(struct soap *soap, const struct ns1__searchMetroFreq *a, const char *tag, const char *type)
{
	if (soap_out_ns1__searchMetroFreq(soap, tag ? tag : "ns1:searchMetroFreq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__searchMetroFreq * SOAP_FMAC4 soap_get_ns1__searchMetroFreq(struct soap *soap, struct ns1__searchMetroFreq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchMetroFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchMetroFreqResponse(struct soap *soap, struct ns1__searchMetroFreqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchMetroFreqResponse(struct soap *soap, const struct ns1__searchMetroFreqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosearchFreqResults(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchMetroFreqResponse(struct soap *soap, const char *tag, int id, const struct ns1__searchMetroFreqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchMetroFreqResponse), type))
		return soap->error;
	if (soap_out_PointerTosearchFreqResults(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchMetroFreqResponse * SOAP_FMAC4 soap_in_ns1__searchMetroFreqResponse(struct soap *soap, const char *tag, struct ns1__searchMetroFreqResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__searchMetroFreqResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchMetroFreqResponse, sizeof(struct ns1__searchMetroFreqResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__searchMetroFreqResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosearchFreqResults(soap, "return", &a->return_, "ns1:searchFreqResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__searchMetroFreqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchMetroFreqResponse, SOAP_TYPE_ns1__searchMetroFreqResponse, sizeof(struct ns1__searchMetroFreqResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__searchMetroFreqResponse * SOAP_FMAC2 rrapi__instantiate_ns1__searchMetroFreqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchMetroFreqResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__searchMetroFreqResponse *p;
	size_t k = sizeof(struct ns1__searchMetroFreqResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchMetroFreqResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__searchMetroFreqResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__searchMetroFreqResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__searchMetroFreqResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchMetroFreqResponse(struct soap *soap, const struct ns1__searchMetroFreqResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__searchMetroFreqResponse(soap, tag ? tag : "ns1:searchMetroFreqResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__searchMetroFreqResponse * SOAP_FMAC4 soap_get_ns1__searchMetroFreqResponse(struct soap *soap, struct ns1__searchMetroFreqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchMetroFreqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchStateFreq(struct soap *soap, struct ns1__searchStateFreq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->stid);
	soap_default_xsd__decimal(soap, &a->freq);
	soap_default_std__string(soap, &a->tone);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchStateFreq(struct soap *soap, const struct ns1__searchStateFreq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &a->freq);
	soap_serialize_std__string(soap, &a->tone);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchStateFreq(struct soap *soap, const char *tag, int id, const struct ns1__searchStateFreq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchStateFreq), type))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->stid, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "freq", -1, &a->freq, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tone", -1, &a->tone, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchStateFreq * SOAP_FMAC4 soap_in_ns1__searchStateFreq(struct soap *soap, const char *tag, struct ns1__searchStateFreq *a, const char *type)
{
	size_t soap_flag_stid = 1;
	size_t soap_flag_freq = 1;
	size_t soap_flag_tone = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__searchStateFreq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchStateFreq, sizeof(struct ns1__searchStateFreq), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__searchStateFreq(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->stid, "xsd:int"))
				{	soap_flag_stid--;
					continue;
				}
			}
			if (soap_flag_freq && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "freq", &a->freq, "xsd:decimal"))
				{	soap_flag_freq--;
					continue;
				}
			}
			if (soap_flag_tone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tone", &a->tone, "xsd:string"))
				{	soap_flag_tone--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stid > 0 || soap_flag_freq > 0 || soap_flag_tone > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__searchStateFreq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchStateFreq, SOAP_TYPE_ns1__searchStateFreq, sizeof(struct ns1__searchStateFreq), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__searchStateFreq * SOAP_FMAC2 rrapi__instantiate_ns1__searchStateFreq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchStateFreq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__searchStateFreq *p;
	size_t k = sizeof(struct ns1__searchStateFreq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchStateFreq, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__searchStateFreq);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__searchStateFreq, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__searchStateFreq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchStateFreq(struct soap *soap, const struct ns1__searchStateFreq *a, const char *tag, const char *type)
{
	if (soap_out_ns1__searchStateFreq(soap, tag ? tag : "ns1:searchStateFreq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__searchStateFreq * SOAP_FMAC4 soap_get_ns1__searchStateFreq(struct soap *soap, struct ns1__searchStateFreq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchStateFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchStateFreqResponse(struct soap *soap, struct ns1__searchStateFreqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchStateFreqResponse(struct soap *soap, const struct ns1__searchStateFreqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosearchFreqResults(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchStateFreqResponse(struct soap *soap, const char *tag, int id, const struct ns1__searchStateFreqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchStateFreqResponse), type))
		return soap->error;
	if (soap_out_PointerTosearchFreqResults(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchStateFreqResponse * SOAP_FMAC4 soap_in_ns1__searchStateFreqResponse(struct soap *soap, const char *tag, struct ns1__searchStateFreqResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__searchStateFreqResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchStateFreqResponse, sizeof(struct ns1__searchStateFreqResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__searchStateFreqResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosearchFreqResults(soap, "return", &a->return_, "ns1:searchFreqResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__searchStateFreqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchStateFreqResponse, SOAP_TYPE_ns1__searchStateFreqResponse, sizeof(struct ns1__searchStateFreqResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__searchStateFreqResponse * SOAP_FMAC2 rrapi__instantiate_ns1__searchStateFreqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchStateFreqResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__searchStateFreqResponse *p;
	size_t k = sizeof(struct ns1__searchStateFreqResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchStateFreqResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__searchStateFreqResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__searchStateFreqResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__searchStateFreqResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchStateFreqResponse(struct soap *soap, const struct ns1__searchStateFreqResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__searchStateFreqResponse(soap, tag ? tag : "ns1:searchStateFreqResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__searchStateFreqResponse * SOAP_FMAC4 soap_get_ns1__searchStateFreqResponse(struct soap *soap, struct ns1__searchStateFreqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchStateFreqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchCountyFreq(struct soap *soap, struct ns1__searchCountyFreq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ctid);
	soap_default_xsd__decimal(soap, &a->freq);
	soap_default_std__string(soap, &a->tone);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchCountyFreq(struct soap *soap, const struct ns1__searchCountyFreq *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__decimal(soap, &a->freq);
	soap_serialize_std__string(soap, &a->tone);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchCountyFreq(struct soap *soap, const char *tag, int id, const struct ns1__searchCountyFreq *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchCountyFreq), type))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ctid, ""))
		return soap->error;
	if (soap_out_xsd__decimal(soap, "freq", -1, &a->freq, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tone", -1, &a->tone, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchCountyFreq * SOAP_FMAC4 soap_in_ns1__searchCountyFreq(struct soap *soap, const char *tag, struct ns1__searchCountyFreq *a, const char *type)
{
	size_t soap_flag_ctid = 1;
	size_t soap_flag_freq = 1;
	size_t soap_flag_tone = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__searchCountyFreq*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchCountyFreq, sizeof(struct ns1__searchCountyFreq), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__searchCountyFreq(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ctid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ctid, "xsd:int"))
				{	soap_flag_ctid--;
					continue;
				}
			}
			if (soap_flag_freq && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__decimal(soap, "freq", &a->freq, "xsd:decimal"))
				{	soap_flag_freq--;
					continue;
				}
			}
			if (soap_flag_tone && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tone", &a->tone, "xsd:string"))
				{	soap_flag_tone--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ctid > 0 || soap_flag_freq > 0 || soap_flag_tone > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__searchCountyFreq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchCountyFreq, SOAP_TYPE_ns1__searchCountyFreq, sizeof(struct ns1__searchCountyFreq), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__searchCountyFreq * SOAP_FMAC2 rrapi__instantiate_ns1__searchCountyFreq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchCountyFreq(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__searchCountyFreq *p;
	size_t k = sizeof(struct ns1__searchCountyFreq);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchCountyFreq, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__searchCountyFreq);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__searchCountyFreq, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__searchCountyFreq location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchCountyFreq(struct soap *soap, const struct ns1__searchCountyFreq *a, const char *tag, const char *type)
{
	if (soap_out_ns1__searchCountyFreq(soap, tag ? tag : "ns1:searchCountyFreq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__searchCountyFreq * SOAP_FMAC4 soap_get_ns1__searchCountyFreq(struct soap *soap, struct ns1__searchCountyFreq *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchCountyFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__searchCountyFreqResponse(struct soap *soap, struct ns1__searchCountyFreqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__searchCountyFreqResponse(struct soap *soap, const struct ns1__searchCountyFreqResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosearchFreqResults(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__searchCountyFreqResponse(struct soap *soap, const char *tag, int id, const struct ns1__searchCountyFreqResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__searchCountyFreqResponse), type))
		return soap->error;
	if (soap_out_PointerTosearchFreqResults(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__searchCountyFreqResponse * SOAP_FMAC4 soap_in_ns1__searchCountyFreqResponse(struct soap *soap, const char *tag, struct ns1__searchCountyFreqResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__searchCountyFreqResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__searchCountyFreqResponse, sizeof(struct ns1__searchCountyFreqResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__searchCountyFreqResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTosearchFreqResults(soap, "return", &a->return_, "ns1:searchFreqResult"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__searchCountyFreqResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__searchCountyFreqResponse, SOAP_TYPE_ns1__searchCountyFreqResponse, sizeof(struct ns1__searchCountyFreqResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__searchCountyFreqResponse * SOAP_FMAC2 rrapi__instantiate_ns1__searchCountyFreqResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__searchCountyFreqResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__searchCountyFreqResponse *p;
	size_t k = sizeof(struct ns1__searchCountyFreqResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__searchCountyFreqResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__searchCountyFreqResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__searchCountyFreqResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__searchCountyFreqResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__searchCountyFreqResponse(struct soap *soap, const struct ns1__searchCountyFreqResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__searchCountyFreqResponse(soap, tag ? tag : "ns1:searchCountyFreqResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__searchCountyFreqResponse * SOAP_FMAC4 soap_get_ns1__searchCountyFreqResponse(struct soap *soap, struct ns1__searchCountyFreqResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__searchCountyFreqResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSubcatFreqs(struct soap *soap, struct ns1__getSubcatFreqs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->scid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSubcatFreqs(struct soap *soap, const struct ns1__getSubcatFreqs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSubcatFreqs(struct soap *soap, const char *tag, int id, const struct ns1__getSubcatFreqs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSubcatFreqs), type))
		return soap->error;
	if (soap_out_int(soap, "scid", -1, &a->scid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSubcatFreqs * SOAP_FMAC4 soap_in_ns1__getSubcatFreqs(struct soap *soap, const char *tag, struct ns1__getSubcatFreqs *a, const char *type)
{
	size_t soap_flag_scid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getSubcatFreqs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSubcatFreqs, sizeof(struct ns1__getSubcatFreqs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getSubcatFreqs(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_scid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "scid", &a->scid, "xsd:int"))
				{	soap_flag_scid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_scid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getSubcatFreqs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSubcatFreqs, SOAP_TYPE_ns1__getSubcatFreqs, sizeof(struct ns1__getSubcatFreqs), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getSubcatFreqs * SOAP_FMAC2 rrapi__instantiate_ns1__getSubcatFreqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getSubcatFreqs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getSubcatFreqs *p;
	size_t k = sizeof(struct ns1__getSubcatFreqs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getSubcatFreqs, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getSubcatFreqs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getSubcatFreqs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getSubcatFreqs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSubcatFreqs(struct soap *soap, const struct ns1__getSubcatFreqs *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getSubcatFreqs(soap, tag ? tag : "ns1:getSubcatFreqs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSubcatFreqs * SOAP_FMAC4 soap_get_ns1__getSubcatFreqs(struct soap *soap, struct ns1__getSubcatFreqs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSubcatFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getSubcatFreqsResponse(struct soap *soap, struct ns1__getSubcatFreqsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getSubcatFreqsResponse(struct soap *soap, const struct ns1__getSubcatFreqsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToFreqs(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getSubcatFreqsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getSubcatFreqsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getSubcatFreqsResponse), type))
		return soap->error;
	if (soap_out_PointerToFreqs(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getSubcatFreqsResponse * SOAP_FMAC4 soap_in_ns1__getSubcatFreqsResponse(struct soap *soap, const char *tag, struct ns1__getSubcatFreqsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getSubcatFreqsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getSubcatFreqsResponse, sizeof(struct ns1__getSubcatFreqsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getSubcatFreqsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToFreqs(soap, "return", &a->return_, "ns1:freq"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getSubcatFreqsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getSubcatFreqsResponse, SOAP_TYPE_ns1__getSubcatFreqsResponse, sizeof(struct ns1__getSubcatFreqsResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getSubcatFreqsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getSubcatFreqsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getSubcatFreqsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getSubcatFreqsResponse *p;
	size_t k = sizeof(struct ns1__getSubcatFreqsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getSubcatFreqsResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getSubcatFreqsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getSubcatFreqsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getSubcatFreqsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getSubcatFreqsResponse(struct soap *soap, const struct ns1__getSubcatFreqsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getSubcatFreqsResponse(soap, tag ? tag : "ns1:getSubcatFreqsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getSubcatFreqsResponse * SOAP_FMAC4 soap_get_ns1__getSubcatFreqsResponse(struct soap *soap, struct ns1__getSubcatFreqsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getSubcatFreqsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAgencyInfo(struct soap *soap, struct ns1__getAgencyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->aid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAgencyInfo(struct soap *soap, const struct ns1__getAgencyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAgencyInfo(struct soap *soap, const char *tag, int id, const struct ns1__getAgencyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAgencyInfo), type))
		return soap->error;
	if (soap_out_int(soap, "aid", -1, &a->aid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAgencyInfo * SOAP_FMAC4 soap_in_ns1__getAgencyInfo(struct soap *soap, const char *tag, struct ns1__getAgencyInfo *a, const char *type)
{
	size_t soap_flag_aid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getAgencyInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAgencyInfo, sizeof(struct ns1__getAgencyInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAgencyInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_aid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "aid", &a->aid, "xsd:int"))
				{	soap_flag_aid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_aid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getAgencyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAgencyInfo, SOAP_TYPE_ns1__getAgencyInfo, sizeof(struct ns1__getAgencyInfo), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getAgencyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getAgencyInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getAgencyInfo *p;
	size_t k = sizeof(struct ns1__getAgencyInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getAgencyInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getAgencyInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getAgencyInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getAgencyInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAgencyInfo(struct soap *soap, const struct ns1__getAgencyInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getAgencyInfo(soap, tag ? tag : "ns1:getAgencyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAgencyInfo * SOAP_FMAC4 soap_get_ns1__getAgencyInfo(struct soap *soap, struct ns1__getAgencyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAgencyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAgencyInfoResponse(struct soap *soap, struct ns1__getAgencyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAgencyInfoResponse(struct soap *soap, const struct ns1__getAgencyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__AgencyInfo(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAgencyInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAgencyInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAgencyInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__AgencyInfo(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAgencyInfoResponse * SOAP_FMAC4 soap_in_ns1__getAgencyInfoResponse(struct soap *soap, const char *tag, struct ns1__getAgencyInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getAgencyInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAgencyInfoResponse, sizeof(struct ns1__getAgencyInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAgencyInfoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__AgencyInfo(soap, "return", &a->return_, "ns1:AgencyInfo"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAgencyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAgencyInfoResponse, SOAP_TYPE_ns1__getAgencyInfoResponse, sizeof(struct ns1__getAgencyInfoResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getAgencyInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getAgencyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getAgencyInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getAgencyInfoResponse *p;
	size_t k = sizeof(struct ns1__getAgencyInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getAgencyInfoResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getAgencyInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getAgencyInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getAgencyInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAgencyInfoResponse(struct soap *soap, const struct ns1__getAgencyInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getAgencyInfoResponse(soap, tag ? tag : "ns1:getAgencyInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAgencyInfoResponse * SOAP_FMAC4 soap_get_ns1__getAgencyInfoResponse(struct soap *soap, struct ns1__getAgencyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAgencyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountyInfo(struct soap *soap, struct ns1__getCountyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->ctid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountyInfo(struct soap *soap, const struct ns1__getCountyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountyInfo(struct soap *soap, const char *tag, int id, const struct ns1__getCountyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountyInfo), type))
		return soap->error;
	if (soap_out_int(soap, "ctid", -1, &a->ctid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountyInfo * SOAP_FMAC4 soap_in_ns1__getCountyInfo(struct soap *soap, const char *tag, struct ns1__getCountyInfo *a, const char *type)
{
	size_t soap_flag_ctid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountyInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountyInfo, sizeof(struct ns1__getCountyInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountyInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ctid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "ctid", &a->ctid, "xsd:int"))
				{	soap_flag_ctid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ctid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getCountyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountyInfo, SOAP_TYPE_ns1__getCountyInfo, sizeof(struct ns1__getCountyInfo), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountyInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountyInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountyInfo *p;
	size_t k = sizeof(struct ns1__getCountyInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountyInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountyInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountyInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountyInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountyInfo(struct soap *soap, const struct ns1__getCountyInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountyInfo(soap, tag ? tag : "ns1:getCountyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountyInfo * SOAP_FMAC4 soap_get_ns1__getCountyInfo(struct soap *soap, struct ns1__getCountyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountyInfoResponse(struct soap *soap, struct ns1__getCountyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountyInfoResponse(struct soap *soap, const struct ns1__getCountyInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CountyInfo(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountyInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCountyInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountyInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CountyInfo(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountyInfoResponse * SOAP_FMAC4 soap_in_ns1__getCountyInfoResponse(struct soap *soap, const char *tag, struct ns1__getCountyInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountyInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountyInfoResponse, sizeof(struct ns1__getCountyInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountyInfoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CountyInfo(soap, "return", &a->return_, "ns1:CountyInfo"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountyInfoResponse, SOAP_TYPE_ns1__getCountyInfoResponse, sizeof(struct ns1__getCountyInfoResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountyInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountyInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountyInfoResponse *p;
	size_t k = sizeof(struct ns1__getCountyInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountyInfoResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountyInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountyInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountyInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountyInfoResponse(struct soap *soap, const struct ns1__getCountyInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountyInfoResponse(soap, tag ? tag : "ns1:getCountyInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountyInfoResponse * SOAP_FMAC4 soap_get_ns1__getCountyInfoResponse(struct soap *soap, struct ns1__getCountyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStateInfo(struct soap *soap, struct ns1__getStateInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->stid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStateInfo(struct soap *soap, const struct ns1__getStateInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStateInfo(struct soap *soap, const char *tag, int id, const struct ns1__getStateInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStateInfo), type))
		return soap->error;
	if (soap_out_int(soap, "stid", -1, &a->stid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStateInfo * SOAP_FMAC4 soap_in_ns1__getStateInfo(struct soap *soap, const char *tag, struct ns1__getStateInfo *a, const char *type)
{
	size_t soap_flag_stid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getStateInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStateInfo, sizeof(struct ns1__getStateInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getStateInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "stid", &a->stid, "xsd:int"))
				{	soap_flag_stid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getStateInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStateInfo, SOAP_TYPE_ns1__getStateInfo, sizeof(struct ns1__getStateInfo), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getStateInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getStateInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getStateInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getStateInfo *p;
	size_t k = sizeof(struct ns1__getStateInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getStateInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getStateInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getStateInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getStateInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStateInfo(struct soap *soap, const struct ns1__getStateInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getStateInfo(soap, tag ? tag : "ns1:getStateInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStateInfo * SOAP_FMAC4 soap_get_ns1__getStateInfo(struct soap *soap, struct ns1__getStateInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStateInfoResponse(struct soap *soap, struct ns1__getStateInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStateInfoResponse(struct soap *soap, const struct ns1__getStateInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__StateInfo(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStateInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getStateInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStateInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__StateInfo(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStateInfoResponse * SOAP_FMAC4 soap_in_ns1__getStateInfoResponse(struct soap *soap, const char *tag, struct ns1__getStateInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getStateInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStateInfoResponse, sizeof(struct ns1__getStateInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getStateInfoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__StateInfo(soap, "return", &a->return_, "ns1:StateInfo"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStateInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStateInfoResponse, SOAP_TYPE_ns1__getStateInfoResponse, sizeof(struct ns1__getStateInfoResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getStateInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getStateInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getStateInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getStateInfoResponse *p;
	size_t k = sizeof(struct ns1__getStateInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getStateInfoResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getStateInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getStateInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getStateInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStateInfoResponse(struct soap *soap, const struct ns1__getStateInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getStateInfoResponse(soap, tag ? tag : "ns1:getStateInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStateInfoResponse * SOAP_FMAC4 soap_get_ns1__getStateInfoResponse(struct soap *soap, struct ns1__getStateInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStateInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountryInfo(struct soap *soap, struct ns1__getCountryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->coid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountryInfo(struct soap *soap, const struct ns1__getCountryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountryInfo(struct soap *soap, const char *tag, int id, const struct ns1__getCountryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountryInfo), type))
		return soap->error;
	if (soap_out_int(soap, "coid", -1, &a->coid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountryInfo * SOAP_FMAC4 soap_in_ns1__getCountryInfo(struct soap *soap, const char *tag, struct ns1__getCountryInfo *a, const char *type)
{
	size_t soap_flag_coid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountryInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountryInfo, sizeof(struct ns1__getCountryInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountryInfo(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_coid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "coid", &a->coid, "xsd:int"))
				{	soap_flag_coid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_coid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getCountryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountryInfo, SOAP_TYPE_ns1__getCountryInfo, sizeof(struct ns1__getCountryInfo), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountryInfo * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountryInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountryInfo *p;
	size_t k = sizeof(struct ns1__getCountryInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountryInfo, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountryInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountryInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountryInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountryInfo(struct soap *soap, const struct ns1__getCountryInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountryInfo(soap, tag ? tag : "ns1:getCountryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountryInfo * SOAP_FMAC4 soap_get_ns1__getCountryInfo(struct soap *soap, struct ns1__getCountryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountryInfoResponse(struct soap *soap, struct ns1__getCountryInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountryInfoResponse(struct soap *soap, const struct ns1__getCountryInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__CountryInfo(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountryInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCountryInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountryInfoResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CountryInfo(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountryInfoResponse * SOAP_FMAC4 soap_in_ns1__getCountryInfoResponse(struct soap *soap, const char *tag, struct ns1__getCountryInfoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountryInfoResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountryInfoResponse, sizeof(struct ns1__getCountryInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountryInfoResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__CountryInfo(soap, "return", &a->return_, "ns1:CountryInfo"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountryInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountryInfoResponse, SOAP_TYPE_ns1__getCountryInfoResponse, sizeof(struct ns1__getCountryInfoResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountryInfoResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountryInfoResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountryInfoResponse *p;
	size_t k = sizeof(struct ns1__getCountryInfoResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountryInfoResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountryInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountryInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountryInfoResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountryInfoResponse(struct soap *soap, const struct ns1__getCountryInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountryInfoResponse(soap, tag ? tag : "ns1:getCountryInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountryInfoResponse * SOAP_FMAC4 soap_get_ns1__getCountryInfoResponse(struct soap *soap, struct ns1__getCountryInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountryInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountryList(struct soap *soap, struct ns1__getCountryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountryList(struct soap *soap, const struct ns1__getCountryList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountryList(struct soap *soap, const char *tag, int id, const struct ns1__getCountryList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountryList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountryList * SOAP_FMAC4 soap_in_ns1__getCountryList(struct soap *soap, const char *tag, struct ns1__getCountryList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountryList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountryList, sizeof(struct ns1__getCountryList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountryList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountryList, SOAP_TYPE_ns1__getCountryList, sizeof(struct ns1__getCountryList), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountryList * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountryList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountryList *p;
	size_t k = sizeof(struct ns1__getCountryList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountryList, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountryList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountryList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountryList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountryList(struct soap *soap, const struct ns1__getCountryList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountryList(soap, tag ? tag : "ns1:getCountryList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountryList * SOAP_FMAC4 soap_get_ns1__getCountryList(struct soap *soap, struct ns1__getCountryList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountryListResponse(struct soap *soap, struct ns1__getCountryListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountryListResponse(struct soap *soap, const struct ns1__getCountryListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToCountries(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountryListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCountryListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountryListResponse), type))
		return soap->error;
	if (soap_out_PointerToCountries(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountryListResponse * SOAP_FMAC4 soap_in_ns1__getCountryListResponse(struct soap *soap, const char *tag, struct ns1__getCountryListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountryListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountryListResponse, sizeof(struct ns1__getCountryListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountryListResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToCountries(soap, "return", &a->return_, "ns1:Country"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountryListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountryListResponse, SOAP_TYPE_ns1__getCountryListResponse, sizeof(struct ns1__getCountryListResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountryListResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountryListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountryListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountryListResponse *p;
	size_t k = sizeof(struct ns1__getCountryListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountryListResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountryListResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountryListResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountryListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountryListResponse(struct soap *soap, const struct ns1__getCountryListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountryListResponse(soap, tag ? tag : "ns1:getCountryListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountryListResponse * SOAP_FMAC4 soap_get_ns1__getCountryListResponse(struct soap *soap, struct ns1__getCountryListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountryListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsVoice(struct soap *soap, struct ns1__getTrsVoice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsVoice(struct soap *soap, const struct ns1__getTrsVoice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsVoice(struct soap *soap, const char *tag, int id, const struct ns1__getTrsVoice *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsVoice), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsVoice * SOAP_FMAC4 soap_in_ns1__getTrsVoice(struct soap *soap, const char *tag, struct ns1__getTrsVoice *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsVoice*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsVoice, sizeof(struct ns1__getTrsVoice), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsVoice(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsVoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsVoice, SOAP_TYPE_ns1__getTrsVoice, sizeof(struct ns1__getTrsVoice), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsVoice * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsVoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsVoice(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsVoice *p;
	size_t k = sizeof(struct ns1__getTrsVoice);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsVoice, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsVoice);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsVoice, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsVoice location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsVoice(struct soap *soap, const struct ns1__getTrsVoice *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsVoice(soap, tag ? tag : "ns1:getTrsVoice", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsVoice * SOAP_FMAC4 soap_get_ns1__getTrsVoice(struct soap *soap, struct ns1__getTrsVoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsVoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsVoiceResponse(struct soap *soap, struct ns1__getTrsVoiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsVoiceResponse(struct soap *soap, const struct ns1__getTrsVoiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTrsVoice(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsVoiceResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsVoiceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsVoiceResponse), type))
		return soap->error;
	if (soap_out_PointerToTrsVoice(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsVoiceResponse * SOAP_FMAC4 soap_in_ns1__getTrsVoiceResponse(struct soap *soap, const char *tag, struct ns1__getTrsVoiceResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsVoiceResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsVoiceResponse, sizeof(struct ns1__getTrsVoiceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsVoiceResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsVoice(soap, "return", &a->return_, "ns1:trsVoiceDef"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsVoiceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsVoiceResponse, SOAP_TYPE_ns1__getTrsVoiceResponse, sizeof(struct ns1__getTrsVoiceResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsVoiceResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsVoiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsVoiceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsVoiceResponse *p;
	size_t k = sizeof(struct ns1__getTrsVoiceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsVoiceResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsVoiceResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsVoiceResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsVoiceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsVoiceResponse(struct soap *soap, const struct ns1__getTrsVoiceResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsVoiceResponse(soap, tag ? tag : "ns1:getTrsVoiceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsVoiceResponse * SOAP_FMAC4 soap_get_ns1__getTrsVoiceResponse(struct soap *soap, struct ns1__getTrsVoiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsVoiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsFlavor(struct soap *soap, struct ns1__getTrsFlavor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsFlavor(struct soap *soap, const struct ns1__getTrsFlavor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsFlavor(struct soap *soap, const char *tag, int id, const struct ns1__getTrsFlavor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsFlavor), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsFlavor * SOAP_FMAC4 soap_in_ns1__getTrsFlavor(struct soap *soap, const char *tag, struct ns1__getTrsFlavor *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsFlavor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsFlavor, sizeof(struct ns1__getTrsFlavor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsFlavor(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsFlavor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsFlavor, SOAP_TYPE_ns1__getTrsFlavor, sizeof(struct ns1__getTrsFlavor), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsFlavor * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsFlavor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsFlavor(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsFlavor *p;
	size_t k = sizeof(struct ns1__getTrsFlavor);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsFlavor, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsFlavor);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsFlavor, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsFlavor location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsFlavor(struct soap *soap, const struct ns1__getTrsFlavor *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsFlavor(soap, tag ? tag : "ns1:getTrsFlavor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsFlavor * SOAP_FMAC4 soap_get_ns1__getTrsFlavor(struct soap *soap, struct ns1__getTrsFlavor *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsFlavor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsFlavorResponse(struct soap *soap, struct ns1__getTrsFlavorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsFlavorResponse(struct soap *soap, const struct ns1__getTrsFlavorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTrsFlavor(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsFlavorResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsFlavorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsFlavorResponse), type))
		return soap->error;
	if (soap_out_PointerToTrsFlavor(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsFlavorResponse * SOAP_FMAC4 soap_in_ns1__getTrsFlavorResponse(struct soap *soap, const char *tag, struct ns1__getTrsFlavorResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsFlavorResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsFlavorResponse, sizeof(struct ns1__getTrsFlavorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsFlavorResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsFlavor(soap, "return", &a->return_, "ns1:trsFlavorDef"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsFlavorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsFlavorResponse, SOAP_TYPE_ns1__getTrsFlavorResponse, sizeof(struct ns1__getTrsFlavorResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsFlavorResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsFlavorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsFlavorResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsFlavorResponse *p;
	size_t k = sizeof(struct ns1__getTrsFlavorResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsFlavorResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsFlavorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsFlavorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsFlavorResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsFlavorResponse(struct soap *soap, const struct ns1__getTrsFlavorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsFlavorResponse(soap, tag ? tag : "ns1:getTrsFlavorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsFlavorResponse * SOAP_FMAC4 soap_get_ns1__getTrsFlavorResponse(struct soap *soap, struct ns1__getTrsFlavorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsFlavorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsType(struct soap *soap, struct ns1__getTrsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsType(struct soap *soap, const struct ns1__getTrsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsType(struct soap *soap, const char *tag, int id, const struct ns1__getTrsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsType), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsType * SOAP_FMAC4 soap_in_ns1__getTrsType(struct soap *soap, const char *tag, struct ns1__getTrsType *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsType, sizeof(struct ns1__getTrsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsType, SOAP_TYPE_ns1__getTrsType, sizeof(struct ns1__getTrsType), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsType * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsType *p;
	size_t k = sizeof(struct ns1__getTrsType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsType, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsType(struct soap *soap, const struct ns1__getTrsType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsType(soap, tag ? tag : "ns1:getTrsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsType * SOAP_FMAC4 soap_get_ns1__getTrsType(struct soap *soap, struct ns1__getTrsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsTypeResponse(struct soap *soap, struct ns1__getTrsTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsTypeResponse(struct soap *soap, const struct ns1__getTrsTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTrsType(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsTypeResponse), type))
		return soap->error;
	if (soap_out_PointerToTrsType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsTypeResponse * SOAP_FMAC4 soap_in_ns1__getTrsTypeResponse(struct soap *soap, const char *tag, struct ns1__getTrsTypeResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsTypeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsTypeResponse, sizeof(struct ns1__getTrsTypeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsTypeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsType(soap, "return", &a->return_, "ns1:trsTypeDef"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsTypeResponse, SOAP_TYPE_ns1__getTrsTypeResponse, sizeof(struct ns1__getTrsTypeResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsTypeResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsTypeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsTypeResponse *p;
	size_t k = sizeof(struct ns1__getTrsTypeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsTypeResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsTypeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsTypeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsTypeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsTypeResponse(struct soap *soap, const struct ns1__getTrsTypeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsTypeResponse(soap, tag ? tag : "ns1:getTrsTypeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsTypeResponse * SOAP_FMAC4 soap_get_ns1__getTrsTypeResponse(struct soap *soap, struct ns1__getTrsTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getMode(struct soap *soap, struct ns1__getMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->mode);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getMode(struct soap *soap, const struct ns1__getMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMode(struct soap *soap, const char *tag, int id, const struct ns1__getMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMode), type))
		return soap->error;
	if (soap_out_int(soap, "mode", -1, &a->mode, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getMode * SOAP_FMAC4 soap_in_ns1__getMode(struct soap *soap, const char *tag, struct ns1__getMode *a, const char *type)
{
	size_t soap_flag_mode = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMode, sizeof(struct ns1__getMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getMode(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "mode", &a->mode, "xsd:int"))
				{	soap_flag_mode--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMode, SOAP_TYPE_ns1__getMode, sizeof(struct ns1__getMode), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getMode * SOAP_FMAC2 rrapi__instantiate_ns1__getMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getMode *p;
	size_t k = sizeof(struct ns1__getMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getMode, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getMode(struct soap *soap, const struct ns1__getMode *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getMode(soap, tag ? tag : "ns1:getMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getMode * SOAP_FMAC4 soap_get_ns1__getMode(struct soap *soap, struct ns1__getMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getModeResponse(struct soap *soap, struct ns1__getModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getModeResponse(struct soap *soap, const struct ns1__getModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTomodes(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getModeResponse(struct soap *soap, const char *tag, int id, const struct ns1__getModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getModeResponse), type))
		return soap->error;
	if (soap_out_PointerTomodes(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getModeResponse * SOAP_FMAC4 soap_in_ns1__getModeResponse(struct soap *soap, const char *tag, struct ns1__getModeResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getModeResponse, sizeof(struct ns1__getModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getModeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTomodes(soap, "return", &a->return_, "ns1:mode"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getModeResponse, SOAP_TYPE_ns1__getModeResponse, sizeof(struct ns1__getModeResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getModeResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getModeResponse *p;
	size_t k = sizeof(struct ns1__getModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getModeResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getModeResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getModeResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getModeResponse(struct soap *soap, const struct ns1__getModeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getModeResponse(soap, tag ? tag : "ns1:getModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getModeResponse * SOAP_FMAC4 soap_get_ns1__getModeResponse(struct soap *soap, struct ns1__getModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTag(struct soap *soap, struct ns1__getTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTag(struct soap *soap, const struct ns1__getTag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTag(struct soap *soap, const char *tag, int id, const struct ns1__getTag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTag), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTag * SOAP_FMAC4 soap_in_ns1__getTag(struct soap *soap, const char *tag, struct ns1__getTag *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTag*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTag, sizeof(struct ns1__getTag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTag(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTag, SOAP_TYPE_ns1__getTag, sizeof(struct ns1__getTag), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTag * SOAP_FMAC2 rrapi__instantiate_ns1__getTag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTag(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTag *p;
	size_t k = sizeof(struct ns1__getTag);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTag, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTag);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTag, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTag location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTag(struct soap *soap, const struct ns1__getTag *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTag(soap, tag ? tag : "ns1:getTag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTag * SOAP_FMAC4 soap_get_ns1__getTag(struct soap *soap, struct ns1__getTag *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTagResponse(struct soap *soap, struct ns1__getTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTagResponse(struct soap *soap, const struct ns1__getTagResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotags(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTagResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTagResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTagResponse), type))
		return soap->error;
	if (soap_out_PointerTotags(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTagResponse * SOAP_FMAC4 soap_in_ns1__getTagResponse(struct soap *soap, const char *tag, struct ns1__getTagResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTagResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTagResponse, sizeof(struct ns1__getTagResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTagResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotags(soap, "return", &a->return_, "ns1:tag"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTagResponse, SOAP_TYPE_ns1__getTagResponse, sizeof(struct ns1__getTagResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTagResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTagResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTagResponse *p;
	size_t k = sizeof(struct ns1__getTagResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTagResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTagResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTagResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTagResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTagResponse(struct soap *soap, const struct ns1__getTagResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTagResponse(soap, tag ? tag : "ns1:getTagResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTagResponse * SOAP_FMAC4 soap_get_ns1__getTagResponse(struct soap *soap, struct ns1__getTagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountiesByList(struct soap *soap, struct ns1__getCountiesByList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request = NULL;
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountiesByList(struct soap *soap, const struct ns1__getCountiesByList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToctidList(soap, &a->request);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountiesByList(struct soap *soap, const char *tag, int id, const struct ns1__getCountiesByList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountiesByList), type))
		return soap->error;
	if (soap_out_PointerToctidList(soap, "request", -1, &a->request, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountiesByList * SOAP_FMAC4 soap_in_ns1__getCountiesByList(struct soap *soap, const char *tag, struct ns1__getCountiesByList *a, const char *type)
{
	size_t soap_flag_request = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountiesByList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountiesByList, sizeof(struct ns1__getCountiesByList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountiesByList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToctidList(soap, "request", &a->request, "ns1:ctid"))
				{	soap_flag_request--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountiesByList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountiesByList, SOAP_TYPE_ns1__getCountiesByList, sizeof(struct ns1__getCountiesByList), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountiesByList * SOAP_FMAC2 rrapi__instantiate_ns1__getCountiesByList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountiesByList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountiesByList *p;
	size_t k = sizeof(struct ns1__getCountiesByList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountiesByList, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountiesByList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountiesByList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountiesByList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountiesByList(struct soap *soap, const struct ns1__getCountiesByList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountiesByList(soap, tag ? tag : "ns1:getCountiesByList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountiesByList * SOAP_FMAC4 soap_get_ns1__getCountiesByList(struct soap *soap, struct ns1__getCountiesByList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountiesByList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCountiesByListResponse(struct soap *soap, struct ns1__getCountiesByListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCountiesByListResponse(struct soap *soap, const struct ns1__getCountiesByListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToCounties(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCountiesByListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCountiesByListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCountiesByListResponse), type))
		return soap->error;
	if (soap_out_PointerToCounties(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCountiesByListResponse * SOAP_FMAC4 soap_in_ns1__getCountiesByListResponse(struct soap *soap, const char *tag, struct ns1__getCountiesByListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getCountiesByListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCountiesByListResponse, sizeof(struct ns1__getCountiesByListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCountiesByListResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToCounties(soap, "return", &a->return_, "ns1:County"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCountiesByListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCountiesByListResponse, SOAP_TYPE_ns1__getCountiesByListResponse, sizeof(struct ns1__getCountiesByListResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getCountiesByListResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getCountiesByListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getCountiesByListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getCountiesByListResponse *p;
	size_t k = sizeof(struct ns1__getCountiesByListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getCountiesByListResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getCountiesByListResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getCountiesByListResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getCountiesByListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCountiesByListResponse(struct soap *soap, const struct ns1__getCountiesByListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getCountiesByListResponse(soap, tag ? tag : "ns1:getCountiesByListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCountiesByListResponse * SOAP_FMAC4 soap_get_ns1__getCountiesByListResponse(struct soap *soap, struct ns1__getCountiesByListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCountiesByListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStatesByList(struct soap *soap, struct ns1__getStatesByList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->request = NULL;
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStatesByList(struct soap *soap, const struct ns1__getStatesByList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostidList(soap, &a->request);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStatesByList(struct soap *soap, const char *tag, int id, const struct ns1__getStatesByList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStatesByList), type))
		return soap->error;
	if (soap_out_PointerTostidList(soap, "request", -1, &a->request, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStatesByList * SOAP_FMAC4 soap_in_ns1__getStatesByList(struct soap *soap, const char *tag, struct ns1__getStatesByList *a, const char *type)
{
	size_t soap_flag_request = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getStatesByList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStatesByList, sizeof(struct ns1__getStatesByList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getStatesByList(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_request && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostidList(soap, "request", &a->request, "ns1:stid"))
				{	soap_flag_request--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStatesByList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStatesByList, SOAP_TYPE_ns1__getStatesByList, sizeof(struct ns1__getStatesByList), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getStatesByList * SOAP_FMAC2 rrapi__instantiate_ns1__getStatesByList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getStatesByList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getStatesByList *p;
	size_t k = sizeof(struct ns1__getStatesByList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getStatesByList, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getStatesByList);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getStatesByList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getStatesByList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStatesByList(struct soap *soap, const struct ns1__getStatesByList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getStatesByList(soap, tag ? tag : "ns1:getStatesByList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStatesByList * SOAP_FMAC4 soap_get_ns1__getStatesByList(struct soap *soap, struct ns1__getStatesByList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStatesByList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getStatesByListResponse(struct soap *soap, struct ns1__getStatesByListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getStatesByListResponse(struct soap *soap, const struct ns1__getStatesByListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToStates(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getStatesByListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getStatesByListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getStatesByListResponse), type))
		return soap->error;
	if (soap_out_PointerToStates(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getStatesByListResponse * SOAP_FMAC4 soap_in_ns1__getStatesByListResponse(struct soap *soap, const char *tag, struct ns1__getStatesByListResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getStatesByListResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getStatesByListResponse, sizeof(struct ns1__getStatesByListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getStatesByListResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToStates(soap, "return", &a->return_, "ns1:State"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getStatesByListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getStatesByListResponse, SOAP_TYPE_ns1__getStatesByListResponse, sizeof(struct ns1__getStatesByListResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getStatesByListResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getStatesByListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getStatesByListResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getStatesByListResponse *p;
	size_t k = sizeof(struct ns1__getStatesByListResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getStatesByListResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getStatesByListResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getStatesByListResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getStatesByListResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getStatesByListResponse(struct soap *soap, const struct ns1__getStatesByListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getStatesByListResponse(soap, tag ? tag : "ns1:getStatesByListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getStatesByListResponse * SOAP_FMAC4 soap_get_ns1__getStatesByListResponse(struct soap *soap, struct ns1__getStatesByListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getStatesByListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsSites(struct soap *soap, struct ns1__getTrsSites *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsSites(struct soap *soap, const struct ns1__getTrsSites *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsSites(struct soap *soap, const char *tag, int id, const struct ns1__getTrsSites *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsSites), type))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->sid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsSites * SOAP_FMAC4 soap_in_ns1__getTrsSites(struct soap *soap, const char *tag, struct ns1__getTrsSites *a, const char *type)
{
	size_t soap_flag_sid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsSites*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsSites, sizeof(struct ns1__getTrsSites), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsSites(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->sid, "xsd:int"))
				{	soap_flag_sid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsSites *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsSites, SOAP_TYPE_ns1__getTrsSites, sizeof(struct ns1__getTrsSites), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsSites * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsSites(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsSites(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsSites *p;
	size_t k = sizeof(struct ns1__getTrsSites);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsSites, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsSites);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsSites, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsSites location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsSites(struct soap *soap, const struct ns1__getTrsSites *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsSites(soap, tag ? tag : "ns1:getTrsSites", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsSites * SOAP_FMAC4 soap_get_ns1__getTrsSites(struct soap *soap, struct ns1__getTrsSites *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsSites(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsSitesResponse(struct soap *soap, struct ns1__getTrsSitesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsSitesResponse(struct soap *soap, const struct ns1__getTrsSitesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTrsSites(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsSitesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsSitesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsSitesResponse), type))
		return soap->error;
	if (soap_out_PointerToTrsSites(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsSitesResponse * SOAP_FMAC4 soap_in_ns1__getTrsSitesResponse(struct soap *soap, const char *tag, struct ns1__getTrsSitesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsSitesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsSitesResponse, sizeof(struct ns1__getTrsSitesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsSitesResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsSites(soap, "return", &a->return_, "ns1:TrsSite"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsSitesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsSitesResponse, SOAP_TYPE_ns1__getTrsSitesResponse, sizeof(struct ns1__getTrsSitesResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsSitesResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsSitesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsSitesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsSitesResponse *p;
	size_t k = sizeof(struct ns1__getTrsSitesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsSitesResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsSitesResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsSitesResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsSitesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsSitesResponse(struct soap *soap, const struct ns1__getTrsSitesResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsSitesResponse(soap, tag ? tag : "ns1:getTrsSitesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsSitesResponse * SOAP_FMAC4 soap_get_ns1__getTrsSitesResponse(struct soap *soap, struct ns1__getTrsSitesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsSitesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsBySysid(struct soap *soap, struct ns1__getTrsBySysid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->sysid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsBySysid(struct soap *soap, const struct ns1__getTrsBySysid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__string(soap, &a->sysid);
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsBySysid(struct soap *soap, const char *tag, int id, const struct ns1__getTrsBySysid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsBySysid), type))
		return soap->error;
	if (soap_out_std__string(soap, "sysid", -1, &a->sysid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsBySysid * SOAP_FMAC4 soap_in_ns1__getTrsBySysid(struct soap *soap, const char *tag, struct ns1__getTrsBySysid *a, const char *type)
{
	size_t soap_flag_sysid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsBySysid*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsBySysid, sizeof(struct ns1__getTrsBySysid), soap->type, soap->arrayType, rrapi__instantiate, rrapi__fbase);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsBySysid(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sysid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "sysid", &a->sysid, "xsd:string"))
				{	soap_flag_sysid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sysid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsBySysid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsBySysid, SOAP_TYPE_ns1__getTrsBySysid, sizeof(struct ns1__getTrsBySysid), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsBySysid * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsBySysid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsBySysid(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsBySysid *p;
	size_t k = sizeof(struct ns1__getTrsBySysid);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsBySysid, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsBySysid);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsBySysid, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsBySysid location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsBySysid(struct soap *soap, const struct ns1__getTrsBySysid *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsBySysid(soap, tag ? tag : "ns1:getTrsBySysid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsBySysid * SOAP_FMAC4 soap_get_ns1__getTrsBySysid(struct soap *soap, struct ns1__getTrsBySysid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsBySysid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsBySysidResponse(struct soap *soap, struct ns1__getTrsBySysidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsBySysidResponse(struct soap *soap, const struct ns1__getTrsBySysidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTrsList(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsBySysidResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsBySysidResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsBySysidResponse), type))
		return soap->error;
	if (soap_out_PointerToTrsList(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsBySysidResponse * SOAP_FMAC4 soap_in_ns1__getTrsBySysidResponse(struct soap *soap, const char *tag, struct ns1__getTrsBySysidResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsBySysidResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsBySysidResponse, sizeof(struct ns1__getTrsBySysidResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsBySysidResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTrsList(soap, "return", &a->return_, "ns1:TrsListDef"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsBySysidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsBySysidResponse, SOAP_TYPE_ns1__getTrsBySysidResponse, sizeof(struct ns1__getTrsBySysidResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsBySysidResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsBySysidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsBySysidResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsBySysidResponse *p;
	size_t k = sizeof(struct ns1__getTrsBySysidResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsBySysidResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsBySysidResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsBySysidResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsBySysidResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsBySysidResponse(struct soap *soap, const struct ns1__getTrsBySysidResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsBySysidResponse(soap, tag ? tag : "ns1:getTrsBySysidResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsBySysidResponse * SOAP_FMAC4 soap_get_ns1__getTrsBySysidResponse(struct soap *soap, struct ns1__getTrsBySysidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsBySysidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsDetails(struct soap *soap, struct ns1__getTrsDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsDetails(struct soap *soap, const struct ns1__getTrsDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsDetails(struct soap *soap, const char *tag, int id, const struct ns1__getTrsDetails *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsDetails), type))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->sid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsDetails * SOAP_FMAC4 soap_in_ns1__getTrsDetails(struct soap *soap, const char *tag, struct ns1__getTrsDetails *a, const char *type)
{
	size_t soap_flag_sid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsDetails*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsDetails, sizeof(struct ns1__getTrsDetails), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsDetails(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->sid, "xsd:int"))
				{	soap_flag_sid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsDetails, SOAP_TYPE_ns1__getTrsDetails, sizeof(struct ns1__getTrsDetails), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsDetails * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsDetails(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsDetails(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsDetails *p;
	size_t k = sizeof(struct ns1__getTrsDetails);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsDetails, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsDetails);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsDetails, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsDetails location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsDetails(struct soap *soap, const struct ns1__getTrsDetails *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsDetails(soap, tag ? tag : "ns1:getTrsDetails", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsDetails * SOAP_FMAC4 soap_get_ns1__getTrsDetails(struct soap *soap, struct ns1__getTrsDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsDetailsResponse(struct soap *soap, struct ns1__getTrsDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsDetailsResponse(struct soap *soap, const struct ns1__getTrsDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Trs(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsDetailsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsDetailsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsDetailsResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__Trs(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsDetailsResponse * SOAP_FMAC4 soap_in_ns1__getTrsDetailsResponse(struct soap *soap, const char *tag, struct ns1__getTrsDetailsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsDetailsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsDetailsResponse, sizeof(struct ns1__getTrsDetailsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsDetailsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__Trs(soap, "return", &a->return_, "ns1:Trs"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsDetailsResponse, SOAP_TYPE_ns1__getTrsDetailsResponse, sizeof(struct ns1__getTrsDetailsResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsDetailsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsDetailsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsDetailsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsDetailsResponse *p;
	size_t k = sizeof(struct ns1__getTrsDetailsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsDetailsResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsDetailsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsDetailsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsDetailsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsDetailsResponse(struct soap *soap, const struct ns1__getTrsDetailsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsDetailsResponse(soap, tag ? tag : "ns1:getTrsDetailsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsDetailsResponse * SOAP_FMAC4 soap_get_ns1__getTrsDetailsResponse(struct soap *soap, struct ns1__getTrsDetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsTalkgroupCats(struct soap *soap, struct ns1__getTrsTalkgroupCats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sid);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsTalkgroupCats(struct soap *soap, const struct ns1__getTrsTalkgroupCats *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsTalkgroupCats(struct soap *soap, const char *tag, int id, const struct ns1__getTrsTalkgroupCats *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsTalkgroupCats), type))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->sid, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroupCats * SOAP_FMAC4 soap_in_ns1__getTrsTalkgroupCats(struct soap *soap, const char *tag, struct ns1__getTrsTalkgroupCats *a, const char *type)
{
	size_t soap_flag_sid = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsTalkgroupCats*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsTalkgroupCats, sizeof(struct ns1__getTrsTalkgroupCats), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsTalkgroupCats(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->sid, "xsd:int"))
				{	soap_flag_sid--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsTalkgroupCats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsTalkgroupCats, SOAP_TYPE_ns1__getTrsTalkgroupCats, sizeof(struct ns1__getTrsTalkgroupCats), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsTalkgroupCats * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroupCats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsTalkgroupCats(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsTalkgroupCats *p;
	size_t k = sizeof(struct ns1__getTrsTalkgroupCats);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsTalkgroupCats, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsTalkgroupCats);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsTalkgroupCats, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsTalkgroupCats location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsTalkgroupCats(struct soap *soap, const struct ns1__getTrsTalkgroupCats *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsTalkgroupCats(soap, tag ? tag : "ns1:getTrsTalkgroupCats", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroupCats * SOAP_FMAC4 soap_get_ns1__getTrsTalkgroupCats(struct soap *soap, struct ns1__getTrsTalkgroupCats *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsTalkgroupCats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, struct ns1__getTrsTalkgroupCatsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, const struct ns1__getTrsTalkgroupCatsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTalkgroupCats(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsTalkgroupCatsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse), type))
		return soap->error;
	if (soap_out_PointerToTalkgroupCats(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroupCatsResponse * SOAP_FMAC4 soap_in_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, const char *tag, struct ns1__getTrsTalkgroupCatsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsTalkgroupCatsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse, sizeof(struct ns1__getTrsTalkgroupCatsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsTalkgroupCatsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTalkgroupCats(soap, "return", &a->return_, "ns1:TalkgroupCat"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsTalkgroupCatsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse, SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse, sizeof(struct ns1__getTrsTalkgroupCatsResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsTalkgroupCatsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsTalkgroupCatsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsTalkgroupCatsResponse *p;
	size_t k = sizeof(struct ns1__getTrsTalkgroupCatsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsTalkgroupCatsResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsTalkgroupCatsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsTalkgroupCatsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsTalkgroupCatsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, const struct ns1__getTrsTalkgroupCatsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsTalkgroupCatsResponse(soap, tag ? tag : "ns1:getTrsTalkgroupCatsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroupCatsResponse * SOAP_FMAC4 soap_get_ns1__getTrsTalkgroupCatsResponse(struct soap *soap, struct ns1__getTrsTalkgroupCatsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsTalkgroupCatsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsTalkgroups(struct soap *soap, struct ns1__getTrsTalkgroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->sid);
	soap_default_int(soap, &a->tgCid);
	soap_default_int(soap, &a->tgTag);
	soap_default_int(soap, &a->tgDec);
	a->authInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsTalkgroups(struct soap *soap, const struct ns1__getTrsTalkgroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__authInfo(soap, &a->authInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsTalkgroups(struct soap *soap, const char *tag, int id, const struct ns1__getTrsTalkgroups *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsTalkgroups), type))
		return soap->error;
	if (soap_out_int(soap, "sid", -1, &a->sid, ""))
		return soap->error;
	if (soap_out_int(soap, "tgCid", -1, &a->tgCid, ""))
		return soap->error;
	if (soap_out_int(soap, "tgTag", -1, &a->tgTag, ""))
		return soap->error;
	if (soap_out_int(soap, "tgDec", -1, &a->tgDec, ""))
		return soap->error;
	if (soap_out_PointerTons1__authInfo(soap, "authInfo", -1, &a->authInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroups * SOAP_FMAC4 soap_in_ns1__getTrsTalkgroups(struct soap *soap, const char *tag, struct ns1__getTrsTalkgroups *a, const char *type)
{
	size_t soap_flag_sid = 1;
	size_t soap_flag_tgCid = 1;
	size_t soap_flag_tgTag = 1;
	size_t soap_flag_tgDec = 1;
	size_t soap_flag_authInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsTalkgroups*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsTalkgroups, sizeof(struct ns1__getTrsTalkgroups), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsTalkgroups(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "sid", &a->sid, "xsd:int"))
				{	soap_flag_sid--;
					continue;
				}
			}
			if (soap_flag_tgCid && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgCid", &a->tgCid, "xsd:int"))
				{	soap_flag_tgCid--;
					continue;
				}
			}
			if (soap_flag_tgTag && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgTag", &a->tgTag, "xsd:int"))
				{	soap_flag_tgTag--;
					continue;
				}
			}
			if (soap_flag_tgDec && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tgDec", &a->tgDec, "xsd:int"))
				{	soap_flag_tgDec--;
					continue;
				}
			}
			if (soap_flag_authInfo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTons1__authInfo(soap, "authInfo", &a->authInfo, "ns1:authInfo"))
				{	soap_flag_authInfo--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sid > 0 || soap_flag_tgCid > 0 || soap_flag_tgTag > 0 || soap_flag_tgDec > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getTrsTalkgroups *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsTalkgroups, SOAP_TYPE_ns1__getTrsTalkgroups, sizeof(struct ns1__getTrsTalkgroups), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsTalkgroups * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroups(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsTalkgroups(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsTalkgroups *p;
	size_t k = sizeof(struct ns1__getTrsTalkgroups);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsTalkgroups, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsTalkgroups);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsTalkgroups, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsTalkgroups location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsTalkgroups(struct soap *soap, const struct ns1__getTrsTalkgroups *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsTalkgroups(soap, tag ? tag : "ns1:getTrsTalkgroups", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroups * SOAP_FMAC4 soap_get_ns1__getTrsTalkgroups(struct soap *soap, struct ns1__getTrsTalkgroups *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsTalkgroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTrsTalkgroupsResponse(struct soap *soap, struct ns1__getTrsTalkgroupsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTrsTalkgroupsResponse(struct soap *soap, const struct ns1__getTrsTalkgroupsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToTalkgroups(soap, &a->return_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTrsTalkgroupsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTrsTalkgroupsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTrsTalkgroupsResponse), type))
		return soap->error;
	if (soap_out_PointerToTalkgroups(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroupsResponse * SOAP_FMAC4 soap_in_ns1__getTrsTalkgroupsResponse(struct soap *soap, const char *tag, struct ns1__getTrsTalkgroupsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct ns1__getTrsTalkgroupsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTrsTalkgroupsResponse, sizeof(struct ns1__getTrsTalkgroupsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTrsTalkgroupsResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToTalkgroups(soap, "return", &a->return_, "ns1:Talkgroup"))
				{	soap_flag_return_--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTrsTalkgroupsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTrsTalkgroupsResponse, SOAP_TYPE_ns1__getTrsTalkgroupsResponse, sizeof(struct ns1__getTrsTalkgroupsResponse), 0, rrapi__finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getTrsTalkgroupsResponse * SOAP_FMAC2 rrapi__instantiate_ns1__getTrsTalkgroupsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "rrapi__instantiate_ns1__getTrsTalkgroupsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getTrsTalkgroupsResponse *p;
	size_t k = sizeof(struct ns1__getTrsTalkgroupsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_ns1__getTrsTalkgroupsResponse, n, rrapi__fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct ns1__getTrsTalkgroupsResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct ns1__getTrsTalkgroupsResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getTrsTalkgroupsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTrsTalkgroupsResponse(struct soap *soap, const struct ns1__getTrsTalkgroupsResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getTrsTalkgroupsResponse(soap, tag ? tag : "ns1:getTrsTalkgroupsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTrsTalkgroupsResponse * SOAP_FMAC4 soap_get_ns1__getTrsTalkgroupsResponse(struct soap *soap, struct ns1__getTrsTalkgroupsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTrsTalkgroupsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTouserFeedBroadcasts(struct soap *soap, userFeedBroadcasts *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTouserFeedBroadcasts(struct soap *soap, const char *tag, int id, userFeedBroadcasts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_userFeedBroadcasts, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_userFeedBroadcasts ? type : NULL);
}

SOAP_FMAC3 userFeedBroadcasts ** SOAP_FMAC4 soap_in_PointerTouserFeedBroadcasts(struct soap *soap, const char *tag, userFeedBroadcasts **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (userFeedBroadcasts **)soap_malloc(soap, sizeof(userFeedBroadcasts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (userFeedBroadcasts *)rrapi__instantiate_userFeedBroadcasts(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (userFeedBroadcasts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_userFeedBroadcasts, sizeof(userFeedBroadcasts), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTouserFeedBroadcasts(struct soap *soap, userFeedBroadcasts *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTouserFeedBroadcasts(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 userFeedBroadcasts ** SOAP_FMAC4 soap_get_PointerTouserFeedBroadcasts(struct soap *soap, userFeedBroadcasts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTouserFeedBroadcasts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserInfo(struct soap *soap, const char *tag, int id, ns1__UserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__UserInfo ? type : NULL);
}

SOAP_FMAC3 ns1__UserInfo ** SOAP_FMAC4 soap_in_PointerTons1__UserInfo(struct soap *soap, const char *tag, ns1__UserInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserInfo **)soap_malloc(soap, sizeof(ns1__UserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserInfo *)rrapi__instantiate_ns1__UserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__UserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserInfo, sizeof(ns1__UserInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__UserInfo(soap, tag ? tag : "ns1:UserInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__UserInfo ** SOAP_FMAC4 soap_get_PointerTons1__UserInfo(struct soap *soap, ns1__UserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToproxCallsignResults(struct soap *soap, proxCallsignResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToproxCallsignResults(struct soap *soap, const char *tag, int id, proxCallsignResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_proxCallsignResults, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_proxCallsignResults ? type : NULL);
}

SOAP_FMAC3 proxCallsignResults ** SOAP_FMAC4 soap_in_PointerToproxCallsignResults(struct soap *soap, const char *tag, proxCallsignResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (proxCallsignResults **)soap_malloc(soap, sizeof(proxCallsignResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (proxCallsignResults *)rrapi__instantiate_proxCallsignResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (proxCallsignResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_proxCallsignResults, sizeof(proxCallsignResults), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToproxCallsignResults(struct soap *soap, proxCallsignResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToproxCallsignResults(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 proxCallsignResults ** SOAP_FMAC4 soap_get_PointerToproxCallsignResults(struct soap *soap, proxCallsignResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToproxCallsignResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofccRadioServiceCodes(struct soap *soap, fccRadioServiceCodes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofccRadioServiceCodes(struct soap *soap, const char *tag, int id, fccRadioServiceCodes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_fccRadioServiceCodes, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_fccRadioServiceCodes ? type : NULL);
}

SOAP_FMAC3 fccRadioServiceCodes ** SOAP_FMAC4 soap_in_PointerTofccRadioServiceCodes(struct soap *soap, const char *tag, fccRadioServiceCodes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fccRadioServiceCodes **)soap_malloc(soap, sizeof(fccRadioServiceCodes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fccRadioServiceCodes *)rrapi__instantiate_fccRadioServiceCodes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (fccRadioServiceCodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fccRadioServiceCodes, sizeof(fccRadioServiceCodes), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofccRadioServiceCodes(struct soap *soap, fccRadioServiceCodes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofccRadioServiceCodes(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fccRadioServiceCodes ** SOAP_FMAC4 soap_get_PointerTofccRadioServiceCodes(struct soap *soap, fccRadioServiceCodes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofccRadioServiceCodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fccCallsignDetails(struct soap *soap, ns1__fccCallsignDetails *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fccCallsignDetails))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fccCallsignDetails(struct soap *soap, const char *tag, int id, ns1__fccCallsignDetails *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fccCallsignDetails, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__fccCallsignDetails ? type : NULL);
}

SOAP_FMAC3 ns1__fccCallsignDetails ** SOAP_FMAC4 soap_in_PointerTons1__fccCallsignDetails(struct soap *soap, const char *tag, ns1__fccCallsignDetails **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccCallsignDetails **)soap_malloc(soap, sizeof(ns1__fccCallsignDetails *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fccCallsignDetails *)rrapi__instantiate_ns1__fccCallsignDetails(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__fccCallsignDetails **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccCallsignDetails, sizeof(ns1__fccCallsignDetails), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fccCallsignDetails(struct soap *soap, ns1__fccCallsignDetails *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__fccCallsignDetails(soap, tag ? tag : "ns1:fccCallsignDetails", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccCallsignDetails ** SOAP_FMAC4 soap_get_PointerTons1__fccCallsignDetails(struct soap *soap, ns1__fccCallsignDetails **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fccCallsignDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ZipInfo(struct soap *soap, ns1__ZipInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ZipInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ZipInfo(struct soap *soap, const char *tag, int id, ns1__ZipInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ZipInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ZipInfo ? type : NULL);
}

SOAP_FMAC3 ns1__ZipInfo ** SOAP_FMAC4 soap_in_PointerTons1__ZipInfo(struct soap *soap, const char *tag, ns1__ZipInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ZipInfo **)soap_malloc(soap, sizeof(ns1__ZipInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ZipInfo *)rrapi__instantiate_ns1__ZipInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ZipInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ZipInfo, sizeof(ns1__ZipInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ZipInfo(struct soap *soap, ns1__ZipInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ZipInfo(soap, tag ? tag : "ns1:ZipInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ZipInfo ** SOAP_FMAC4 soap_get_PointerTons1__ZipInfo(struct soap *soap, ns1__ZipInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ZipInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToMetros(struct soap *soap, Metros *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToMetros(struct soap *soap, const char *tag, int id, Metros *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Metros, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Metros ? type : NULL);
}

SOAP_FMAC3 Metros ** SOAP_FMAC4 soap_in_PointerToMetros(struct soap *soap, const char *tag, Metros **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Metros **)soap_malloc(soap, sizeof(Metros *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Metros *)rrapi__instantiate_Metros(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Metros **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Metros, sizeof(Metros), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToMetros(struct soap *soap, Metros *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToMetros(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Metros ** SOAP_FMAC4 soap_get_PointerToMetros(struct soap *soap, Metros **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToMetros(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosearchFreqResults(struct soap *soap, searchFreqResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosearchFreqResults(struct soap *soap, const char *tag, int id, searchFreqResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_searchFreqResults, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_searchFreqResults ? type : NULL);
}

SOAP_FMAC3 searchFreqResults ** SOAP_FMAC4 soap_in_PointerTosearchFreqResults(struct soap *soap, const char *tag, searchFreqResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (searchFreqResults **)soap_malloc(soap, sizeof(searchFreqResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (searchFreqResults *)rrapi__instantiate_searchFreqResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (searchFreqResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_searchFreqResults, sizeof(searchFreqResults), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosearchFreqResults(struct soap *soap, searchFreqResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosearchFreqResults(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 searchFreqResults ** SOAP_FMAC4 soap_get_PointerTosearchFreqResults(struct soap *soap, searchFreqResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosearchFreqResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToFreqs(struct soap *soap, Freqs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToFreqs(struct soap *soap, const char *tag, int id, Freqs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Freqs, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Freqs ? type : NULL);
}

SOAP_FMAC3 Freqs ** SOAP_FMAC4 soap_in_PointerToFreqs(struct soap *soap, const char *tag, Freqs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Freqs **)soap_malloc(soap, sizeof(Freqs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Freqs *)rrapi__instantiate_Freqs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Freqs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Freqs, sizeof(Freqs), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToFreqs(struct soap *soap, Freqs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToFreqs(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Freqs ** SOAP_FMAC4 soap_get_PointerToFreqs(struct soap *soap, Freqs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AgencyInfo(struct soap *soap, ns1__AgencyInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AgencyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AgencyInfo(struct soap *soap, const char *tag, int id, ns1__AgencyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AgencyInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__AgencyInfo ? type : NULL);
}

SOAP_FMAC3 ns1__AgencyInfo ** SOAP_FMAC4 soap_in_PointerTons1__AgencyInfo(struct soap *soap, const char *tag, ns1__AgencyInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AgencyInfo **)soap_malloc(soap, sizeof(ns1__AgencyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AgencyInfo *)rrapi__instantiate_ns1__AgencyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__AgencyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AgencyInfo, sizeof(ns1__AgencyInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AgencyInfo(struct soap *soap, ns1__AgencyInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__AgencyInfo(soap, tag ? tag : "ns1:AgencyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AgencyInfo ** SOAP_FMAC4 soap_get_PointerTons1__AgencyInfo(struct soap *soap, ns1__AgencyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AgencyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountyInfo(struct soap *soap, ns1__CountyInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CountyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountyInfo(struct soap *soap, const char *tag, int id, ns1__CountyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountyInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CountyInfo ? type : NULL);
}

SOAP_FMAC3 ns1__CountyInfo ** SOAP_FMAC4 soap_in_PointerTons1__CountyInfo(struct soap *soap, const char *tag, ns1__CountyInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountyInfo **)soap_malloc(soap, sizeof(ns1__CountyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CountyInfo *)rrapi__instantiate_ns1__CountyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CountyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountyInfo, sizeof(ns1__CountyInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountyInfo(struct soap *soap, ns1__CountyInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CountyInfo(soap, tag ? tag : "ns1:CountyInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CountyInfo ** SOAP_FMAC4 soap_get_PointerTons1__CountyInfo(struct soap *soap, ns1__CountyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StateInfo(struct soap *soap, ns1__StateInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StateInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StateInfo(struct soap *soap, const char *tag, int id, ns1__StateInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StateInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__StateInfo ? type : NULL);
}

SOAP_FMAC3 ns1__StateInfo ** SOAP_FMAC4 soap_in_PointerTons1__StateInfo(struct soap *soap, const char *tag, ns1__StateInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StateInfo **)soap_malloc(soap, sizeof(ns1__StateInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StateInfo *)rrapi__instantiate_ns1__StateInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__StateInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StateInfo, sizeof(ns1__StateInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StateInfo(struct soap *soap, ns1__StateInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__StateInfo(soap, tag ? tag : "ns1:StateInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__StateInfo ** SOAP_FMAC4 soap_get_PointerTons1__StateInfo(struct soap *soap, ns1__StateInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StateInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CountryInfo(struct soap *soap, ns1__CountryInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CountryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CountryInfo(struct soap *soap, const char *tag, int id, ns1__CountryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CountryInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__CountryInfo ? type : NULL);
}

SOAP_FMAC3 ns1__CountryInfo ** SOAP_FMAC4 soap_in_PointerTons1__CountryInfo(struct soap *soap, const char *tag, ns1__CountryInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CountryInfo **)soap_malloc(soap, sizeof(ns1__CountryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CountryInfo *)rrapi__instantiate_ns1__CountryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__CountryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CountryInfo, sizeof(ns1__CountryInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CountryInfo(struct soap *soap, ns1__CountryInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__CountryInfo(soap, tag ? tag : "ns1:CountryInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CountryInfo ** SOAP_FMAC4 soap_get_PointerTons1__CountryInfo(struct soap *soap, ns1__CountryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CountryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCountries(struct soap *soap, Countries *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCountries(struct soap *soap, const char *tag, int id, Countries *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Countries, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Countries ? type : NULL);
}

SOAP_FMAC3 Countries ** SOAP_FMAC4 soap_in_PointerToCountries(struct soap *soap, const char *tag, Countries **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Countries **)soap_malloc(soap, sizeof(Countries *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Countries *)rrapi__instantiate_Countries(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Countries **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Countries, sizeof(Countries), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCountries(struct soap *soap, Countries *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToCountries(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Countries ** SOAP_FMAC4 soap_get_PointerToCountries(struct soap *soap, Countries **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCountries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsVoice(struct soap *soap, TrsVoice *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsVoice(struct soap *soap, const char *tag, int id, TrsVoice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsVoice, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsVoice ? type : NULL);
}

SOAP_FMAC3 TrsVoice ** SOAP_FMAC4 soap_in_PointerToTrsVoice(struct soap *soap, const char *tag, TrsVoice **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsVoice **)soap_malloc(soap, sizeof(TrsVoice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsVoice *)rrapi__instantiate_TrsVoice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsVoice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsVoice, sizeof(TrsVoice), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsVoice(struct soap *soap, TrsVoice *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsVoice(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsVoice ** SOAP_FMAC4 soap_get_PointerToTrsVoice(struct soap *soap, TrsVoice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsVoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsFlavor(struct soap *soap, TrsFlavor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsFlavor(struct soap *soap, const char *tag, int id, TrsFlavor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsFlavor, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsFlavor ? type : NULL);
}

SOAP_FMAC3 TrsFlavor ** SOAP_FMAC4 soap_in_PointerToTrsFlavor(struct soap *soap, const char *tag, TrsFlavor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsFlavor **)soap_malloc(soap, sizeof(TrsFlavor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsFlavor *)rrapi__instantiate_TrsFlavor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsFlavor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsFlavor, sizeof(TrsFlavor), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsFlavor(struct soap *soap, TrsFlavor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsFlavor(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsFlavor ** SOAP_FMAC4 soap_get_PointerToTrsFlavor(struct soap *soap, TrsFlavor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsFlavor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsType(struct soap *soap, TrsType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsType(struct soap *soap, const char *tag, int id, TrsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsType, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsType ? type : NULL);
}

SOAP_FMAC3 TrsType ** SOAP_FMAC4 soap_in_PointerToTrsType(struct soap *soap, const char *tag, TrsType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsType **)soap_malloc(soap, sizeof(TrsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsType *)rrapi__instantiate_TrsType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsType, sizeof(TrsType), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsType(struct soap *soap, TrsType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsType(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsType ** SOAP_FMAC4 soap_get_PointerToTrsType(struct soap *soap, TrsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTomodes(struct soap *soap, modes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTomodes(struct soap *soap, const char *tag, int id, modes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_modes, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_modes ? type : NULL);
}

SOAP_FMAC3 modes ** SOAP_FMAC4 soap_in_PointerTomodes(struct soap *soap, const char *tag, modes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (modes **)soap_malloc(soap, sizeof(modes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (modes *)rrapi__instantiate_modes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (modes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_modes, sizeof(modes), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTomodes(struct soap *soap, modes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTomodes(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 modes ** SOAP_FMAC4 soap_get_PointerTomodes(struct soap *soap, modes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToctidList(struct soap *soap, ctidList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToctidList(struct soap *soap, const char *tag, int id, ctidList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ctidList, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ctidList ? type : NULL);
}

SOAP_FMAC3 ctidList ** SOAP_FMAC4 soap_in_PointerToctidList(struct soap *soap, const char *tag, ctidList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ctidList **)soap_malloc(soap, sizeof(ctidList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ctidList *)rrapi__instantiate_ctidList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ctidList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ctidList, sizeof(ctidList), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToctidList(struct soap *soap, ctidList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToctidList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ctidList ** SOAP_FMAC4 soap_get_PointerToctidList(struct soap *soap, ctidList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToctidList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostidList(struct soap *soap, stidList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostidList(struct soap *soap, const char *tag, int id, stidList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_stidList, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_stidList ? type : NULL);
}

SOAP_FMAC3 stidList ** SOAP_FMAC4 soap_in_PointerTostidList(struct soap *soap, const char *tag, stidList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (stidList **)soap_malloc(soap, sizeof(stidList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (stidList *)rrapi__instantiate_stidList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (stidList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_stidList, sizeof(stidList), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostidList(struct soap *soap, stidList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostidList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 stidList ** SOAP_FMAC4 soap_get_PointerTostidList(struct soap *soap, stidList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostidList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsSites(struct soap *soap, TrsSites *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsSites(struct soap *soap, const char *tag, int id, TrsSites *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsSites, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsSites ? type : NULL);
}

SOAP_FMAC3 TrsSites ** SOAP_FMAC4 soap_in_PointerToTrsSites(struct soap *soap, const char *tag, TrsSites **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsSites **)soap_malloc(soap, sizeof(TrsSites *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsSites *)rrapi__instantiate_TrsSites(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsSites **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsSites, sizeof(TrsSites), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsSites(struct soap *soap, TrsSites *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsSites(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsSites ** SOAP_FMAC4 soap_get_PointerToTrsSites(struct soap *soap, TrsSites **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsSites(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Trs(struct soap *soap, ns1__Trs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Trs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Trs(struct soap *soap, const char *tag, int id, ns1__Trs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Trs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Trs ? type : NULL);
}

SOAP_FMAC3 ns1__Trs ** SOAP_FMAC4 soap_in_PointerTons1__Trs(struct soap *soap, const char *tag, ns1__Trs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Trs **)soap_malloc(soap, sizeof(ns1__Trs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Trs *)rrapi__instantiate_ns1__Trs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Trs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Trs, sizeof(ns1__Trs), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Trs(struct soap *soap, ns1__Trs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Trs(soap, tag ? tag : "ns1:Trs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Trs ** SOAP_FMAC4 soap_get_PointerTons1__Trs(struct soap *soap, ns1__Trs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Trs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTalkgroupCats(struct soap *soap, TalkgroupCats *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTalkgroupCats(struct soap *soap, const char *tag, int id, TalkgroupCats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TalkgroupCats, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TalkgroupCats ? type : NULL);
}

SOAP_FMAC3 TalkgroupCats ** SOAP_FMAC4 soap_in_PointerToTalkgroupCats(struct soap *soap, const char *tag, TalkgroupCats **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TalkgroupCats **)soap_malloc(soap, sizeof(TalkgroupCats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TalkgroupCats *)rrapi__instantiate_TalkgroupCats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TalkgroupCats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TalkgroupCats, sizeof(TalkgroupCats), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTalkgroupCats(struct soap *soap, TalkgroupCats *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTalkgroupCats(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TalkgroupCats ** SOAP_FMAC4 soap_get_PointerToTalkgroupCats(struct soap *soap, TalkgroupCats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTalkgroupCats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__authInfo(struct soap *soap, ns1__authInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__authInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__authInfo(struct soap *soap, const char *tag, int id, ns1__authInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__authInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__authInfo ? type : NULL);
}

SOAP_FMAC3 ns1__authInfo ** SOAP_FMAC4 soap_in_PointerTons1__authInfo(struct soap *soap, const char *tag, ns1__authInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__authInfo **)soap_malloc(soap, sizeof(ns1__authInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__authInfo *)rrapi__instantiate_ns1__authInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__authInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__authInfo, sizeof(ns1__authInfo), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__authInfo(struct soap *soap, ns1__authInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__authInfo(soap, tag ? tag : "ns1:authInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__authInfo ** SOAP_FMAC4 soap_get_PointerTons1__authInfo(struct soap *soap, ns1__authInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__authInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTalkgroups(struct soap *soap, Talkgroups *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTalkgroups(struct soap *soap, const char *tag, int id, Talkgroups *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Talkgroups, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Talkgroups ? type : NULL);
}

SOAP_FMAC3 Talkgroups ** SOAP_FMAC4 soap_in_PointerToTalkgroups(struct soap *soap, const char *tag, Talkgroups **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Talkgroups **)soap_malloc(soap, sizeof(Talkgroups *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Talkgroups *)rrapi__instantiate_Talkgroups(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Talkgroups **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Talkgroups, sizeof(Talkgroups), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTalkgroups(struct soap *soap, Talkgroups *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTalkgroups(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Talkgroups ** SOAP_FMAC4 soap_get_PointerToTalkgroups(struct soap *soap, Talkgroups **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTalkgroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__fccRadioServiceCode))
		soap_serialize_PointerTons1__fccRadioServiceCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__fccRadioServiceCode(struct soap *soap, const char *tag, int id, ns1__fccRadioServiceCode **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__fccRadioServiceCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__fccRadioServiceCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__fccRadioServiceCode *** SOAP_FMAC4 soap_in_PointerToPointerTons1__fccRadioServiceCode(struct soap *soap, const char *tag, ns1__fccRadioServiceCode ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccRadioServiceCode ***)soap_malloc(soap, sizeof(ns1__fccRadioServiceCode **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__fccRadioServiceCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__fccRadioServiceCode ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccRadioServiceCode, sizeof(ns1__fccRadioServiceCode), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__fccRadioServiceCode(soap, tag ? tag : "ns1:fccRadioServiceCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccRadioServiceCode *** SOAP_FMAC4 soap_get_PointerToPointerTons1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__fccRadioServiceCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fccRadioServiceCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fccRadioServiceCode(struct soap *soap, const char *tag, int id, ns1__fccRadioServiceCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fccRadioServiceCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__fccRadioServiceCode ? type : NULL);
}

SOAP_FMAC3 ns1__fccRadioServiceCode ** SOAP_FMAC4 soap_in_PointerTons1__fccRadioServiceCode(struct soap *soap, const char *tag, ns1__fccRadioServiceCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccRadioServiceCode **)soap_malloc(soap, sizeof(ns1__fccRadioServiceCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fccRadioServiceCode *)rrapi__instantiate_ns1__fccRadioServiceCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__fccRadioServiceCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccRadioServiceCode, sizeof(ns1__fccRadioServiceCode), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__fccRadioServiceCode(soap, tag ? tag : "ns1:fccRadioServiceCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccRadioServiceCode ** SOAP_FMAC4 soap_get_PointerTons1__fccRadioServiceCode(struct soap *soap, ns1__fccRadioServiceCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fccRadioServiceCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__proxCallsignResult))
		soap_serialize_PointerTons1__proxCallsignResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__proxCallsignResult(struct soap *soap, const char *tag, int id, ns1__proxCallsignResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__proxCallsignResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__proxCallsignResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__proxCallsignResult *** SOAP_FMAC4 soap_in_PointerToPointerTons1__proxCallsignResult(struct soap *soap, const char *tag, ns1__proxCallsignResult ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__proxCallsignResult ***)soap_malloc(soap, sizeof(ns1__proxCallsignResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__proxCallsignResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__proxCallsignResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__proxCallsignResult, sizeof(ns1__proxCallsignResult), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__proxCallsignResult(soap, tag ? tag : "ns1:proxCallsignResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__proxCallsignResult *** SOAP_FMAC4 soap_get_PointerToPointerTons1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__proxCallsignResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__proxCallsignResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__proxCallsignResult(struct soap *soap, const char *tag, int id, ns1__proxCallsignResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__proxCallsignResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__proxCallsignResult ? type : NULL);
}

SOAP_FMAC3 ns1__proxCallsignResult ** SOAP_FMAC4 soap_in_PointerTons1__proxCallsignResult(struct soap *soap, const char *tag, ns1__proxCallsignResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__proxCallsignResult **)soap_malloc(soap, sizeof(ns1__proxCallsignResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__proxCallsignResult *)rrapi__instantiate_ns1__proxCallsignResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__proxCallsignResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__proxCallsignResult, sizeof(ns1__proxCallsignResult), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__proxCallsignResult(soap, tag ? tag : "ns1:proxCallsignResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__proxCallsignResult ** SOAP_FMAC4 soap_get_PointerTons1__proxCallsignResult(struct soap *soap, ns1__proxCallsignResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__proxCallsignResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__fccLocation(struct soap *soap, ns1__fccLocation **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__fccLocation))
		soap_serialize_PointerTons1__fccLocation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__fccLocation(struct soap *soap, const char *tag, int id, ns1__fccLocation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__fccLocation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__fccLocation(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__fccLocation *** SOAP_FMAC4 soap_in_PointerToPointerTons1__fccLocation(struct soap *soap, const char *tag, ns1__fccLocation ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccLocation ***)soap_malloc(soap, sizeof(ns1__fccLocation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__fccLocation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__fccLocation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccLocation, sizeof(ns1__fccLocation), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__fccLocation(struct soap *soap, ns1__fccLocation **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__fccLocation(soap, tag ? tag : "ns1:fccLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccLocation *** SOAP_FMAC4 soap_get_PointerToPointerTons1__fccLocation(struct soap *soap, ns1__fccLocation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__fccLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fccLocation(struct soap *soap, ns1__fccLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fccLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fccLocation(struct soap *soap, const char *tag, int id, ns1__fccLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fccLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__fccLocation ? type : NULL);
}

SOAP_FMAC3 ns1__fccLocation ** SOAP_FMAC4 soap_in_PointerTons1__fccLocation(struct soap *soap, const char *tag, ns1__fccLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccLocation **)soap_malloc(soap, sizeof(ns1__fccLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fccLocation *)rrapi__instantiate_ns1__fccLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__fccLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccLocation, sizeof(ns1__fccLocation), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fccLocation(struct soap *soap, ns1__fccLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__fccLocation(soap, tag ? tag : "ns1:fccLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccLocation ** SOAP_FMAC4 soap_get_PointerTons1__fccLocation(struct soap *soap, ns1__fccLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fccLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__fccFrequency(struct soap *soap, ns1__fccFrequency **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__fccFrequency))
		soap_serialize_PointerTons1__fccFrequency(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__fccFrequency(struct soap *soap, const char *tag, int id, ns1__fccFrequency **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__fccFrequency, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__fccFrequency(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__fccFrequency *** SOAP_FMAC4 soap_in_PointerToPointerTons1__fccFrequency(struct soap *soap, const char *tag, ns1__fccFrequency ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccFrequency ***)soap_malloc(soap, sizeof(ns1__fccFrequency **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__fccFrequency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__fccFrequency ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccFrequency, sizeof(ns1__fccFrequency), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__fccFrequency(struct soap *soap, ns1__fccFrequency **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__fccFrequency(soap, tag ? tag : "ns1:fccFrequency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccFrequency *** SOAP_FMAC4 soap_get_PointerToPointerTons1__fccFrequency(struct soap *soap, ns1__fccFrequency ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__fccFrequency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fccFrequency(struct soap *soap, ns1__fccFrequency *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fccFrequency))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fccFrequency(struct soap *soap, const char *tag, int id, ns1__fccFrequency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fccFrequency, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__fccFrequency ? type : NULL);
}

SOAP_FMAC3 ns1__fccFrequency ** SOAP_FMAC4 soap_in_PointerTons1__fccFrequency(struct soap *soap, const char *tag, ns1__fccFrequency **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fccFrequency **)soap_malloc(soap, sizeof(ns1__fccFrequency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fccFrequency *)rrapi__instantiate_ns1__fccFrequency(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__fccFrequency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fccFrequency, sizeof(ns1__fccFrequency), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fccFrequency(struct soap *soap, ns1__fccFrequency *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__fccFrequency(soap, tag ? tag : "ns1:fccFrequency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fccFrequency ** SOAP_FMAC4 soap_get_PointerTons1__fccFrequency(struct soap *soap, ns1__fccFrequency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fccFrequency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__mode(struct soap *soap, ns1__mode **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__mode))
		soap_serialize_PointerTons1__mode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__mode(struct soap *soap, const char *tag, int id, ns1__mode **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__mode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__mode(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__mode *** SOAP_FMAC4 soap_in_PointerToPointerTons1__mode(struct soap *soap, const char *tag, ns1__mode ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__mode ***)soap_malloc(soap, sizeof(ns1__mode **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__mode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__mode ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mode, sizeof(ns1__mode), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__mode(struct soap *soap, ns1__mode **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__mode(soap, tag ? tag : "ns1:mode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__mode *** SOAP_FMAC4 soap_get_PointerToPointerTons1__mode(struct soap *soap, ns1__mode ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__mode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__mode(struct soap *soap, ns1__mode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__mode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__mode(struct soap *soap, const char *tag, int id, ns1__mode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__mode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__mode ? type : NULL);
}

SOAP_FMAC3 ns1__mode ** SOAP_FMAC4 soap_in_PointerTons1__mode(struct soap *soap, const char *tag, ns1__mode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__mode **)soap_malloc(soap, sizeof(ns1__mode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__mode *)rrapi__instantiate_ns1__mode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__mode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__mode, sizeof(ns1__mode), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__mode(struct soap *soap, ns1__mode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__mode(soap, tag ? tag : "ns1:mode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__mode ** SOAP_FMAC4 soap_get_PointerTons1__mode(struct soap *soap, ns1__mode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__mode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__tag(struct soap *soap, ns1__tag **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__tag))
		soap_serialize_PointerTons1__tag(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__tag(struct soap *soap, const char *tag, int id, ns1__tag **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__tag, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__tag(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__tag *** SOAP_FMAC4 soap_in_PointerToPointerTons1__tag(struct soap *soap, const char *tag, ns1__tag ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__tag ***)soap_malloc(soap, sizeof(ns1__tag **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__tag(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__tag ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__tag, sizeof(ns1__tag), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__tag(struct soap *soap, ns1__tag **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__tag(soap, tag ? tag : "ns1:tag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__tag *** SOAP_FMAC4 soap_get_PointerToPointerTons1__tag(struct soap *soap, ns1__tag ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__tag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__tag(struct soap *soap, ns1__tag *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__tag))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__tag(struct soap *soap, const char *tag, int id, ns1__tag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__tag, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__tag ? type : NULL);
}

SOAP_FMAC3 ns1__tag ** SOAP_FMAC4 soap_in_PointerTons1__tag(struct soap *soap, const char *tag, ns1__tag **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__tag **)soap_malloc(soap, sizeof(ns1__tag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__tag *)rrapi__instantiate_ns1__tag(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__tag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__tag, sizeof(ns1__tag), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__tag(struct soap *soap, ns1__tag *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__tag(soap, tag ? tag : "ns1:tag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__tag ** SOAP_FMAC4 soap_get_PointerTons1__tag(struct soap *soap, ns1__tag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__tag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__sid(struct soap *soap, ns1__sid **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__sid))
		soap_serialize_PointerTons1__sid(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__sid(struct soap *soap, const char *tag, int id, ns1__sid **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__sid, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__sid(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__sid *** SOAP_FMAC4 soap_in_PointerToPointerTons1__sid(struct soap *soap, const char *tag, ns1__sid ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sid ***)soap_malloc(soap, sizeof(ns1__sid **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__sid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__sid ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sid, sizeof(ns1__sid), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__sid(struct soap *soap, ns1__sid **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__sid(soap, tag ? tag : "ns1:sid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sid *** SOAP_FMAC4 soap_get_PointerToPointerTons1__sid(struct soap *soap, ns1__sid ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__sid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sid(struct soap *soap, ns1__sid *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sid))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sid(struct soap *soap, const char *tag, int id, ns1__sid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sid, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__sid ? type : NULL);
}

SOAP_FMAC3 ns1__sid ** SOAP_FMAC4 soap_in_PointerTons1__sid(struct soap *soap, const char *tag, ns1__sid **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sid **)soap_malloc(soap, sizeof(ns1__sid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sid *)rrapi__instantiate_ns1__sid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__sid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sid, sizeof(ns1__sid), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sid(struct soap *soap, ns1__sid *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__sid(soap, tag ? tag : "ns1:sid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sid ** SOAP_FMAC4 soap_get_PointerTons1__sid(struct soap *soap, ns1__sid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Agency(struct soap *soap, ns1__Agency **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Agency))
		soap_serialize_PointerTons1__Agency(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Agency(struct soap *soap, const char *tag, int id, ns1__Agency **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Agency, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Agency(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Agency *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Agency(struct soap *soap, const char *tag, ns1__Agency ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Agency ***)soap_malloc(soap, sizeof(ns1__Agency **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Agency(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Agency ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Agency, sizeof(ns1__Agency), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Agency(struct soap *soap, ns1__Agency **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__Agency(soap, tag ? tag : "ns1:Agency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Agency *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Agency(struct soap *soap, ns1__Agency ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Agency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Agency(struct soap *soap, ns1__Agency *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Agency))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Agency(struct soap *soap, const char *tag, int id, ns1__Agency *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Agency, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Agency ? type : NULL);
}

SOAP_FMAC3 ns1__Agency ** SOAP_FMAC4 soap_in_PointerTons1__Agency(struct soap *soap, const char *tag, ns1__Agency **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Agency **)soap_malloc(soap, sizeof(ns1__Agency *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Agency *)rrapi__instantiate_ns1__Agency(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Agency **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Agency, sizeof(ns1__Agency), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Agency(struct soap *soap, ns1__Agency *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Agency(soap, tag ? tag : "ns1:Agency", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Agency ** SOAP_FMAC4 soap_get_PointerTons1__Agency(struct soap *soap, ns1__Agency **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Agency(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Country(struct soap *soap, ns1__Country **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Country))
		soap_serialize_PointerTons1__Country(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Country(struct soap *soap, const char *tag, int id, ns1__Country **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Country, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Country(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Country *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Country(struct soap *soap, const char *tag, ns1__Country ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Country ***)soap_malloc(soap, sizeof(ns1__Country **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Country(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Country ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Country, sizeof(ns1__Country), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Country(struct soap *soap, ns1__Country **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__Country(soap, tag ? tag : "ns1:Country", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Country *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Country(struct soap *soap, ns1__Country ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Country(struct soap *soap, ns1__Country *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Country))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Country(struct soap *soap, const char *tag, int id, ns1__Country *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Country, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Country ? type : NULL);
}

SOAP_FMAC3 ns1__Country ** SOAP_FMAC4 soap_in_PointerTons1__Country(struct soap *soap, const char *tag, ns1__Country **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Country **)soap_malloc(soap, sizeof(ns1__Country *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Country *)rrapi__instantiate_ns1__Country(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Country **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Country, sizeof(ns1__Country), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Country(struct soap *soap, ns1__Country *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Country(soap, tag ? tag : "ns1:Country", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Country ** SOAP_FMAC4 soap_get_PointerTons1__Country(struct soap *soap, ns1__Country **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Country(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Metro(struct soap *soap, ns1__Metro **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Metro))
		soap_serialize_PointerTons1__Metro(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Metro(struct soap *soap, const char *tag, int id, ns1__Metro **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Metro, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Metro(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Metro *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Metro(struct soap *soap, const char *tag, ns1__Metro ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Metro ***)soap_malloc(soap, sizeof(ns1__Metro **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Metro(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Metro ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Metro, sizeof(ns1__Metro), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Metro(struct soap *soap, ns1__Metro **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__Metro(soap, tag ? tag : "ns1:Metro", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Metro *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Metro(struct soap *soap, ns1__Metro ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Metro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Metro(struct soap *soap, ns1__Metro *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Metro))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Metro(struct soap *soap, const char *tag, int id, ns1__Metro *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Metro, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Metro ? type : NULL);
}

SOAP_FMAC3 ns1__Metro ** SOAP_FMAC4 soap_in_PointerTons1__Metro(struct soap *soap, const char *tag, ns1__Metro **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Metro **)soap_malloc(soap, sizeof(ns1__Metro *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Metro *)rrapi__instantiate_ns1__Metro(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Metro **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Metro, sizeof(ns1__Metro), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Metro(struct soap *soap, ns1__Metro *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Metro(soap, tag ? tag : "ns1:Metro", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Metro ** SOAP_FMAC4 soap_get_PointerTons1__Metro(struct soap *soap, ns1__Metro **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Metro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__State(struct soap *soap, ns1__State **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__State))
		soap_serialize_PointerTons1__State(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__State(struct soap *soap, const char *tag, int id, ns1__State **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__State, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__State(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__State *** SOAP_FMAC4 soap_in_PointerToPointerTons1__State(struct soap *soap, const char *tag, ns1__State ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__State ***)soap_malloc(soap, sizeof(ns1__State **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__State(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__State ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__State, sizeof(ns1__State), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__State(struct soap *soap, ns1__State **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__State(soap, tag ? tag : "ns1:State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__State *** SOAP_FMAC4 soap_get_PointerToPointerTons1__State(struct soap *soap, ns1__State ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__State(struct soap *soap, ns1__State *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__State))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__State(struct soap *soap, const char *tag, int id, ns1__State *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__State, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__State ? type : NULL);
}

SOAP_FMAC3 ns1__State ** SOAP_FMAC4 soap_in_PointerTons1__State(struct soap *soap, const char *tag, ns1__State **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__State **)soap_malloc(soap, sizeof(ns1__State *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__State *)rrapi__instantiate_ns1__State(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__State **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__State, sizeof(ns1__State), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__State(struct soap *soap, ns1__State *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__State(soap, tag ? tag : "ns1:State", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__State ** SOAP_FMAC4 soap_get_PointerTons1__State(struct soap *soap, ns1__State **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__State(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__County(struct soap *soap, ns1__County **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__County))
		soap_serialize_PointerTons1__County(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__County(struct soap *soap, const char *tag, int id, ns1__County **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__County, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__County(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__County *** SOAP_FMAC4 soap_in_PointerToPointerTons1__County(struct soap *soap, const char *tag, ns1__County ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__County ***)soap_malloc(soap, sizeof(ns1__County **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__County(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__County ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__County, sizeof(ns1__County), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__County(struct soap *soap, ns1__County **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__County(soap, tag ? tag : "ns1:County", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__County *** SOAP_FMAC4 soap_get_PointerToPointerTons1__County(struct soap *soap, ns1__County ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__County(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__County(struct soap *soap, ns1__County *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__County))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__County(struct soap *soap, const char *tag, int id, ns1__County *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__County, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__County ? type : NULL);
}

SOAP_FMAC3 ns1__County ** SOAP_FMAC4 soap_in_PointerTons1__County(struct soap *soap, const char *tag, ns1__County **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__County **)soap_malloc(soap, sizeof(ns1__County *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__County *)rrapi__instantiate_ns1__County(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__County **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__County, sizeof(ns1__County), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__County(struct soap *soap, ns1__County *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__County(soap, tag ? tag : "ns1:County", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__County ** SOAP_FMAC4 soap_get_PointerTons1__County(struct soap *soap, ns1__County **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__County(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__subcat(struct soap *soap, ns1__subcat **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__subcat))
		soap_serialize_PointerTons1__subcat(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__subcat(struct soap *soap, const char *tag, int id, ns1__subcat **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__subcat, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__subcat(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__subcat *** SOAP_FMAC4 soap_in_PointerToPointerTons1__subcat(struct soap *soap, const char *tag, ns1__subcat ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__subcat ***)soap_malloc(soap, sizeof(ns1__subcat **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__subcat(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__subcat ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__subcat, sizeof(ns1__subcat), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__subcat(struct soap *soap, ns1__subcat **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__subcat(soap, tag ? tag : "ns1:subcat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__subcat *** SOAP_FMAC4 soap_get_PointerToPointerTons1__subcat(struct soap *soap, ns1__subcat ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__subcat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__subcat(struct soap *soap, ns1__subcat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__subcat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__subcat(struct soap *soap, const char *tag, int id, ns1__subcat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__subcat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__subcat ? type : NULL);
}

SOAP_FMAC3 ns1__subcat ** SOAP_FMAC4 soap_in_PointerTons1__subcat(struct soap *soap, const char *tag, ns1__subcat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__subcat **)soap_malloc(soap, sizeof(ns1__subcat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__subcat *)rrapi__instantiate_ns1__subcat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__subcat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__subcat, sizeof(ns1__subcat), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__subcat(struct soap *soap, ns1__subcat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__subcat(soap, tag ? tag : "ns1:subcat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__subcat ** SOAP_FMAC4 soap_get_PointerTons1__subcat(struct soap *soap, ns1__subcat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__subcat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__cat(struct soap *soap, ns1__cat **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__cat))
		soap_serialize_PointerTons1__cat(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__cat(struct soap *soap, const char *tag, int id, ns1__cat **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__cat, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__cat(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__cat *** SOAP_FMAC4 soap_in_PointerToPointerTons1__cat(struct soap *soap, const char *tag, ns1__cat ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cat ***)soap_malloc(soap, sizeof(ns1__cat **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__cat(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__cat ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cat, sizeof(ns1__cat), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__cat(struct soap *soap, ns1__cat **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__cat(soap, tag ? tag : "ns1:cat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cat *** SOAP_FMAC4 soap_get_PointerToPointerTons1__cat(struct soap *soap, ns1__cat ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__cat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cat(struct soap *soap, ns1__cat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cat(struct soap *soap, const char *tag, int id, ns1__cat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__cat ? type : NULL);
}

SOAP_FMAC3 ns1__cat ** SOAP_FMAC4 soap_in_PointerTons1__cat(struct soap *soap, const char *tag, ns1__cat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cat **)soap_malloc(soap, sizeof(ns1__cat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cat *)rrapi__instantiate_ns1__cat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__cat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cat, sizeof(ns1__cat), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cat(struct soap *soap, ns1__cat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__cat(soap, tag ? tag : "ns1:cat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cat ** SOAP_FMAC4 soap_get_PointerTons1__cat(struct soap *soap, ns1__cat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__freq(struct soap *soap, ns1__freq **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__freq))
		soap_serialize_PointerTons1__freq(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__freq(struct soap *soap, const char *tag, int id, ns1__freq **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__freq, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__freq(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__freq *** SOAP_FMAC4 soap_in_PointerToPointerTons1__freq(struct soap *soap, const char *tag, ns1__freq ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__freq ***)soap_malloc(soap, sizeof(ns1__freq **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__freq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__freq ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__freq, sizeof(ns1__freq), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__freq(struct soap *soap, ns1__freq **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__freq(soap, tag ? tag : "ns1:freq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__freq *** SOAP_FMAC4 soap_get_PointerToPointerTons1__freq(struct soap *soap, ns1__freq ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__freq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__freq(struct soap *soap, ns1__freq *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__freq))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__freq(struct soap *soap, const char *tag, int id, ns1__freq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__freq, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__freq ? type : NULL);
}

SOAP_FMAC3 ns1__freq ** SOAP_FMAC4 soap_in_PointerTons1__freq(struct soap *soap, const char *tag, ns1__freq **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__freq **)soap_malloc(soap, sizeof(ns1__freq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__freq *)rrapi__instantiate_ns1__freq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__freq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__freq, sizeof(ns1__freq), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__freq(struct soap *soap, ns1__freq *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__freq(soap, tag ? tag : "ns1:freq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__freq ** SOAP_FMAC4 soap_get_PointerTons1__freq(struct soap *soap, ns1__freq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__freq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__searchFreqResult(struct soap *soap, ns1__searchFreqResult **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__searchFreqResult))
		soap_serialize_PointerTons1__searchFreqResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__searchFreqResult(struct soap *soap, const char *tag, int id, ns1__searchFreqResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__searchFreqResult, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__searchFreqResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__searchFreqResult *** SOAP_FMAC4 soap_in_PointerToPointerTons1__searchFreqResult(struct soap *soap, const char *tag, ns1__searchFreqResult ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchFreqResult ***)soap_malloc(soap, sizeof(ns1__searchFreqResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__searchFreqResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__searchFreqResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchFreqResult, sizeof(ns1__searchFreqResult), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__searchFreqResult(struct soap *soap, ns1__searchFreqResult **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__searchFreqResult(soap, tag ? tag : "ns1:searchFreqResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchFreqResult *** SOAP_FMAC4 soap_get_PointerToPointerTons1__searchFreqResult(struct soap *soap, ns1__searchFreqResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__searchFreqResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__searchFreqResult(struct soap *soap, ns1__searchFreqResult *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__searchFreqResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__searchFreqResult(struct soap *soap, const char *tag, int id, ns1__searchFreqResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__searchFreqResult, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__searchFreqResult ? type : NULL);
}

SOAP_FMAC3 ns1__searchFreqResult ** SOAP_FMAC4 soap_in_PointerTons1__searchFreqResult(struct soap *soap, const char *tag, ns1__searchFreqResult **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__searchFreqResult **)soap_malloc(soap, sizeof(ns1__searchFreqResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__searchFreqResult *)rrapi__instantiate_ns1__searchFreqResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__searchFreqResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__searchFreqResult, sizeof(ns1__searchFreqResult), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__searchFreqResult(struct soap *soap, ns1__searchFreqResult *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__searchFreqResult(soap, tag ? tag : "ns1:searchFreqResult", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__searchFreqResult ** SOAP_FMAC4 soap_get_PointerTons1__searchFreqResult(struct soap *soap, ns1__searchFreqResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__searchFreqResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__trsVoiceDef))
		soap_serialize_PointerTons1__trsVoiceDef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__trsVoiceDef(struct soap *soap, const char *tag, int id, ns1__trsVoiceDef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__trsVoiceDef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__trsVoiceDef(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__trsVoiceDef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__trsVoiceDef(struct soap *soap, const char *tag, ns1__trsVoiceDef ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsVoiceDef ***)soap_malloc(soap, sizeof(ns1__trsVoiceDef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__trsVoiceDef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__trsVoiceDef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsVoiceDef, sizeof(ns1__trsVoiceDef), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__trsVoiceDef(soap, tag ? tag : "ns1:trsVoiceDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsVoiceDef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__trsVoiceDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trsVoiceDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trsVoiceDef(struct soap *soap, const char *tag, int id, ns1__trsVoiceDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trsVoiceDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__trsVoiceDef ? type : NULL);
}

SOAP_FMAC3 ns1__trsVoiceDef ** SOAP_FMAC4 soap_in_PointerTons1__trsVoiceDef(struct soap *soap, const char *tag, ns1__trsVoiceDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsVoiceDef **)soap_malloc(soap, sizeof(ns1__trsVoiceDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__trsVoiceDef *)rrapi__instantiate_ns1__trsVoiceDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__trsVoiceDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsVoiceDef, sizeof(ns1__trsVoiceDef), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__trsVoiceDef(soap, tag ? tag : "ns1:trsVoiceDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsVoiceDef ** SOAP_FMAC4 soap_get_PointerTons1__trsVoiceDef(struct soap *soap, ns1__trsVoiceDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trsVoiceDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__trsFlavorDef))
		soap_serialize_PointerTons1__trsFlavorDef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__trsFlavorDef(struct soap *soap, const char *tag, int id, ns1__trsFlavorDef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__trsFlavorDef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__trsFlavorDef(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__trsFlavorDef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__trsFlavorDef(struct soap *soap, const char *tag, ns1__trsFlavorDef ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsFlavorDef ***)soap_malloc(soap, sizeof(ns1__trsFlavorDef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__trsFlavorDef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__trsFlavorDef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsFlavorDef, sizeof(ns1__trsFlavorDef), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__trsFlavorDef(soap, tag ? tag : "ns1:trsFlavorDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsFlavorDef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__trsFlavorDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trsFlavorDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trsFlavorDef(struct soap *soap, const char *tag, int id, ns1__trsFlavorDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trsFlavorDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__trsFlavorDef ? type : NULL);
}

SOAP_FMAC3 ns1__trsFlavorDef ** SOAP_FMAC4 soap_in_PointerTons1__trsFlavorDef(struct soap *soap, const char *tag, ns1__trsFlavorDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsFlavorDef **)soap_malloc(soap, sizeof(ns1__trsFlavorDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__trsFlavorDef *)rrapi__instantiate_ns1__trsFlavorDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__trsFlavorDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsFlavorDef, sizeof(ns1__trsFlavorDef), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__trsFlavorDef(soap, tag ? tag : "ns1:trsFlavorDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsFlavorDef ** SOAP_FMAC4 soap_get_PointerTons1__trsFlavorDef(struct soap *soap, ns1__trsFlavorDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trsFlavorDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__trsTypeDef(struct soap *soap, ns1__trsTypeDef **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__trsTypeDef))
		soap_serialize_PointerTons1__trsTypeDef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__trsTypeDef(struct soap *soap, const char *tag, int id, ns1__trsTypeDef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__trsTypeDef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__trsTypeDef(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__trsTypeDef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__trsTypeDef(struct soap *soap, const char *tag, ns1__trsTypeDef ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsTypeDef ***)soap_malloc(soap, sizeof(ns1__trsTypeDef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__trsTypeDef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__trsTypeDef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsTypeDef, sizeof(ns1__trsTypeDef), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__trsTypeDef(struct soap *soap, ns1__trsTypeDef **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__trsTypeDef(soap, tag ? tag : "ns1:trsTypeDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsTypeDef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__trsTypeDef(struct soap *soap, ns1__trsTypeDef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__trsTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trsTypeDef(struct soap *soap, ns1__trsTypeDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trsTypeDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trsTypeDef(struct soap *soap, const char *tag, int id, ns1__trsTypeDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trsTypeDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__trsTypeDef ? type : NULL);
}

SOAP_FMAC3 ns1__trsTypeDef ** SOAP_FMAC4 soap_in_PointerTons1__trsTypeDef(struct soap *soap, const char *tag, ns1__trsTypeDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsTypeDef **)soap_malloc(soap, sizeof(ns1__trsTypeDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__trsTypeDef *)rrapi__instantiate_ns1__trsTypeDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__trsTypeDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsTypeDef, sizeof(ns1__trsTypeDef), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trsTypeDef(struct soap *soap, ns1__trsTypeDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__trsTypeDef(soap, tag ? tag : "ns1:trsTypeDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsTypeDef ** SOAP_FMAC4 soap_get_PointerTons1__trsTypeDef(struct soap *soap, ns1__trsTypeDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trsTypeDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__trsBandplanDef))
		soap_serialize_PointerTons1__trsBandplanDef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__trsBandplanDef(struct soap *soap, const char *tag, int id, ns1__trsBandplanDef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__trsBandplanDef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__trsBandplanDef(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__trsBandplanDef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__trsBandplanDef(struct soap *soap, const char *tag, ns1__trsBandplanDef ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsBandplanDef ***)soap_malloc(soap, sizeof(ns1__trsBandplanDef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__trsBandplanDef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__trsBandplanDef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsBandplanDef, sizeof(ns1__trsBandplanDef), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__trsBandplanDef(soap, tag ? tag : "ns1:trsBandplanDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsBandplanDef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__trsBandplanDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trsBandplanDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trsBandplanDef(struct soap *soap, const char *tag, int id, ns1__trsBandplanDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trsBandplanDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__trsBandplanDef ? type : NULL);
}

SOAP_FMAC3 ns1__trsBandplanDef ** SOAP_FMAC4 soap_in_PointerTons1__trsBandplanDef(struct soap *soap, const char *tag, ns1__trsBandplanDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsBandplanDef **)soap_malloc(soap, sizeof(ns1__trsBandplanDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__trsBandplanDef *)rrapi__instantiate_ns1__trsBandplanDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__trsBandplanDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsBandplanDef, sizeof(ns1__trsBandplanDef), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__trsBandplanDef(soap, tag ? tag : "ns1:trsBandplanDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsBandplanDef ** SOAP_FMAC4 soap_get_PointerTons1__trsBandplanDef(struct soap *soap, ns1__trsBandplanDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trsBandplanDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__trsSysidDef(struct soap *soap, ns1__trsSysidDef **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__trsSysidDef))
		soap_serialize_PointerTons1__trsSysidDef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__trsSysidDef(struct soap *soap, const char *tag, int id, ns1__trsSysidDef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__trsSysidDef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__trsSysidDef(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__trsSysidDef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__trsSysidDef(struct soap *soap, const char *tag, ns1__trsSysidDef ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsSysidDef ***)soap_malloc(soap, sizeof(ns1__trsSysidDef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__trsSysidDef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__trsSysidDef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsSysidDef, sizeof(ns1__trsSysidDef), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__trsSysidDef(struct soap *soap, ns1__trsSysidDef **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__trsSysidDef(soap, tag ? tag : "ns1:trsSysidDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsSysidDef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__trsSysidDef(struct soap *soap, ns1__trsSysidDef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__trsSysidDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__trsSysidDef(struct soap *soap, ns1__trsSysidDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__trsSysidDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__trsSysidDef(struct soap *soap, const char *tag, int id, ns1__trsSysidDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__trsSysidDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__trsSysidDef ? type : NULL);
}

SOAP_FMAC3 ns1__trsSysidDef ** SOAP_FMAC4 soap_in_PointerTons1__trsSysidDef(struct soap *soap, const char *tag, ns1__trsSysidDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__trsSysidDef **)soap_malloc(soap, sizeof(ns1__trsSysidDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__trsSysidDef *)rrapi__instantiate_ns1__trsSysidDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__trsSysidDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__trsSysidDef, sizeof(ns1__trsSysidDef), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__trsSysidDef(struct soap *soap, ns1__trsSysidDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__trsSysidDef(soap, tag ? tag : "ns1:trsSysidDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__trsSysidDef ** SOAP_FMAC4 soap_get_PointerTons1__trsSysidDef(struct soap *soap, ns1__trsSysidDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__trsSysidDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__TrsListDef(struct soap *soap, ns1__TrsListDef **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__TrsListDef))
		soap_serialize_PointerTons1__TrsListDef(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__TrsListDef(struct soap *soap, const char *tag, int id, ns1__TrsListDef **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__TrsListDef, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__TrsListDef(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__TrsListDef *** SOAP_FMAC4 soap_in_PointerToPointerTons1__TrsListDef(struct soap *soap, const char *tag, ns1__TrsListDef ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsListDef ***)soap_malloc(soap, sizeof(ns1__TrsListDef **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__TrsListDef(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__TrsListDef ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsListDef, sizeof(ns1__TrsListDef), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__TrsListDef(struct soap *soap, ns1__TrsListDef **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__TrsListDef(soap, tag ? tag : "ns1:TrsListDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsListDef *** SOAP_FMAC4 soap_get_PointerToPointerTons1__TrsListDef(struct soap *soap, ns1__TrsListDef ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__TrsListDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TrsListDef(struct soap *soap, ns1__TrsListDef *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TrsListDef))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TrsListDef(struct soap *soap, const char *tag, int id, ns1__TrsListDef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TrsListDef, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TrsListDef ? type : NULL);
}

SOAP_FMAC3 ns1__TrsListDef ** SOAP_FMAC4 soap_in_PointerTons1__TrsListDef(struct soap *soap, const char *tag, ns1__TrsListDef **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsListDef **)soap_malloc(soap, sizeof(ns1__TrsListDef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TrsListDef *)rrapi__instantiate_ns1__TrsListDef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TrsListDef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsListDef, sizeof(ns1__TrsListDef), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TrsListDef(struct soap *soap, ns1__TrsListDef *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TrsListDef(soap, tag ? tag : "ns1:TrsListDef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsListDef ** SOAP_FMAC4 soap_get_PointerTons1__TrsListDef(struct soap *soap, ns1__TrsListDef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TrsListDef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__TrsSiteLicense))
		soap_serialize_PointerTons1__TrsSiteLicense(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__TrsSiteLicense(struct soap *soap, const char *tag, int id, ns1__TrsSiteLicense **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__TrsSiteLicense, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__TrsSiteLicense(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__TrsSiteLicense *** SOAP_FMAC4 soap_in_PointerToPointerTons1__TrsSiteLicense(struct soap *soap, const char *tag, ns1__TrsSiteLicense ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsSiteLicense ***)soap_malloc(soap, sizeof(ns1__TrsSiteLicense **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__TrsSiteLicense(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__TrsSiteLicense ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsSiteLicense, sizeof(ns1__TrsSiteLicense), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__TrsSiteLicense(soap, tag ? tag : "ns1:TrsSiteLicense", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsSiteLicense *** SOAP_FMAC4 soap_get_PointerToPointerTons1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__TrsSiteLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TrsSiteLicense))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TrsSiteLicense(struct soap *soap, const char *tag, int id, ns1__TrsSiteLicense *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TrsSiteLicense, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TrsSiteLicense ? type : NULL);
}

SOAP_FMAC3 ns1__TrsSiteLicense ** SOAP_FMAC4 soap_in_PointerTons1__TrsSiteLicense(struct soap *soap, const char *tag, ns1__TrsSiteLicense **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsSiteLicense **)soap_malloc(soap, sizeof(ns1__TrsSiteLicense *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TrsSiteLicense *)rrapi__instantiate_ns1__TrsSiteLicense(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TrsSiteLicense **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsSiteLicense, sizeof(ns1__TrsSiteLicense), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TrsSiteLicense(soap, tag ? tag : "ns1:TrsSiteLicense", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsSiteLicense ** SOAP_FMAC4 soap_get_PointerTons1__TrsSiteLicense(struct soap *soap, ns1__TrsSiteLicense **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TrsSiteLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__TrsSiteFreq))
		soap_serialize_PointerTons1__TrsSiteFreq(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__TrsSiteFreq(struct soap *soap, const char *tag, int id, ns1__TrsSiteFreq **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__TrsSiteFreq, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__TrsSiteFreq(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__TrsSiteFreq *** SOAP_FMAC4 soap_in_PointerToPointerTons1__TrsSiteFreq(struct soap *soap, const char *tag, ns1__TrsSiteFreq ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsSiteFreq ***)soap_malloc(soap, sizeof(ns1__TrsSiteFreq **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__TrsSiteFreq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__TrsSiteFreq ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsSiteFreq, sizeof(ns1__TrsSiteFreq), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__TrsSiteFreq(soap, tag ? tag : "ns1:TrsSiteFreq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsSiteFreq *** SOAP_FMAC4 soap_get_PointerToPointerTons1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__TrsSiteFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TrsSiteFreq))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TrsSiteFreq(struct soap *soap, const char *tag, int id, ns1__TrsSiteFreq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TrsSiteFreq, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TrsSiteFreq ? type : NULL);
}

SOAP_FMAC3 ns1__TrsSiteFreq ** SOAP_FMAC4 soap_in_PointerTons1__TrsSiteFreq(struct soap *soap, const char *tag, ns1__TrsSiteFreq **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsSiteFreq **)soap_malloc(soap, sizeof(ns1__TrsSiteFreq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TrsSiteFreq *)rrapi__instantiate_ns1__TrsSiteFreq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TrsSiteFreq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsSiteFreq, sizeof(ns1__TrsSiteFreq), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TrsSiteFreq(soap, tag ? tag : "ns1:TrsSiteFreq", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsSiteFreq ** SOAP_FMAC4 soap_get_PointerTons1__TrsSiteFreq(struct soap *soap, ns1__TrsSiteFreq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TrsSiteFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__TrsSite(struct soap *soap, ns1__TrsSite **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__TrsSite))
		soap_serialize_PointerTons1__TrsSite(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__TrsSite(struct soap *soap, const char *tag, int id, ns1__TrsSite **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__TrsSite, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__TrsSite(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__TrsSite *** SOAP_FMAC4 soap_in_PointerToPointerTons1__TrsSite(struct soap *soap, const char *tag, ns1__TrsSite ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsSite ***)soap_malloc(soap, sizeof(ns1__TrsSite **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__TrsSite(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__TrsSite ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsSite, sizeof(ns1__TrsSite), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__TrsSite(struct soap *soap, ns1__TrsSite **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__TrsSite(soap, tag ? tag : "ns1:TrsSite", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsSite *** SOAP_FMAC4 soap_get_PointerToPointerTons1__TrsSite(struct soap *soap, ns1__TrsSite ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__TrsSite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TrsSite(struct soap *soap, ns1__TrsSite *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TrsSite))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TrsSite(struct soap *soap, const char *tag, int id, ns1__TrsSite *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TrsSite, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TrsSite ? type : NULL);
}

SOAP_FMAC3 ns1__TrsSite ** SOAP_FMAC4 soap_in_PointerTons1__TrsSite(struct soap *soap, const char *tag, ns1__TrsSite **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsSite **)soap_malloc(soap, sizeof(ns1__TrsSite *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TrsSite *)rrapi__instantiate_ns1__TrsSite(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TrsSite **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsSite, sizeof(ns1__TrsSite), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TrsSite(struct soap *soap, ns1__TrsSite *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TrsSite(soap, tag ? tag : "ns1:TrsSite", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsSite ** SOAP_FMAC4 soap_get_PointerTons1__TrsSite(struct soap *soap, ns1__TrsSite **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TrsSite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__TalkgroupCat))
		soap_serialize_PointerTons1__TalkgroupCat(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__TalkgroupCat(struct soap *soap, const char *tag, int id, ns1__TalkgroupCat **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__TalkgroupCat, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__TalkgroupCat(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__TalkgroupCat *** SOAP_FMAC4 soap_in_PointerToPointerTons1__TalkgroupCat(struct soap *soap, const char *tag, ns1__TalkgroupCat ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TalkgroupCat ***)soap_malloc(soap, sizeof(ns1__TalkgroupCat **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__TalkgroupCat(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__TalkgroupCat ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TalkgroupCat, sizeof(ns1__TalkgroupCat), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__TalkgroupCat(soap, tag ? tag : "ns1:TalkgroupCat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TalkgroupCat *** SOAP_FMAC4 soap_get_PointerToPointerTons1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__TalkgroupCat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TalkgroupCat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TalkgroupCat(struct soap *soap, const char *tag, int id, ns1__TalkgroupCat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TalkgroupCat, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TalkgroupCat ? type : NULL);
}

SOAP_FMAC3 ns1__TalkgroupCat ** SOAP_FMAC4 soap_in_PointerTons1__TalkgroupCat(struct soap *soap, const char *tag, ns1__TalkgroupCat **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TalkgroupCat **)soap_malloc(soap, sizeof(ns1__TalkgroupCat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TalkgroupCat *)rrapi__instantiate_ns1__TalkgroupCat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TalkgroupCat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TalkgroupCat, sizeof(ns1__TalkgroupCat), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TalkgroupCat(soap, tag ? tag : "ns1:TalkgroupCat", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TalkgroupCat ** SOAP_FMAC4 soap_get_PointerTons1__TalkgroupCat(struct soap *soap, ns1__TalkgroupCat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TalkgroupCat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__Talkgroup(struct soap *soap, ns1__Talkgroup **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__Talkgroup))
		soap_serialize_PointerTons1__Talkgroup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__Talkgroup(struct soap *soap, const char *tag, int id, ns1__Talkgroup **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__Talkgroup, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__Talkgroup(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__Talkgroup *** SOAP_FMAC4 soap_in_PointerToPointerTons1__Talkgroup(struct soap *soap, const char *tag, ns1__Talkgroup ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Talkgroup ***)soap_malloc(soap, sizeof(ns1__Talkgroup **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__Talkgroup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__Talkgroup ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Talkgroup, sizeof(ns1__Talkgroup), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__Talkgroup(struct soap *soap, ns1__Talkgroup **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__Talkgroup(soap, tag ? tag : "ns1:Talkgroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Talkgroup *** SOAP_FMAC4 soap_get_PointerToPointerTons1__Talkgroup(struct soap *soap, ns1__Talkgroup ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__Talkgroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Talkgroup(struct soap *soap, ns1__Talkgroup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Talkgroup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Talkgroup(struct soap *soap, const char *tag, int id, ns1__Talkgroup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Talkgroup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Talkgroup ? type : NULL);
}

SOAP_FMAC3 ns1__Talkgroup ** SOAP_FMAC4 soap_in_PointerTons1__Talkgroup(struct soap *soap, const char *tag, ns1__Talkgroup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Talkgroup **)soap_malloc(soap, sizeof(ns1__Talkgroup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Talkgroup *)rrapi__instantiate_ns1__Talkgroup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Talkgroup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Talkgroup, sizeof(ns1__Talkgroup), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Talkgroup(struct soap *soap, ns1__Talkgroup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Talkgroup(soap, tag ? tag : "ns1:Talkgroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Talkgroup ** SOAP_FMAC4 soap_get_PointerTons1__Talkgroup(struct soap *soap, ns1__Talkgroup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Talkgroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ctid(struct soap *soap, ns1__ctid **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ctid))
		soap_serialize_PointerTons1__ctid(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ctid(struct soap *soap, const char *tag, int id, ns1__ctid **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ctid, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ctid(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ctid *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ctid(struct soap *soap, const char *tag, ns1__ctid ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ctid ***)soap_malloc(soap, sizeof(ns1__ctid **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ctid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ctid ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ctid, sizeof(ns1__ctid), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ctid(struct soap *soap, ns1__ctid **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__ctid(soap, tag ? tag : "ns1:ctid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ctid *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ctid(struct soap *soap, ns1__ctid ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ctid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ctid(struct soap *soap, ns1__ctid *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ctid))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ctid(struct soap *soap, const char *tag, int id, ns1__ctid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ctid, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ctid ? type : NULL);
}

SOAP_FMAC3 ns1__ctid ** SOAP_FMAC4 soap_in_PointerTons1__ctid(struct soap *soap, const char *tag, ns1__ctid **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ctid **)soap_malloc(soap, sizeof(ns1__ctid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ctid *)rrapi__instantiate_ns1__ctid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ctid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ctid, sizeof(ns1__ctid), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ctid(struct soap *soap, ns1__ctid *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ctid(soap, tag ? tag : "ns1:ctid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ctid ** SOAP_FMAC4 soap_get_PointerTons1__ctid(struct soap *soap, ns1__ctid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ctid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__stid(struct soap *soap, ns1__stid **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__stid))
		soap_serialize_PointerTons1__stid(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__stid(struct soap *soap, const char *tag, int id, ns1__stid **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__stid, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__stid(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__stid *** SOAP_FMAC4 soap_in_PointerToPointerTons1__stid(struct soap *soap, const char *tag, ns1__stid ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__stid ***)soap_malloc(soap, sizeof(ns1__stid **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__stid(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__stid ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__stid, sizeof(ns1__stid), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__stid(struct soap *soap, ns1__stid **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__stid(soap, tag ? tag : "ns1:stid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__stid *** SOAP_FMAC4 soap_get_PointerToPointerTons1__stid(struct soap *soap, ns1__stid ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__stid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__stid(struct soap *soap, ns1__stid *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__stid))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__stid(struct soap *soap, const char *tag, int id, ns1__stid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__stid, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__stid ? type : NULL);
}

SOAP_FMAC3 ns1__stid ** SOAP_FMAC4 soap_in_PointerTons1__stid(struct soap *soap, const char *tag, ns1__stid **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__stid **)soap_malloc(soap, sizeof(ns1__stid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__stid *)rrapi__instantiate_ns1__stid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__stid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__stid, sizeof(ns1__stid), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__stid(struct soap *soap, ns1__stid *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__stid(soap, tag ? tag : "ns1:stid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__stid ** SOAP_FMAC4 soap_get_PointerTons1__stid(struct soap *soap, ns1__stid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__stid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__userFeedBroadcast))
		soap_serialize_PointerTons1__userFeedBroadcast(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__userFeedBroadcast(struct soap *soap, const char *tag, int id, ns1__userFeedBroadcast **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__userFeedBroadcast, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__userFeedBroadcast(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__userFeedBroadcast *** SOAP_FMAC4 soap_in_PointerToPointerTons1__userFeedBroadcast(struct soap *soap, const char *tag, ns1__userFeedBroadcast ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userFeedBroadcast ***)soap_malloc(soap, sizeof(ns1__userFeedBroadcast **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__userFeedBroadcast(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__userFeedBroadcast ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userFeedBroadcast, sizeof(ns1__userFeedBroadcast), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToPointerTons1__userFeedBroadcast(soap, tag ? tag : "ns1:userFeedBroadcast", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__userFeedBroadcast *** SOAP_FMAC4 soap_get_PointerToPointerTons1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__userFeedBroadcast(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__userFeedBroadcast))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__userFeedBroadcast(struct soap *soap, const char *tag, int id, ns1__userFeedBroadcast *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__userFeedBroadcast, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__userFeedBroadcast ? type : NULL);
}

SOAP_FMAC3 ns1__userFeedBroadcast ** SOAP_FMAC4 soap_in_PointerTons1__userFeedBroadcast(struct soap *soap, const char *tag, ns1__userFeedBroadcast **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__userFeedBroadcast **)soap_malloc(soap, sizeof(ns1__userFeedBroadcast *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__userFeedBroadcast *)rrapi__instantiate_ns1__userFeedBroadcast(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__userFeedBroadcast **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__userFeedBroadcast, sizeof(ns1__userFeedBroadcast), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__userFeedBroadcast(soap, tag ? tag : "ns1:userFeedBroadcast", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__userFeedBroadcast ** SOAP_FMAC4 soap_get_PointerTons1__userFeedBroadcast(struct soap *soap, ns1__userFeedBroadcast **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__userFeedBroadcast(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofccFrequencies(struct soap *soap, fccFrequencies *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofccFrequencies(struct soap *soap, const char *tag, int id, fccFrequencies *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_fccFrequencies, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_fccFrequencies ? type : NULL);
}

SOAP_FMAC3 fccFrequencies ** SOAP_FMAC4 soap_in_PointerTofccFrequencies(struct soap *soap, const char *tag, fccFrequencies **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fccFrequencies **)soap_malloc(soap, sizeof(fccFrequencies *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fccFrequencies *)rrapi__instantiate_fccFrequencies(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (fccFrequencies **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fccFrequencies, sizeof(fccFrequencies), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofccFrequencies(struct soap *soap, fccFrequencies *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofccFrequencies(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fccFrequencies ** SOAP_FMAC4 soap_get_PointerTofccFrequencies(struct soap *soap, fccFrequencies **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofccFrequencies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofccLocations(struct soap *soap, fccLocations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofccLocations(struct soap *soap, const char *tag, int id, fccLocations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_fccLocations, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_fccLocations ? type : NULL);
}

SOAP_FMAC3 fccLocations ** SOAP_FMAC4 soap_in_PointerTofccLocations(struct soap *soap, const char *tag, fccLocations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (fccLocations **)soap_malloc(soap, sizeof(fccLocations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (fccLocations *)rrapi__instantiate_fccLocations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (fccLocations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_fccLocations, sizeof(fccLocations), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofccLocations(struct soap *soap, fccLocations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofccLocations(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 fccLocations ** SOAP_FMAC4 soap_get_PointerTofccLocations(struct soap *soap, fccLocations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofccLocations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCounties(struct soap *soap, Counties *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCounties(struct soap *soap, const char *tag, int id, Counties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Counties, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Counties ? type : NULL);
}

SOAP_FMAC3 Counties ** SOAP_FMAC4 soap_in_PointerToCounties(struct soap *soap, const char *tag, Counties **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Counties **)soap_malloc(soap, sizeof(Counties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Counties *)rrapi__instantiate_Counties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Counties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Counties, sizeof(Counties), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCounties(struct soap *soap, Counties *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToCounties(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Counties ** SOAP_FMAC4 soap_get_PointerToCounties(struct soap *soap, Counties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCounties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsList(struct soap *soap, TrsList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsList(struct soap *soap, const char *tag, int id, TrsList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsList, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsList ? type : NULL);
}

SOAP_FMAC3 TrsList ** SOAP_FMAC4 soap_in_PointerToTrsList(struct soap *soap, const char *tag, TrsList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsList **)soap_malloc(soap, sizeof(TrsList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsList *)rrapi__instantiate_TrsList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsList, sizeof(TrsList), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsList(struct soap *soap, TrsList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsList(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsList ** SOAP_FMAC4 soap_get_PointerToTrsList(struct soap *soap, TrsList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToStates(struct soap *soap, States *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToStates(struct soap *soap, const char *tag, int id, States *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_States, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_States ? type : NULL);
}

SOAP_FMAC3 States ** SOAP_FMAC4 soap_in_PointerToStates(struct soap *soap, const char *tag, States **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (States **)soap_malloc(soap, sizeof(States *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (States *)rrapi__instantiate_States(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (States **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_States, sizeof(States), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToStates(struct soap *soap, States *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToStates(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 States ** SOAP_FMAC4 soap_get_PointerToStates(struct soap *soap, States **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToAgencies(struct soap *soap, Agencies *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToAgencies(struct soap *soap, const char *tag, int id, Agencies *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Agencies, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Agencies ? type : NULL);
}

SOAP_FMAC3 Agencies ** SOAP_FMAC4 soap_in_PointerToAgencies(struct soap *soap, const char *tag, Agencies **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Agencies **)soap_malloc(soap, sizeof(Agencies *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Agencies *)rrapi__instantiate_Agencies(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Agencies **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Agencies, sizeof(Agencies), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToAgencies(struct soap *soap, Agencies *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToAgencies(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Agencies ** SOAP_FMAC4 soap_get_PointerToAgencies(struct soap *soap, Agencies **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToAgencies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToCats(struct soap *soap, Cats *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToCats(struct soap *soap, const char *tag, int id, Cats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_Cats, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_Cats ? type : NULL);
}

SOAP_FMAC3 Cats ** SOAP_FMAC4 soap_in_PointerToCats(struct soap *soap, const char *tag, Cats **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Cats **)soap_malloc(soap, sizeof(Cats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Cats *)rrapi__instantiate_Cats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (Cats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Cats, sizeof(Cats), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToCats(struct soap *soap, Cats *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToCats(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Cats ** SOAP_FMAC4 soap_get_PointerToCats(struct soap *soap, Cats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToCats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTosids(struct soap *soap, sids *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTosids(struct soap *soap, const char *tag, int id, sids *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_sids, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_sids ? type : NULL);
}

SOAP_FMAC3 sids ** SOAP_FMAC4 soap_in_PointerTosids(struct soap *soap, const char *tag, sids **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (sids **)soap_malloc(soap, sizeof(sids *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (sids *)rrapi__instantiate_sids(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (sids **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_sids, sizeof(sids), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTosids(struct soap *soap, sids *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTosids(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 sids ** SOAP_FMAC4 soap_get_PointerTosids(struct soap *soap, sids **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTosids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSubCats(struct soap *soap, SubCats *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSubCats(struct soap *soap, const char *tag, int id, SubCats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_SubCats, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_SubCats ? type : NULL);
}

SOAP_FMAC3 SubCats ** SOAP_FMAC4 soap_in_PointerToSubCats(struct soap *soap, const char *tag, SubCats **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (SubCats **)soap_malloc(soap, sizeof(SubCats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (SubCats *)rrapi__instantiate_SubCats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (SubCats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SubCats, sizeof(SubCats), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSubCats(struct soap *soap, SubCats *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSubCats(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 SubCats ** SOAP_FMAC4 soap_get_PointerToSubCats(struct soap *soap, SubCats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSubCats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TrsFleetmap(struct soap *soap, ns1__TrsFleetmap *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TrsFleetmap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TrsFleetmap(struct soap *soap, const char *tag, int id, ns1__TrsFleetmap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TrsFleetmap, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__TrsFleetmap ? type : NULL);
}

SOAP_FMAC3 ns1__TrsFleetmap ** SOAP_FMAC4 soap_in_PointerTons1__TrsFleetmap(struct soap *soap, const char *tag, ns1__TrsFleetmap **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TrsFleetmap **)soap_malloc(soap, sizeof(ns1__TrsFleetmap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TrsFleetmap *)rrapi__instantiate_ns1__TrsFleetmap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__TrsFleetmap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TrsFleetmap, sizeof(ns1__TrsFleetmap), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TrsFleetmap(struct soap *soap, ns1__TrsFleetmap *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__TrsFleetmap(soap, tag ? tag : "ns1:TrsFleetmap", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TrsFleetmap ** SOAP_FMAC4 soap_get_PointerTons1__TrsFleetmap(struct soap *soap, ns1__TrsFleetmap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TrsFleetmap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsSysid(struct soap *soap, TrsSysid *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsSysid(struct soap *soap, const char *tag, int id, TrsSysid *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsSysid, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsSysid ? type : NULL);
}

SOAP_FMAC3 TrsSysid ** SOAP_FMAC4 soap_in_PointerToTrsSysid(struct soap *soap, const char *tag, TrsSysid **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsSysid **)soap_malloc(soap, sizeof(TrsSysid *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsSysid *)rrapi__instantiate_TrsSysid(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsSysid **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsSysid, sizeof(TrsSysid), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsSysid(struct soap *soap, TrsSysid *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsSysid(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsSysid ** SOAP_FMAC4 soap_get_PointerToTrsSysid(struct soap *soap, TrsSysid **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsSysid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostids(struct soap *soap, stids *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostids(struct soap *soap, const char *tag, int id, stids *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_stids, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_stids ? type : NULL);
}

SOAP_FMAC3 stids ** SOAP_FMAC4 soap_in_PointerTostids(struct soap *soap, const char *tag, stids **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (stids **)soap_malloc(soap, sizeof(stids *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (stids *)rrapi__instantiate_stids(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (stids **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_stids, sizeof(stids), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostids(struct soap *soap, stids *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostids(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 stids ** SOAP_FMAC4 soap_get_PointerTostids(struct soap *soap, stids **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToctids(struct soap *soap, ctids *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToctids(struct soap *soap, const char *tag, int id, ctids *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_ctids, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ctids ? type : NULL);
}

SOAP_FMAC3 ctids ** SOAP_FMAC4 soap_in_PointerToctids(struct soap *soap, const char *tag, ctids **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ctids **)soap_malloc(soap, sizeof(ctids *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ctids *)rrapi__instantiate_ctids(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ctids **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ctids, sizeof(ctids), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToctids(struct soap *soap, ctids *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToctids(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ctids ** SOAP_FMAC4 soap_get_PointerToctids(struct soap *soap, ctids **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToctids(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsBandplan(struct soap *soap, TrsBandplan *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsBandplan(struct soap *soap, const char *tag, int id, TrsBandplan *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsBandplan, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsBandplan ? type : NULL);
}

SOAP_FMAC3 TrsBandplan ** SOAP_FMAC4 soap_in_PointerToTrsBandplan(struct soap *soap, const char *tag, TrsBandplan **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsBandplan **)soap_malloc(soap, sizeof(TrsBandplan *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsBandplan *)rrapi__instantiate_TrsBandplan(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsBandplan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsBandplan, sizeof(TrsBandplan), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsBandplan(struct soap *soap, TrsBandplan *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsBandplan(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsBandplan ** SOAP_FMAC4 soap_get_PointerToTrsBandplan(struct soap *soap, TrsBandplan **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsBandplan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsSiteFreqs(struct soap *soap, TrsSiteFreqs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsSiteFreqs(struct soap *soap, const char *tag, int id, TrsSiteFreqs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsSiteFreqs, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsSiteFreqs ? type : NULL);
}

SOAP_FMAC3 TrsSiteFreqs ** SOAP_FMAC4 soap_in_PointerToTrsSiteFreqs(struct soap *soap, const char *tag, TrsSiteFreqs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsSiteFreqs **)soap_malloc(soap, sizeof(TrsSiteFreqs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsSiteFreqs *)rrapi__instantiate_TrsSiteFreqs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsSiteFreqs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsSiteFreqs, sizeof(TrsSiteFreqs), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsSiteFreqs(struct soap *soap, TrsSiteFreqs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsSiteFreqs(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsSiteFreqs ** SOAP_FMAC4 soap_get_PointerToTrsSiteFreqs(struct soap *soap, TrsSiteFreqs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsSiteFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToTrsSiteLicenses(struct soap *soap, TrsSiteLicenses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToTrsSiteLicenses(struct soap *soap, const char *tag, int id, TrsSiteLicenses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_TrsSiteLicenses, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_TrsSiteLicenses ? type : NULL);
}

SOAP_FMAC3 TrsSiteLicenses ** SOAP_FMAC4 soap_in_PointerToTrsSiteLicenses(struct soap *soap, const char *tag, TrsSiteLicenses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (TrsSiteLicenses **)soap_malloc(soap, sizeof(TrsSiteLicenses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (TrsSiteLicenses *)rrapi__instantiate_TrsSiteLicenses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (TrsSiteLicenses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_TrsSiteLicenses, sizeof(TrsSiteLicenses), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToTrsSiteLicenses(struct soap *soap, TrsSiteLicenses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToTrsSiteLicenses(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 TrsSiteLicenses ** SOAP_FMAC4 soap_get_PointerToTrsSiteLicenses(struct soap *soap, TrsSiteLicenses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToTrsSiteLicenses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotags(struct soap *soap, tags *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotags(struct soap *soap, const char *tag, int id, tags *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_tags, NULL);
	if (!*a || id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tags ? type : NULL);
}

SOAP_FMAC3 tags ** SOAP_FMAC4 soap_in_PointerTotags(struct soap *soap, const char *tag, tags **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tags **)soap_malloc(soap, sizeof(tags *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tags *)rrapi__instantiate_tags(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tags **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tags, sizeof(tags), 0, rrapi__fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotags(struct soap *soap, tags *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotags(soap, tag ? tag : "SOAP-ENC:Array", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tags ** SOAP_FMAC4 soap_get_PointerTotags(struct soap *soap, tags **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotags(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of rrapi_C.cpp */
